---------------hibernate-orm Summary----------------
Number of Nested Try: 282
Number of Destructive Wrapping: 163
Number of Over Catch: 288
----------------------------------------------------
---------------NESTED TRY--------------
====================================================
BeanInfoHelper.java at Line:52 col: 2
try {
  BeanInfo info=Introspector.getBeanInfo(beanClass,stopClass);
  try {
    delegate.processBeanInfo(info);
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  InvocationTargetException e) {
    throw new BeanIntrospectionException("Error delegating bean info use",e.getTargetException());
  }
catch (  Exception e) {
    throw new BeanIntrospectionException("Error delegating bean info use",e);
  }
 finally {
    Introspector.flushFromCaches(beanClass);
  }
}
 catch (IntrospectionException e) {
  throw new BeanIntrospectionException("Unable to determine bean info from class [" + beanClass.getName() + "]",e);
}

====================================================
ParameterCollectionTest.java at Line:40 col: 2
try (Session session=openSession()){
  session.beginTransaction();
  try {
    for (int i=0; i < 20; i++) {
      Person p1=new Person(i,"p" + i);
      session.save(p1);
    }
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().isActive()) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
HSQLStoreProcedureTest.java at Line:88 col: 2
try {
  StoredProcedureQuery query=em.createNamedStoredProcedureQuery("User.inoutproc");
  final Set<Parameter<?>> parameters=query.getParameters();
  assertThat(parameters.size(),is(2));
  assertThat(query.getParameter("arg1"),not(nullValue()));
  assertThat(query.getParameter("res"),not(nullValue()));
  assertThat(query.getParameter("arg1",Integer.class),not(nullValue()));
  try {
    query.getParameter("arg1",String.class);
    fail("An IllegalArgumentException is expected, A parameter with name arg1 and type String does not exist");
  }
 catch (  IllegalArgumentException iae) {
  }
  try {
    query.getParameter("arg2");
    fail("An IllegalArgumentException is expected, A parameter with name arg2 does not exist");
  }
 catch (  IllegalArgumentException iae) {
  }
}
  finally {
  em.close();
}

====================================================
OracleExtractSequenceMetadataTest.java at Line:61 col: 3
try (Statement stmt=conn.createStatement()){
  try {
    stmt.execute(String.format("DROP USER %s CASCADE",OTHER_SCHEMA_NAME));
  }
 catch (  Exception ignore) {
  }
  stmt.execute(String.format("CREATE USER %s IDENTIFIED BY whatever",OTHER_SCHEMA_NAME));
  stmt.execute(String.format("CREATE SEQUENCE %s.%s START WITH 1 INCREMENT BY %s",OTHER_SCHEMA_NAME,SEQUENCE_NAME,SEQUENCE_INCREMENT_SIZE_FROM_OTHER_SCHEMA));
  try {
    stmt.execute(String.format("DROP SEQUENCE %s",SEQUENCE_NAME));
  }
 catch (  Exception ignore) {
  }
}
 
====================================================
SQLServerDialectCollationTest.java at Line:57 col: 2
try {
  try (Connection connection=_serviceRegistry.getService(JdbcServices.class).getBootstrapJdbcConnectionAccess().obtainConnection();Statement statement=connection.createStatement()){
    connection.setAutoCommit(true);
    statement.executeUpdate("DROP DATABASE hibernate_orm_test_collation");
  }
 catch (  SQLException e) {
    log.debug(e.getMessage());
  }
  try (Connection connection=_serviceRegistry.getService(JdbcServices.class).getBootstrapJdbcConnectionAccess().obtainConnection();Statement statement=connection.createStatement()){
    connection.setAutoCommit(true);
    statement.executeUpdate("CREATE DATABASE hibernate_orm_test_collation COLLATE Latin1_General_CS_AS");
    statement.executeUpdate("ALTER DATABASE [hibernate_orm_test_collation] SET AUTO_CLOSE OFF ");
  }
 catch (  SQLException e) {
    log.debug(e.getMessage());
  }
}
  finally {
  _serviceRegistry.destroy();
}

====================================================
DateTimeParameterTest.java at Line:147 col: 3
try {
  Statement statement=conn.createStatement();
  try {
    dropProcedures(statement);
  }
 catch (  SQLException ignore) {
  }
  statement.execute("CREATE PROCEDURE findMessagesByDate(IN chkDt DATE) " + "language java " + "dynamic result sets 1 "+ "external name 'org.hibernate.jpa.test.procedure.DateTimeParameterTest.findMessagesByDate' "+ "parameter style java");
  statement.execute("CREATE PROCEDURE findMessagesByTime(IN chkTime TIME) " + "language java " + "dynamic result sets 1 "+ "external name 'org.hibernate.jpa.test.procedure.DateTimeParameterTest.findMessagesByTime' "+ "parameter style java");
  statement.execute("CREATE PROCEDURE findMessagesByTimestampRange(IN startDt TIMESTAMP, IN endDt TIMESTAMP) " + "language java " + "dynamic result sets 1 "+ "external name 'org.hibernate.jpa.test.procedure.DateTimeParameterTest.findMessagesByTimestampRange' "+ "parameter style java");
  statement.execute("CREATE PROCEDURE retrieveTimestamp(IN ts1 TIMESTAMP, OUT ts2 TIMESTAMP) " + "language java " + "dynamic result sets 0 "+ "external name 'org.hibernate.jpa.test.procedure.DateTimeParameterTest.retrieveTimestamp' "+ "parameter style java");
  try {
    statement.close();
  }
 catch (  SQLException ignore) {
  }
}
  finally {
  try {
    conn.commit();
  }
 catch (  SQLException e) {
    System.out.println("Unable to commit transaction after creating creating procedures");
  }
  try {
    connectionAccess.releaseConnection(conn);
  }
 catch (  SQLException ignore) {
  }
}

====================================================
HANAStoredProcedureTest.java at Line:291 col: 2
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (Statement statement=connection.createStatement()){
      statement.executeUpdate("DROP PROCEDURE singleRefCursor");
    }
 catch (    SQLException ignore) {
    }
  }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
LockTest.java at Line:710 col: 2
try {
  lock.setName("testContendedPessimisticReadLockTimeout");
  doInJPA(this::entityManagerFactory,em -> {
    em.persist(lock);
  }
);
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.lock(_lock,LockModeType.PESSIMISTIC_WRITE);
    final Integer id=_lock.getId();
    _lock.getName();
    log.info("testContendedPessimisticReadLockTimeout: got write lock");
    try {
      t.start();
      boolean latchSet=latch.await(10,TimeUnit.SECONDS);
      assertTrue("background test thread finished (lock timeout is broken)",latchSet);
      assertTrue("background test thread timed out on lock attempt",bgTask.get());
    }
 catch (    InterruptedException e) {
      Thread.interrupted();
    }
catch (    ExecutionException e) {
      fail(e.getMessage());
    }
  }
);
}
  finally {
  t.join();
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.remove(_lock);
  }
);
}

====================================================
SchemaUpdateSchemaNameTest.java at Line:66 col: 2
try {
  final Configuration cfg=buildConfiguration(SimpleFirst.class);
  ssr=new StandardServiceRegistryBuilder(new BootstrapServiceRegistryBuilder().build(),cfg.getStandardServiceRegistryBuilder().getAggregatedCfgXml()).applySettings(cfg.getProperties()).build();
  SessionFactory sf=cfg.buildSessionFactory(ssr);
  try {
    Session session=sf.openSession();
    try {
      session.getTransaction().begin();
      session.createNativeQuery("DROP TABLE Simple").executeUpdate();
      session.getTransaction().commit();
    }
 catch (    Throwable t) {
      if (session.getTransaction().isActive()) {
        session.getTransaction().rollback();
      }
      throw t;
    }
 finally {
      session.close();
    }
  }
  finally {
    sf.close();
  }
}
  finally {
  StandardServiceRegistryBuilder.destroy(ssr);
}

====================================================
CascadeTest.java at Line:154 col: 2
try {
  Session s=openSession();
  s.beginTransaction();
  ParentAssigned p=new ParentAssigned(new Long(1),"parent");
  ParentInfoAssigned info=new ParentInfoAssigned("something secret");
  p.setInfo(info);
  info.setOwner(p);
  s.persist(p);
  try {
    s.getTransaction().commit();
    fail("expecting TransientObjectException on flush");
  }
 catch (  TransientObjectException e) {
    log.trace("handled expected exception",e);
    s.getTransaction().rollback();
  }
 finally {
    s.close();
  }
}
  finally {
  cleanupData();
}

====================================================
BeanValidationIntegrator.java at Line:53 col: 3
try {
  final Method validateMethod=activatorClass.getMethod(VALIDATE_SUPPLIED_FACTORY_METHOD_NAME,Object.class);
  try {
    validateMethod.invoke(null,object);
  }
 catch (  InvocationTargetException e) {
    if (e.getTargetException() instanceof HibernateException) {
      throw (HibernateException)e.getTargetException();
    }
    throw new HibernateException("Unable to check validity of passed ValidatorFactory",e);
  }
catch (  IllegalAccessException e) {
    throw new HibernateException("Unable to check validity of passed ValidatorFactory",e);
  }
}
 catch (HibernateException e) {
  throw e;
}
catch (Exception e) {
  throw new HibernateException("Could not locate method needed for ValidatorFactory validation",e);
}

====================================================
BasicJdbcTransactionTests.java at Line:121 col: 2
try (final SessionFactoryImplementor sf=generateSessionFactory()){
  inSession(sf,session -> {
    final TransactionCoordinator coordinator=session.getTransactionCoordinator();
    assertEquals(TransactionStatus.NOT_ACTIVE,coordinator.getTransactionDriverControl().getStatus());
    coordinator.getLocalSynchronizations().registerSynchronization(SynchronizationErrorImpl.forBefore());
    coordinator.getTransactionDriverControl().begin();
    assertEquals(TransactionStatus.ACTIVE,coordinator.getTransactionDriverControl().getStatus());
    try {
      coordinator.getTransactionDriverControl().commit();
    }
 catch (    Exception expected) {
    }
 finally {
      assertThat(coordinator.getTransactionDriverControl().getStatus(),anyOf(is(TransactionStatus.NOT_ACTIVE),is(TransactionStatus.ROLLED_BACK)));
    }
  }
);
}
 
====================================================
SchemaUpdateSchemaNameTest.java at Line:116 col: 3
try {
  Session session=sf.openSession();
  try {
    session.getTransaction().begin();
    session.createQuery("FROM Simple",SimpleNext.class).getResultList();
    session.getTransaction().commit();
  }
 catch (  Throwable t) {
    if (session.getTransaction().isActive()) {
      session.getTransaction().rollback();
    }
    throw t;
  }
 finally {
    session.close();
  }
}
  finally {
  sf.close();
}

====================================================
OneToOneTest.java at Line:237 col: 2
try (Session s=openSession()){
  s.getTransaction().begin();
  Trousers trousers=new Trousers();
  TrousersZip zip=new TrousersZip();
  try {
    trousers.id=1;
    zip.id=2;
    trousers.zip=zip;
    zip.trousers=trousers;
    s.persist(trousers);
    s.persist(zip);
    s.getTransaction().commit();
  }
 catch (  Exception e) {
    if (s.getTransaction() != null && s.getTransaction().isActive()) {
      s.getTransaction().rollback();
    }
    throw e;
  }
  s.clear();
  Transaction tx=s.beginTransaction();
  try {
    trousers=s.get(Trousers.class,trousers.id);
    assertNotNull(trousers.zip);
    assertEquals(zip.id,trousers.zip.id);
    s.clear();
    zip=s.get(TrousersZip.class,zip.id);
    assertNotNull(zip.trousers);
    assertEquals(trousers.id,zip.trousers.id);
    s.delete(zip);
    s.delete(zip.trousers);
    tx.commit();
  }
 catch (  Exception e) {
    if (s.getTransaction() != null && s.getTransaction().isActive()) {
      s.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
PessimisticReadUpdateLockingStrategy.java at Line:78 col: 2
try {
  try {
    final JdbcCoordinator jdbcCoordinator=session.getJdbcCoordinator();
    final PreparedStatement st=jdbcCoordinator.getStatementPreparer().prepareStatement(sql);
    try {
      lockable.getVersionType().nullSafeSet(st,version,1,session);
      int offset=2;
      lockable.getIdentifierType().nullSafeSet(st,id,offset,session);
      offset+=lockable.getIdentifierType().getColumnSpan(factory);
      if (lockable.isVersioned()) {
        lockable.getVersionType().nullSafeSet(st,version,offset,session);
      }
      final int affected=jdbcCoordinator.getResultSetReturn().executeUpdate(st);
      if (affected < 0) {
        final StatisticsImplementor statistics=factory.getStatistics();
        if (statistics.isStatisticsEnabled()) {
          statistics.optimisticFailure(lockable.getEntityName());
        }
        throw new StaleObjectStateException(lockable.getEntityName(),id);
      }
    }
  finally {
      jdbcCoordinator.getLogicalConnection().getResourceRegistry().release(st);
      jdbcCoordinator.afterStatementExecution();
    }
  }
 catch (  SQLException e) {
    throw session.getJdbcServices().getSqlExceptionHelper().convert(e,"could not lock: " + MessageHelper.infoString(lockable,id,session.getFactory()),sql);
  }
}
 catch (JDBCException e) {
  throw new PessimisticEntityLockException(object,"could not obtain pessimistic lock",e);
}

====================================================
DdlTransactionIsolatorNonJtaImpl.java at Line:42 col: 3
try {
  this.jdbcConnection=jdbcContext.getJdbcConnectionAccess().obtainConnection();
  try {
    if (!jdbcConnection.getAutoCommit()) {
      ConnectionAccessLogger.INSTANCE.informConnectionLocalTransactionForNonJtaDdl(jdbcContext.getJdbcConnectionAccess());
      try {
        jdbcConnection.commit();
        jdbcConnection.setAutoCommit(true);
      }
 catch (      SQLException e) {
        throw jdbcContext.getSqlExceptionHelper().convert(e,"Unable to set JDBC Connection into auto-commit mode in preparation for DDL execution");
      }
    }
  }
 catch (  SQLException e) {
    throw jdbcContext.getSqlExceptionHelper().convert(e,"Unable to check JDBC Connection auto-commit in preparation for DDL execution");
  }
}
 catch (SQLException e) {
  throw jdbcContext.getSqlExceptionHelper().convert(e,"Unable to open JDBC Connection for DDL execution");
}

====================================================
JoinedSubclassEntityPersister.java at Line:525 col: 3
try {
  if (persistentClass.isPolymorphic()) {
    final Object discriminatorValue;
    if (explicitDiscriminatorColumnName != null) {
      if (sc.isDiscriminatorValueNull()) {
        discriminatorValue=NULL_DISCRIMINATOR;
      }
 else       if (sc.isDiscriminatorValueNotNull()) {
        discriminatorValue=NOT_NULL_DISCRIMINATOR;
      }
 else {
        try {
          discriminatorValue=discriminatorType.stringToObject(sc.getDiscriminatorValue());
        }
 catch (        ClassCastException cce) {
          throw new MappingException("Illegal discriminator type: " + discriminatorType.getName());
        }
catch (        Exception e) {
          throw new MappingException("Could not format discriminator value to SQL string",e);
        }
      }
    }
 else {
      discriminatorValue=sc.getSubclassId();
    }
    subclassesByDiscriminatorValue.put(discriminatorValue,sc.getEntityName());
    discriminatorValues[k]=discriminatorValue.toString();
    int id=getTableId(sc.getTable().getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName()),subclassTableNameClosure);
    notNullColumnTableNumbers[k]=id;
    notNullColumnNames[k]=subclassTableKeyColumnClosure[id][0];
  }
}
 catch (Exception e) {
  throw new MappingException("Error parsing discriminator value",e);
}

====================================================
AbstractLazyInitializer.java at Line:195 col: 3
try {
  SessionFactoryImplementor sf=(SessionFactoryImplementor)SessionFactoryRegistry.INSTANCE.getSessionFactory(sessionFactoryUuid);
  SharedSessionContractImplementor session=(SharedSessionContractImplementor)sf.openSession();
  session.getPersistenceContext().setDefaultReadOnly(true);
  session.setFlushMode(FlushMode.MANUAL);
  boolean isJTA=session.getTransactionCoordinator().getTransactionCoordinatorBuilder().isJta();
  if (!isJTA) {
    session.beginTransaction();
  }
  try {
    target=session.immediateLoad(entityName,id);
    initialized=true;
    checkTargetState(session);
  }
  finally {
    try {
      if (!isJTA) {
        session.getTransaction().commit();
      }
      session.close();
    }
 catch (    Exception e) {
      LOG.warn("Unable to close temporary session used to load lazy proxy associated to no session");
    }
  }
}
 catch (Exception e) {
  LOG.error("Initialization failure [" + entityName + "#"+ id+ "]",e);
  throw new LazyInitializationException(e.getMessage());
}

====================================================
DateTimeParameterTest.java at Line:143 col: 2
try {
  conn=connectionAccess.obtainConnection();
  conn.setAutoCommit(false);
  try {
    Statement statement=conn.createStatement();
    try {
      dropProcedures(statement);
    }
 catch (    SQLException ignore) {
    }
    statement.execute("CREATE PROCEDURE findMessagesByDate(IN chkDt DATE) " + "language java " + "dynamic result sets 1 "+ "external name 'org.hibernate.jpa.test.procedure.DateTimeParameterTest.findMessagesByDate' "+ "parameter style java");
    statement.execute("CREATE PROCEDURE findMessagesByTime(IN chkTime TIME) " + "language java " + "dynamic result sets 1 "+ "external name 'org.hibernate.jpa.test.procedure.DateTimeParameterTest.findMessagesByTime' "+ "parameter style java");
    statement.execute("CREATE PROCEDURE findMessagesByTimestampRange(IN startDt TIMESTAMP, IN endDt TIMESTAMP) " + "language java " + "dynamic result sets 1 "+ "external name 'org.hibernate.jpa.test.procedure.DateTimeParameterTest.findMessagesByTimestampRange' "+ "parameter style java");
    statement.execute("CREATE PROCEDURE retrieveTimestamp(IN ts1 TIMESTAMP, OUT ts2 TIMESTAMP) " + "language java " + "dynamic result sets 0 "+ "external name 'org.hibernate.jpa.test.procedure.DateTimeParameterTest.retrieveTimestamp' "+ "parameter style java");
    try {
      statement.close();
    }
 catch (    SQLException ignore) {
    }
  }
  finally {
    try {
      conn.commit();
    }
 catch (    SQLException e) {
      System.out.println("Unable to commit transaction after creating creating procedures");
    }
    try {
      connectionAccess.releaseConnection(conn);
    }
 catch (    SQLException ignore) {
    }
  }
}
 catch (SQLException e) {
  throw new RuntimeException("Unable to create stored procedures",e);
}

====================================================
H2StoreProcedureTest.java at Line:123 col: 2
try {
  StoredProcedureQuery query=entityManager.createStoredProcedureQuery("by_Id",MyEntity.class);
  query.registerStoredProcedureParameter(1,Long.class,ParameterMode.IN);
  query.setParameter(1,1L);
  final List resultList=query.getResultList();
  assertThat(resultList.size(),is(1));
  final Set<Parameter<?>> parameters=query.getParameters();
  assertThat(parameters.size(),is(1));
  final Parameter<?> parameter=query.getParameter(1);
  assertThat(parameter,not(nullValue()));
  try {
    query.getParameter(2);
    fail("IllegalArgumentException expected, parameter at position 2 does not exist");
  }
 catch (  IllegalArgumentException iae) {
  }
}
  finally {
  entityManager.close();
}

====================================================
SessionImpl.java at Line:1961 col: 2
try {
  if (object instanceof HibernateProxy) {
    LazyInitializer li=((HibernateProxy)object).getHibernateLazyInitializer();
    if (li.isUninitialized()) {
      return li.getSession() == this;
    }
 else {
      object=li.getImplementation();
    }
  }
  EntityEntry entry=persistenceContext.getEntry(object);
  delayedAfterCompletion();
  if (entry == null) {
    if (!HibernateProxy.class.isInstance(object) && persistenceContext.getEntry(object) == null) {
      try {
        final String entityName=getEntityNameResolver().resolveEntityName(object);
        if (entityName == null) {
          throw new IllegalArgumentException("Could not resolve entity-name [" + object + "]");
        }
        getSessionFactory().getMetamodel().entityPersister(entityName);
      }
 catch (      HibernateException e) {
        throw new IllegalArgumentException("Not an entity [" + object.getClass() + "]",e);
      }
    }
    return false;
  }
 else {
    return entry.getStatus() != Status.DELETED && entry.getStatus() != Status.GONE;
  }
}
 catch (MappingException e) {
  throw new IllegalArgumentException(e.getMessage(),e);
}
catch (RuntimeException e) {
  throw getExceptionConverter().convert(e);
}

====================================================
SessionFactoryRegistry.java at Line:87 col: 2
try {
  jndiService.bind(name,instance);
  LOG.factoryBoundToJndiName(name);
  try {
    jndiService.addListener(name,listener);
  }
 catch (  Exception e) {
    LOG.couldNotBindJndiListener();
  }
}
 catch (JndiNameException e) {
  LOG.invalidJndiName(name,e);
}
catch (JndiException e) {
  LOG.unableToBindFactoryToJndi(e);
}

====================================================
DelayedCdiHostedConverterTest.java at Line:44 col: 2
try (final SeContainer cdiContainer=cdiInitializer.initialize()){
  BootstrapServiceRegistry bsr=new BootstrapServiceRegistryBuilder().build();
  final StandardServiceRegistry ssr=new StandardServiceRegistryBuilder(bsr).applySetting(AvailableSettings.HBM2DDL_AUTO,Action.CREATE_DROP).applySetting(AvailableSettings.CDI_BEAN_MANAGER,cdiContainer.getBeanManager()).applySetting(AvailableSettings.DELAY_CDI_ACCESS,"true").build();
  final SessionFactoryImplementor sessionFactory;
  try {
    sessionFactory=(SessionFactoryImplementor)new MetadataSources(ssr).addAnnotatedClass(TheEntity.class).buildMetadata().getSessionFactoryBuilder().build();
  }
 catch (  Exception e) {
    StandardServiceRegistryBuilder.destroy(ssr);
    throw e;
  }
  assertFalse(MonitorBean.wasInstantiated());
  assertEquals(0,MonitorBean.currentFromDbCount());
  assertEquals(0,MonitorBean.currentToDbCount());
  try {
    inTransaction(sessionFactory,session -> session.persist(new TheEntity(1,"me",5)));
    assertTrue(MonitorBean.wasInstantiated());
    assertEquals(0,MonitorBean.currentFromDbCount());
    assertEquals(1,MonitorBean.currentToDbCount());
    inTransaction(sessionFactory,session -> {
      TheEntity it=session.find(TheEntity.class,1);
      assertNotNull(it);
    }
);
    assertEquals(1,MonitorBean.currentFromDbCount());
    assertEquals(1,MonitorBean.currentToDbCount());
  }
  finally {
    inTransaction(sessionFactory,session -> {
      session.createQuery("delete TheEntity").executeUpdate();
    }
);
    sessionFactory.close();
  }
}
 
====================================================
MySQLStoredProcedureTest.java at Line:199 col: 2
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (Statement statement=connection.createStatement()){
      statement.executeUpdate("DROP FUNCTION IF EXISTS fn_count_phones");
    }
 catch (    SQLException ignore) {
    }
  }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
TransactionUtil.java at Line:343 col: 2
try {
  session=factorySupplier.get().openSession();
  function.beforeTransactionCompletion();
  txn=session.beginTransaction();
  function.accept(session);
  if (!txn.getRollbackOnly()) {
    txn.commit();
  }
 else {
    try {
      txn.rollback();
    }
 catch (    Exception e) {
      log.error("Rollback failure",e);
    }
  }
}
 catch (Throwable t) {
  if (txn != null && txn.isActive()) {
    try {
      txn.rollback();
    }
 catch (    Exception e) {
      log.error("Rollback failure",e);
    }
  }
  throw t;
}
 finally {
  function.afterTransactionCompletion();
  if (session != null) {
    session.close();
  }
}

====================================================
AbstractCollectionPersister.java at Line:1305 col: 2
try {
  Iterator entries=collection.entries(this);
  final JdbcCoordinator jdbcCoordinator=session.getJdbcCoordinator();
  if (entries.hasNext()) {
    Expectation expectation=Expectations.appropriateExpectation(getInsertCheckStyle());
    collection.preInsert(this);
    int i=0;
    int count=0;
    while (entries.hasNext()) {
      final Object entry=entries.next();
      if (collection.entryExists(entry,i)) {
        int offset=1;
        final PreparedStatement st;
        boolean callable=isInsertCallable();
        boolean useBatch=expectation.canBeBatched();
        String sql=getSQLInsertRowString();
        if (useBatch) {
          if (recreateBatchKey == null) {
            recreateBatchKey=new BasicBatchKey(getRole() + "#RECREATE",expectation);
          }
          st=jdbcCoordinator.getBatch(recreateBatchKey).getBatchStatement(sql,callable);
        }
 else {
          st=jdbcCoordinator.getStatementPreparer().prepareStatement(sql,callable);
        }
        try {
          offset+=expectation.prepare(st);
          int loc=writeKey(st,id,offset,session);
          if (hasIdentifier) {
            loc=writeIdentifier(st,collection.getIdentifier(entry,i),loc,session);
          }
          if (hasIndex) {
            loc=writeIndex(st,collection.getIndex(entry,i,this),loc,session);
          }
          loc=writeElement(st,collection.getElement(entry),loc,session);
          if (useBatch) {
            jdbcCoordinator.getBatch(recreateBatchKey).addToBatch();
          }
 else {
            expectation.verifyOutcome(jdbcCoordinator.getResultSetReturn().executeUpdate(st),st,-1);
          }
          collection.afterRowInsert(this,entry,i);
          count++;
        }
 catch (        SQLException sqle) {
          if (useBatch) {
            jdbcCoordinator.abortBatch();
          }
          throw sqle;
        }
 finally {
          if (!useBatch) {
            jdbcCoordinator.getResourceRegistry().release(st);
            jdbcCoordinator.afterStatementExecution();
          }
        }
      }
      i++;
    }
    LOG.debugf("Done inserting collection: %s rows inserted",count);
  }
 else {
    LOG.debug("Collection was empty");
  }
}
 catch (SQLException sqle) {
  throw sqlExceptionHelper.convert(sqle,"could not insert collection: " + MessageHelper.collectionInfoString(this,collection,id,session),getSQLInsertRowString());
}

====================================================
SingletonEhcacheRegionFactory.java at Line:37 col: 2
try {
  String configurationResourceName=getOptions().getServiceRegistry().getService(ConfigurationService.class).getSetting(EHCACHE_CONFIGURATION_RESOURCE_NAME,value -> value == null ? null : value.toString());
  if (configurationResourceName == null || configurationResourceName.length() == 0) {
    try {
      REFERENCE_COUNT.incrementAndGet();
      return CacheManager.create();
    }
 catch (    RuntimeException e) {
      REFERENCE_COUNT.decrementAndGet();
      throw e;
    }
  }
  URL url;
  try {
    url=new URL(configurationResourceName);
  }
 catch (  MalformedURLException e) {
    if (!configurationResourceName.startsWith("/")) {
      configurationResourceName="/" + configurationResourceName;
      LOG.debugf("prepending / to %s. It should be placed in the root of the classpath rather than in a package.",configurationResourceName);
    }
    url=loadResource(configurationResourceName);
  }
  try {
    REFERENCE_COUNT.incrementAndGet();
    Configuration config=HibernateEhcacheUtils.loadAndCorrectConfiguration(url);
    setCacheManagerNameIfNeeded(settings,config,properties);
    return CacheManager.create(config);
  }
 catch (  RuntimeException e) {
    REFERENCE_COUNT.decrementAndGet();
    throw e;
  }
}
 catch (net.sf.ehcache.CacheException e) {
  throw new CacheException(e);
}

====================================================
GenerationTargetToDatabase.java at Line:52 col: 2
try {
  final Statement jdbcStatement=jdbcStatement();
  jdbcStatement.execute(command);
  try {
    SQLWarning warnings=jdbcStatement.getWarnings();
    if (warnings != null) {
      ddlTransactionIsolator.getJdbcContext().getSqlExceptionHelper().logAndClearWarnings(jdbcStatement);
    }
  }
 catch (  SQLException e) {
    log.unableToLogSqlWarnings(e);
  }
}
 catch (SQLException e) {
  throw new CommandAcceptanceException("Error executing DDL \"" + command + "\" via JDBC Statement",e);
}

====================================================
NamedQueryTransactionFailureTest.java at Line:82 col: 2
try {
  doInJPA(this::entityManagerFactory,entityManager -> {
    try {
      Mockito.reset(transactionCoordinator);
      doThrow(IllegalStateException.class).when(transactionCoordinator).pulse();
      entityManager.createNamedQuery("NamedQuery");
    }
 catch (    Exception e) {
      assertEquals(IllegalArgumentException.class,e.getClass());
      assertEquals(IllegalStateException.class,e.getCause().getClass());
    }
  }
);
}
 catch (Exception ignore) {
}

====================================================
StoredProcedureNullParameterByNameTest.java at Line:110 col: 2
try {
  conn=connectionAccess.obtainConnection();
  conn.setAutoCommit(false);
  try {
    Statement statement=conn.createStatement();
    statement.execute(storedProc);
    try {
      statement.close();
    }
 catch (    SQLException ignore) {
      fail();
    }
  }
  finally {
    try {
      conn.commit();
    }
 catch (    SQLException e) {
      System.out.println("Unable to commit transaction after creating creating procedures");
      fail();
    }
    try {
      connectionAccess.releaseConnection(conn);
    }
 catch (    SQLException ignore) {
      fail();
    }
  }
}
 catch (SQLException e) {
  throw new RuntimeException("Unable to create stored procedures",e);
}

====================================================
OracleStoredProcedureTest.java at Line:293 col: 8
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (Statement statement=connection.createStatement()){
      statement.executeUpdate("DROP FUNCTION fn_count_phones");
    }
 catch (    SQLException ignore) {
    }
  }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
AbstractProducedQuery.java at Line:706 col: 2
try {
  if (getParameterMetadata().getPositionalParameterCount() == 0) {
    try {
      return getParameterMetadata().getQueryParameter(Integer.toString(position));
    }
 catch (    HibernateException e) {
      throw new QueryParameterException("could not locate parameter at position [" + position + "]");
    }
  }
  return getParameterMetadata().getQueryParameter(position);
}
 catch (HibernateException e) {
  throw getExceptionConverter().convert(e);
}

====================================================
ConfigLoader.java at Line:91 col: 2
try {
  final InputStream stream=url.openStream();
  try {
    final JaxbCfgHibernateConfiguration jaxbCfg=jaxbProcessorHolder.getValue().unmarshal(stream,new Origin(SourceType.URL,url.toExternalForm()));
    return LoadedConfig.consume(jaxbCfg);
  }
  finally {
    try {
      stream.close();
    }
 catch (    IOException e) {
      log.debug("Unable to close cfg.xml URL stream",e);
    }
  }
}
 catch (IOException e) {
  throw new ConfigurationException("Could not access given cfg.xml URL input stream",e);
}

====================================================
StoreProcedureOutParameterByNameTest.java at Line:135 col: 2
try {
  conn=connectionAccess.obtainConnection();
  conn.setAutoCommit(false);
  try {
    Statement statement=conn.createStatement();
    statement.execute(storedProc);
    try {
      statement.close();
    }
 catch (    SQLException ignore) {
      fail();
    }
  }
  finally {
    try {
      conn.commit();
    }
 catch (    SQLException e) {
      System.out.println("Unable to commit transaction after creating creating procedures");
      fail();
    }
    try {
      connectionAccess.releaseConnection(conn);
    }
 catch (    SQLException ignore) {
      fail();
    }
  }
}
 catch (SQLException e) {
  throw new RuntimeException("Unable to create stored procedures",e);
}

====================================================
CascadeTest.java at Line:43 col: 2
try {
  Session s=openSession();
  s.beginTransaction();
  Parent p=new Parent("parent");
  Child c=new Child("child");
  c.setParent(p);
  s.save(c);
  try {
    s.getTransaction().commit();
    fail("expecting TransientObjectException on flush");
  }
 catch (  IllegalStateException e) {
    assertTyping(TransientObjectException.class,e.getCause());
    log.trace("handled expected exception",e);
    s.getTransaction().rollback();
  }
 finally {
    s.close();
  }
}
  finally {
  cleanupData();
}

====================================================
LockTest.java at Line:1061 col: 2
try {
  lock.setName("testQueryTimeout");
  doInJPA(this::entityManagerFactory,em -> {
    em.persist(lock);
  }
);
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.lock(_lock,LockModeType.PESSIMISTIC_WRITE);
    final Integer id=_lock.getId();
    _lock.getName();
    log.info("testQueryTimeout: got write lock");
    try {
      t.start();
      boolean latchSet=latch.await(10,TimeUnit.SECONDS);
      assertTrue("background test thread finished (lock timeout is broken)",latchSet);
      assertTrue("background test thread timed out on lock attempt",bgTask.get());
    }
 catch (    InterruptedException e) {
      Thread.interrupted();
    }
catch (    ExecutionException e) {
      fail(e.getMessage());
    }
  }
);
}
  finally {
  t.join();
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.remove(_lock);
  }
);
}

====================================================
LongToDateConversionTest.java at Line:45 col: 2
try (Session session=openSession()){
  session.getTransaction().begin();
  TestEntity entity=new TestEntity();
  entity.setDate(new DateAttribute(System.currentTimeMillis()));
  try {
    session.persist(entity);
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().isActive()) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
LockTest.java at Line:1147 col: 2
try {
  lock.setName("testLockTimeoutEMProps");
  doInJPA(this::entityManagerFactory,em -> {
    em.persist(lock);
  }
);
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.lock(_lock,LockModeType.PESSIMISTIC_WRITE);
    final Integer id=_lock.getId();
    _lock.getName();
    log.info("testLockTimeoutEMProps: got write lock");
    try {
      t.start();
      boolean latchSet=latch.await(10,TimeUnit.SECONDS);
      assertTrue("background test thread finished (lock timeout is broken)",latchSet);
      assertTrue("background test thread timed out on lock attempt",bgTask.get());
    }
 catch (    InterruptedException e) {
      Thread.interrupted();
    }
catch (    ExecutionException e) {
      fail(e.getMessage());
    }
  }
);
}
  finally {
  t.join();
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.remove(_lock);
  }
);
}

====================================================
TableBasedUpdateHandlerImpl.java at Line:111 col: 2
try {
  PreparedStatement ps=null;
  int resultCount=0;
  try {
    try {
      ps=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(idInsertSelect,false);
      int position=1;
      position+=handlePrependedParametersOnIdSelection(ps,session,position);
      for (      ParameterSpecification parameterSpecification : idSelectParameterSpecifications) {
        position+=parameterSpecification.bind(ps,queryParameters,session,position);
      }
      resultCount=session.getJdbcCoordinator().getResultSetReturn().executeUpdate(ps);
    }
  finally {
      if (ps != null) {
        session.getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(ps);
        session.getJdbcCoordinator().afterStatementExecution();
      }
    }
  }
 catch (  SQLException e) {
    throw session.getJdbcServices().getSqlExceptionHelper().convert(e,"could not insert/select ids for bulk update",idInsertSelect);
  }
  for (int i=0; i < updates.length; i++) {
    if (updates[i] == null) {
      continue;
    }
    try {
      try {
        ps=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(updates[i],false);
        if (assignmentParameterSpecifications[i] != null) {
          int position=1;
          for (          ParameterSpecification assignmentParameterSpecification : assignmentParameterSpecifications[i]) {
            position+=assignmentParameterSpecification.bind(ps,queryParameters,session,position);
          }
          handleAddedParametersOnUpdate(ps,session,position);
        }
        session.getJdbcCoordinator().getResultSetReturn().executeUpdate(ps);
      }
  finally {
        if (ps != null) {
          session.getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(ps);
          session.getJdbcCoordinator().afterStatementExecution();
        }
      }
    }
 catch (    SQLException e) {
      throw session.getJdbcServices().getSqlExceptionHelper().convert(e,"error performing bulk update",updates[i]);
    }
  }
  return resultCount;
}
  finally {
  releaseFromUse(targetedPersister,session);
}

====================================================
LockTest.java at Line:1112 col: 5
try {
  AtomicBoolean timedOut=new AtomicBoolean();
  doInJPA(this::entityManagerFactory,_entityManager -> {
    log.info("testLockTimeoutEMProps: (BG) about to read write-locked entity");
    Lock lock2=_entityManager.getReference(Lock.class,lock.getId());
    lock2.getName();
    log.info("testLockTimeoutEMProps: (BG) read write-locked entity");
    try {
      _entityManager.lock(lock2,LockModeType.PESSIMISTIC_WRITE);
    }
 catch (    LockTimeoutException e) {
      log.info("testLockTimeoutEMProps: (BG) got expected timeout exception");
      timedOut.set(true);
    }
catch (    Throwable e) {
      log.info("Expected LockTimeoutException but got unexpected exception",e);
    }
  }
,timeoutProps);
  return timedOut.get();
}
  finally {
  latch.countDown();
}

====================================================
SequenceReadingTest.java at Line:47 col: 2
try {
  final MetadataImplementor metadata=(MetadataImplementor)new MetadataSources(ssr).addAnnotatedClass(MyEntity.class).buildMetadata();
  metadata.validate();
  try {
    new SchemaUpdate().execute(EnumSet.of(TargetType.DATABASE),metadata);
  }
  finally {
    try {
      new SchemaExport().drop(EnumSet.of(TargetType.DATABASE),metadata);
    }
 catch (    Exception ignore) {
    }
  }
}
  finally {
  StandardServiceRegistryBuilder.destroy(ssr);
}

====================================================
EntityTransactionTests.java at Line:144 col: 7
try {
  assertTrue(transaction.isActive());
  transaction.setRollbackOnly();
  assertTrue(transaction.isActive());
  assertTrue(transaction.getRollbackOnly());
  try {
    transaction.commit();
  }
 catch (  RollbackException e) {
    assertFalse(transaction.isActive());
    assertThat(transaction.getStatus(),CoreMatchers.is(TransactionStatus.ROLLED_BACK));
  }
}
  finally {
  if (transaction.isActive()) {
    transaction.rollback();
  }
}

====================================================
NativeQueryScrollableResults.java at Line:59 col: 2
try (Session session=openSession()){
  session.getTransaction().begin();
  try {
    session.createQuery("delete from MyEntity").executeUpdate();
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().isActive()) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
LiteralProcessor.java at Line:222 col: 2
try {
  if (type == NUM_BIG_INTEGER) {
    String literalValue=text;
    if (literalValue.endsWith("bi") || literalValue.endsWith("BI")) {
      literalValue=literalValue.substring(0,literalValue.length() - 2);
    }
    return new BigInteger(literalValue).toString();
  }
  if (type == NUM_INT) {
    try {
      return Integer.valueOf(text).toString();
    }
 catch (    NumberFormatException e) {
      LOG.tracev("Could not format incoming text [{0}] as a NUM_INT; assuming numeric overflow and attempting as NUM_LONG",text);
    }
  }
  String literalValue=text;
  if (literalValue.endsWith("l") || literalValue.endsWith("L")) {
    literalValue=literalValue.substring(0,literalValue.length() - 1);
  }
  return Long.valueOf(literalValue).toString();
}
 catch (Throwable t) {
  throw new HibernateException("Could not parse literal [" + text + "] as integer",t);
}

====================================================
HSQLStoreProcedureTest.java at Line:198 col: 3
try {
  Statement statement=conn.createStatement();
  statement.execute(toExecute);
  try {
    statement.close();
  }
 catch (  SQLException e) {
    fail(e.getMessage());
  }
}
  finally {
  try {
    conn.commit();
  }
 catch (  SQLException e) {
    fail(e.getMessage());
  }
  try {
    connectionAccess.releaseConnection(conn);
  }
 catch (  SQLException e) {
    fail(e.getMessage());
  }
}

====================================================
EntityTransactionTests.java at Line:116 col: 3
try {
  inSession(sessionFactory,session -> {
    final Transaction transaction=session.getTransaction();
    transaction.begin();
    try {
      assertTrue(transaction.isActive());
      transaction.setRollbackOnly();
      assertTrue(transaction.isActive());
      assertTrue(transaction.getRollbackOnly());
    }
  finally {
      if (transaction.isActive()) {
        transaction.rollback();
      }
    }
  }
);
  inSession(sessionFactory,session -> {
    final Transaction transaction=session.getTransaction();
    transaction.begin();
    try {
      assertTrue(transaction.isActive());
      transaction.setRollbackOnly();
      assertTrue(transaction.isActive());
      assertTrue(transaction.getRollbackOnly());
      try {
        transaction.commit();
      }
 catch (      RollbackException e) {
        assertFalse(transaction.isActive());
        assertThat(transaction.getStatus(),CoreMatchers.is(TransactionStatus.ROLLED_BACK));
      }
    }
  finally {
      if (transaction.isActive()) {
        transaction.rollback();
      }
    }
  }
);
}
  finally {
  sessionFactory.close();
}

====================================================
ASTParserLoadingTest.java at Line:1635 col: 2
try (final SessionImplementor s=(SessionImplementor)openSession()){
  inTransaction(s,session -> {
    try {
      s.createQuery("from Animal a where a.description = :nonstring").setParameter("nonstring",Integer.valueOf(1)).list();
      fail("query execution should have failed");
    }
 catch (    IllegalArgumentException e) {
      assertTyping(TypeMismatchException.class,e.getCause());
    }
catch (    TypeMismatchException tme) {
    }
  }
);
}
 
====================================================
OracleStoredProcedureTest.java at Line:257 col: 8
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (Statement statement=connection.createStatement()){
      statement.executeUpdate("DROP PROCEDURE sp_count_phones");
    }
 catch (    SQLException ignore) {
    }
  }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
SessionImpl.java at Line:3608 col: 2
try {
  try {
    return createStoredProcedureCall(procedureName,resultSetMappings);
  }
 catch (  UnknownSqlResultSetMappingException unknownResultSetMapping) {
    throw new IllegalArgumentException(unknownResultSetMapping.getMessage(),unknownResultSetMapping);
  }
}
 catch (RuntimeException e) {
  throw getExceptionConverter().convert(e);
}

====================================================
QueryTest.java at Line:1389 col: 2
try {
  em.persist(item);
  try {
    em.createNamedQuery("wrong name");
    fail("Wrong named query should raise an exception");
  }
 catch (  IllegalArgumentException e) {
  }
  assertTrue("thrown IllegalArgumentException should of caused transaction to be marked for rollback only",true == em.getTransaction().getRollbackOnly());
  em.getTransaction().rollback();
  assertNull("entity should not of been saved to database since IllegalArgumentException should of" + "caused transaction to be marked for rollback only",em.find(Item.class,item.getName()));
}
  finally {
  if (em.getTransaction() != null && em.getTransaction().isActive()) {
    em.getTransaction().rollback();
  }
  em.close();
}

====================================================
AttributeConverterTest.java at Line:316 col: 2
try {
  MetadataImplementor metadata=(MetadataImplementor)new MetadataSources(ssr).addAnnotatedClass(EntityWithConvertibleField.class).getMetadataBuilder().applyAttributeConverter(ConvertibleEnumConverter.class,true).build();
  PersistentClass tester=metadata.getEntityBinding(EntityWithConvertibleField.class.getName());
  Property nameProp=tester.getProperty("convertibleEnum");
  SimpleValue nameValue=(SimpleValue)nameProp.getValue();
  Type type=nameValue.getType();
  assertNotNull(type);
  assertTyping(BasicType.class,type);
  if (!AttributeConverterTypeAdapter.class.isInstance(type)) {
    fail("AttributeConverter not applied");
  }
  AbstractStandardBasicType basicType=assertTyping(AbstractStandardBasicType.class,type);
  assertTyping(EnumJavaTypeDescriptor.class,basicType.getJavaTypeDescriptor());
  assertEquals(Types.VARCHAR,basicType.getSqlTypeDescriptor().getSqlType());
  final SessionFactory sf=metadata.buildSessionFactory();
  try {
    Session s=sf.openSession();
    s.getTransaction().begin();
    EntityWithConvertibleField entity=new EntityWithConvertibleField();
    entity.setId("ID");
    entity.setConvertibleEnum(ConvertibleEnum.VALUE);
    String entityID=entity.getId();
    s.persist(entity);
    s.getTransaction().commit();
    s.close();
    s=sf.openSession();
    s.beginTransaction();
    entity=(EntityWithConvertibleField)s.load(EntityWithConvertibleField.class,entityID);
    assertEquals(ConvertibleEnum.VALUE,entity.getConvertibleEnum());
    s.getTransaction().commit();
    s.close();
    JavaConstantNode javaConstantNode=new JavaConstantNode();
    javaConstantNode.setExpectedType(type);
    javaConstantNode.setSessionFactory((SessionFactoryImplementor)sf);
    javaConstantNode.setText("org.hibernate.test.converter.AttributeConverterTest$ConvertibleEnum.VALUE");
    final String outcome=javaConstantNode.getRenderText((SessionFactoryImplementor)sf);
    assertEquals("'VALUE'",outcome);
    s=sf.openSession();
    s.beginTransaction();
    s.createQuery("FROM EntityWithConvertibleField e where e.convertibleEnum = org.hibernate.test.converter.AttributeConverterTest$ConvertibleEnum.VALUE").list();
    s.getTransaction().commit();
    s.close();
    s=sf.openSession();
    s.beginTransaction();
    s.delete(entity);
    s.getTransaction().commit();
    s.close();
  }
  finally {
    try {
      sf.close();
    }
 catch (    Exception ignore) {
    }
  }
}
  finally {
  StandardServiceRegistryBuilder.destroy(ssr);
}

====================================================
EntityTransactionTests.java at Line:183 col: 2
try {
  final SessionFactoryImplementor sessionFactory=(SessionFactoryImplementor)new MetadataSources(ssr).buildMetadata().buildSessionFactory();
  try {
    inSession(sessionFactory,session -> {
      final Transaction transaction=session.getTransaction();
      assertFalse(transaction.isActive());
      try {
        transaction.setRollbackOnly();
        fail("Expecting failure #setRollbackOnly on non-active txn");
      }
 catch (      IllegalStateException expected) {
      }
    }
);
  }
  finally {
    sessionFactory.close();
  }
}
  finally {
  StandardServiceRegistryBuilder.destroy(ssr);
}

====================================================
SynchronizationRegistryStandardImpl.java at Line:81 col: 3
try {
  for (  Synchronization synchronization : synchronizations) {
    try {
      synchronization.afterCompletion(status);
    }
 catch (    Throwable t) {
      log.synchronizationFailed(synchronization,t);
      throw new LocalSynchronizationException("Exception calling user Synchronization (afterCompletion): " + synchronization.getClass().getName(),t);
    }
  }
}
  finally {
  clearSynchronizations();
}

====================================================
AbstractCollectionPersister.java at Line:1543 col: 2
try {
  collection.preInsert(this);
  Iterator entries=collection.entries(this);
  Expectation expectation=Expectations.appropriateExpectation(getInsertCheckStyle());
  boolean callable=isInsertCallable();
  boolean useBatch=expectation.canBeBatched();
  String sql=getSQLInsertRowString();
  int i=0;
  int count=0;
  while (entries.hasNext()) {
    int offset=1;
    Object entry=entries.next();
    PreparedStatement st=null;
    if (collection.needsInserting(entry,i,elementType)) {
      if (useBatch) {
        if (insertBatchKey == null) {
          insertBatchKey=new BasicBatchKey(getRole() + "#INSERT",expectation);
        }
        if (st == null) {
          st=session.getJdbcCoordinator().getBatch(insertBatchKey).getBatchStatement(sql,callable);
        }
      }
 else {
        st=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(sql,callable);
      }
      try {
        offset+=expectation.prepare(st);
        offset=writeKey(st,id,offset,session);
        if (hasIdentifier) {
          offset=writeIdentifier(st,collection.getIdentifier(entry,i),offset,session);
        }
        if (hasIndex) {
          offset=writeIndex(st,collection.getIndex(entry,i,this),offset,session);
        }
        writeElement(st,collection.getElement(entry),offset,session);
        if (useBatch) {
          session.getJdbcCoordinator().getBatch(insertBatchKey).addToBatch();
        }
 else {
          expectation.verifyOutcome(session.getJdbcCoordinator().getResultSetReturn().executeUpdate(st),st,-1);
        }
        collection.afterRowInsert(this,entry,i);
        count++;
      }
 catch (      SQLException sqle) {
        if (useBatch) {
          session.getJdbcCoordinator().abortBatch();
        }
        throw sqle;
      }
 finally {
        if (!useBatch) {
          session.getJdbcCoordinator().getResourceRegistry().release(st);
          session.getJdbcCoordinator().afterStatementExecution();
        }
      }
    }
    i++;
  }
  LOG.debugf("Done inserting rows: %s inserted",count);
}
 catch (SQLException sqle) {
  throw sqlExceptionHelper.convert(sqle,"could not insert collection rows: " + MessageHelper.collectionInfoString(this,collection,id,session),getSQLInsertRowString());
}

====================================================
UpdateEntitiesWithPackageNamesStartingWithKeywordsTest.java at Line:98 col: 2
try (Session session=openSession()){
  session.getTransaction().begin();
  try {
    final Query query=session.createQuery("UPDATE In set prop = :prop WHERE id = :id ");
    query.setParameter("prop","1");
    query.setParameter("id",entity.getId());
    query.executeUpdate();
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().getStatus() == TransactionStatus.ACTIVE) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
LockTest.java at Line:928 col: 5
try {
  AtomicBoolean timedOut=new AtomicBoolean();
  doInJPA(this::entityManagerFactory,_entityManager -> {
    log.info("testQueryTimeout: (BG) about to read write-locked entity");
    Lock lock2=_entityManager.getReference(Lock.class,lock.getId());
    lock2.getName();
    log.info("testQueryTimeout: (BG) read write-locked entity");
    try {
      Query query=_entityManager.createQuery("select L from Lock_ L where L.id < 10000 ");
      query.setLockMode(LockModeType.PESSIMISTIC_READ);
      query.setHint(QueryHints.SPEC_HINT_TIMEOUT,500);
      List<Lock> resultList=query.getResultList();
      String name=resultList.get(0).getName();
      log.info("testQueryTimeout: name read =" + name);
    }
 catch (    QueryTimeoutException e) {
      log.info("testQueryTimeout: (BG) got expected timeout exception");
      timedOut.set(true);
    }
catch (    Throwable e) {
      log.info("Expected LockTimeoutException but got unexpected exception",e);
    }
  }
);
  return timedOut.get();
}
  finally {
  latch.countDown();
}

====================================================
CascadeTest.java at Line:101 col: 2
try {
  Session s=openSession();
  s.beginTransaction();
  ParentAssigned p=new ParentAssigned(new Long(1),"parent");
  ChildAssigned c=new ChildAssigned(new Long(2),"child");
  c.setParent(p);
  s.persist(c);
  try {
    s.getTransaction().commit();
    fail("expecting TransientObjectException on flush");
  }
 catch (  TransientObjectException e) {
    log.trace("handled expected exception",e);
    s.getTransaction().rollback();
  }
 finally {
    s.close();
  }
}
  finally {
  cleanupData();
}

====================================================
DataSourceInjectionTest.java at Line:54 col: 5
try (final SessionFactoryImplementor sf=provider.createContainerEntityManagerFactory(persistenceUnitInfo,intgOverrides).unwrap(SessionFactoryImplementor.class)){
  try (final SessionImplementor session=sf.openSession().unwrap(SessionImplementor.class)){
    session.createQuery("select i from Item i").list();
    Assert.fail("Expecting FakeDataSourceException");
  }
 catch (  PersistenceException pe) {
    try {
      throw (RuntimeException)pe.getCause();
    }
 catch (    FakeDataSourceException fde) {
    }
  }
catch (  FakeDataSourceException fde) {
  }
}
 
====================================================
UpdateEntitiesWithPackageNamesStartingWithKeywordsTest.java at Line:35 col: 2
try (Session session=openSession()){
  session.getTransaction().begin();
  try {
    session.save(entity);
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().getStatus() == TransactionStatus.ACTIVE) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
GeneratedValueTest.java at Line:47 col: 2
try {
  Metadata metadata=new MetadataSources(ssr).addAnnotatedClass(TheEntity.class).buildMetadata();
  ((MetadataImpl)metadata).validate();
  PersistentClass entityBinding=metadata.getEntityBinding(TheEntity.class.getName());
  assertEquals(UUID.class,entityBinding.getIdentifier().getType().getReturnedClass());
  IdentifierGenerator generator=entityBinding.getIdentifier().createIdentifierGenerator(metadata.getIdentifierGeneratorFactory(),metadata.getDatabase().getDialect(),null,null,(RootClass)entityBinding);
  assertTyping(UUIDGenerator.class,generator);
  SessionFactory sf=metadata.buildSessionFactory();
  try {
    TheEntity theEntity=new TheEntity();
    Session s=sf.openSession();
    s.beginTransaction();
    s.save(theEntity);
    s.getTransaction().commit();
    s.close();
    assertNotNull(theEntity.id);
    s=sf.openSession();
    s.beginTransaction();
    try {
      s.delete(theEntity);
      s.getTransaction().commit();
    }
 catch (    Exception e) {
      s.getTransaction().rollback();
      throw e;
    }
 finally {
      s.close();
    }
  }
  finally {
    try {
      sf.close();
    }
 catch (    Exception ignore) {
    }
  }
}
  finally {
  StandardServiceRegistryBuilder.destroy(ssr);
}

====================================================
CascadeTest.java at Line:233 col: 2
try {
  Session s=openSession();
  s.beginTransaction();
  Child c2=new Child("c2");
  ChildInfo info=new ChildInfo("blah blah blah");
  c2.setInfo(info);
  info.setOwner(c2);
  s.persist(c2);
  try {
    s.getTransaction().commit();
    fail("expecting TransientObjectException on flush");
  }
 catch (  TransientObjectException e) {
    log.trace("handled expected exception : " + e);
    s.getTransaction().rollback();
  }
 finally {
    s.close();
  }
}
  finally {
  cleanupData();
}

====================================================
BasicConnectionTest.java at Line:58 col: 2
try {
  Statement statement=jdbcCoord.getStatementPreparer().createStatement();
  String dropSql=getDialect().getDropTableString("SANDBOX_JDBC_TST");
  try {
    jdbcCoord.getResultSetReturn().execute(statement,dropSql);
  }
 catch (  Exception e) {
  }
  jdbcCoord.getResultSetReturn().execute(statement,"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )");
  assertTrue(getResourceRegistry(jdbcCoord).hasRegisteredResources());
  assertTrue(jdbcCoord.getLogicalConnection().isPhysicallyConnected());
  getResourceRegistry(jdbcCoord).release(statement);
  assertFalse(getResourceRegistry(jdbcCoord).hasRegisteredResources());
  assertTrue(jdbcCoord.getLogicalConnection().isPhysicallyConnected());
  PreparedStatement ps=jdbcCoord.getStatementPreparer().prepareStatement("insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )");
  ps.setLong(1,1);
  ps.setString(2,"name");
  jdbcCoord.getResultSetReturn().execute(ps);
  ps=jdbcCoord.getStatementPreparer().prepareStatement("select * from SANDBOX_JDBC_TST");
  jdbcCoord.getResultSetReturn().extract(ps);
  assertTrue(getResourceRegistry(jdbcCoord).hasRegisteredResources());
}
 catch (SQLException e) {
  fail("incorrect exception type : sqlexception");
}
 finally {
  try {
    session.doWork(connection -> {
      final Statement stmnt=connection.createStatement();
      stmnt.execute(getDialect().getDropTableString("SANDBOX_JDBC_TST"));
    }
);
  }
  finally {
    session.close();
  }
}

====================================================
HSQLStoreProcedureTest.java at Line:120 col: 2
try {
  StoredProcedureQuery query=em.createNamedStoredProcedureQuery("User.inoutproc");
  final Set<Parameter<?>> parameters=query.getParameters();
  assertThat(parameters.size(),is(2));
  try {
    query.getParameter(1);
    fail("An IllegalArgumentException is expected, The stored procedure has named parameters not positional");
  }
 catch (  IllegalArgumentException iae) {
  }
  try {
    query.getParameter(1,String.class);
    fail("An IllegalArgumentException is expected, The stored procedure has named parameters not positional");
  }
 catch (  IllegalArgumentException iae) {
  }
}
  finally {
  em.close();
}

====================================================
JpaTckUsageTest.java at Line:423 col: 3
try {
  Statement statement=conn.createStatement();
  dropProcedures(statement);
  try {
    statement.close();
  }
 catch (  SQLException ignore) {
  }
}
  finally {
  try {
    conn.commit();
  }
 catch (  SQLException e) {
    System.out.println("Unable to commit transaction after creating dropping procedures");
  }
  try {
    connectionAccess.releaseConnection(conn);
  }
 catch (  SQLException ignore) {
  }
}

====================================================
ScanningCoordinator.java at Line:149 col: 4
try {
  final Constructor<? extends Scanner> constructor=scannerImplClass.getConstructor(SINGLE_ARG);
  try {
    return constructor.newInstance(StandardArchiveDescriptorFactory.INSTANCE);
  }
 catch (  Exception e) {
    throw new IllegalStateException("Error trying to instantiate custom specified Scanner [" + scannerImplClass.getName() + "]",e);
  }
}
 catch (NoSuchMethodException e) {
  try {
    final Constructor<? extends Scanner> constructor=scannerImplClass.getConstructor();
    try {
      return constructor.newInstance();
    }
 catch (    Exception e2) {
      throw new IllegalStateException("Error trying to instantiate custom specified Scanner [" + scannerImplClass.getName() + "]",e2);
    }
  }
 catch (  NoSuchMethodException ignore) {
    throw new IllegalArgumentException("Configuration named a custom Scanner, but we were unable to locate " + "an appropriate constructor");
  }
}

====================================================
LockTest.java at Line:571 col: 5
try {
  doInJPA(this::entityManagerFactory,_entityManager -> {
    TransactionUtil.setJdbcTimeout(_entityManager.unwrap(Session.class));
    log.info("testContendedPessimisticLock: (BG) about to issue (PESSIMISTIC_READ) query against write-locked entity");
    try {
      Query query=_entityManager.createQuery("select L from Lock_ L where L.id < 10000 ");
      query.setLockMode(LockModeType.PESSIMISTIC_READ);
      List<Lock> resultList=query.getResultList();
      Lock _lock=resultList.get(0);
      backgroundThreadHasReadNewValue.set(_lock.getName().equals("foo"));
    }
 catch (    RuntimeException e) {
      if (!ExceptionUtil.isSqlLockTimeout(e)) {
        fail("An error occurred waiting while attempting to read the entity: " + e.getMessage());
      }
      backgroundThreadHasReadNewValue.set(false);
    }
  }
);
}
 catch (TransactionException e) {
  if (!ExceptionUtil.isConnectionClose(e)) {
    fail("Unexpected exception: " + e.getMessage());
  }
}
 finally {
  latch.countDown();
}

====================================================
CaseStatementTest.java at Line:173 col: 2
try (final SessionImplementor s=(SessionImplementor)openSession()){
  inTransaction(s,session -> {
    try {
      s.createQuery("select case when p.name = 'Steve' then :opt1 else :opt2 end from Person p").setString("opt1","x").setString("opt2","y").list();
      fail("was expecting an exception");
    }
 catch (    IllegalArgumentException e) {
      assertTyping(QueryException.class,e.getCause());
    }
catch (    QueryException expected) {
    }
  }
);
  inTransaction(s,session -> {
    s.createQuery("select case when p.name = 'Steve' then cast( :opt1 as string) else :opt2 end from Person p").setString("opt1","x").setString("opt2","y").list();
  }
);
}
 
====================================================
PostgreSQLMultipleSchemaSequenceTest.java at Line:69 col: 2
try {
  final MetadataImplementor metadata1=(MetadataImplementor)new MetadataSources(ssr1).addAnnotatedClass(Box.class).buildMetadata();
  try {
    new SchemaExport().setOutputFile(output.getAbsolutePath()).create(EnumSet.of(TargetType.DATABASE,TargetType.SCRIPT),metadata1);
    final ConnectionProvider connectionProvider1=ssr1.getService(ConnectionProvider.class);
    DdlTransactionIsolatorTestingImpl ddlTransactionIsolator1=new DdlTransactionIsolatorTestingImpl(ssr1,new JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess(connectionProvider1));
    try (Statement statement=ddlTransactionIsolator1.getIsolatedConnection().createStatement()){
      statement.execute(String.format("DROP SCHEMA IF EXISTS %s CASCADE",extraSchemaName));
      statement.execute(String.format("CREATE SCHEMA %s",extraSchemaName));
      try (ResultSet resultSet=statement.executeQuery("SELECT NEXTVAL('SEQ_TEST')")){
        while (resultSet.next()) {
          Long sequenceValue=resultSet.getLong(1);
          assertEquals(Long.valueOf(1L),sequenceValue);
        }
      }
     }
 catch (    SQLException e) {
      fail(e.getMessage());
    }
    StandardServiceRegistry ssr2=new StandardServiceRegistryBuilder().applySetting(AvailableSettings.URL,Environment.getProperties().get(AvailableSettings.URL) + "?currentSchema=" + extraSchemaName).build();
    try {
      final MetadataImplementor metadata2=(MetadataImplementor)new MetadataSources(ssr2).addAnnotatedClass(Box.class).buildMetadata();
      try {
        new SchemaExport().setOutputFile(output.getAbsolutePath()).create(EnumSet.of(TargetType.DATABASE,TargetType.SCRIPT),metadata2);
      }
  finally {
        final ConnectionProvider connectionProvider2=ssr2.getService(ConnectionProvider.class);
        DdlTransactionIsolatorTestingImpl ddlTransactionIsolator2=new DdlTransactionIsolatorTestingImpl(ssr2,new JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess(connectionProvider2));
        try (Statement statement=ddlTransactionIsolator2.getIsolatedConnection().createStatement()){
          try (ResultSet resultSet=statement.executeQuery("SELECT NEXTVAL('SEQ_TEST')")){
            while (resultSet.next()) {
              Long sequenceValue=resultSet.getLong(1);
              assertEquals(Long.valueOf(1L),sequenceValue);
            }
          }
           statement.execute(String.format("DROP SCHEMA IF EXISTS %s CASCADE",extraSchemaName));
        }
 catch (        SQLException e) {
          fail(e.getMessage());
        }
        new SchemaExport().drop(EnumSet.of(TargetType.DATABASE),metadata2);
      }
    }
  finally {
      StandardServiceRegistryBuilder.destroy(ssr2);
    }
  }
  finally {
    new SchemaExport().drop(EnumSet.of(TargetType.DATABASE),metadata1);
  }
  final List<String> sqlLines=Files.readAllLines(output.toPath(),Charset.defaultCharset());
  assertEquals(2,sqlLines.stream().filter(s -> s.equalsIgnoreCase("create sequence SEQ_TEST start 1 increment 1")).count());
}
 catch (IOException e) {
  fail(e.getMessage());
}
 finally {
  StandardServiceRegistryBuilder.destroy(ssr1);
}

====================================================
AbstractPathImplTest.java at Line:86 col: 2
try {
  CriteriaBuilder criteriaBuilder=em.getCriteriaBuilder();
  CriteriaQuery<Order> criteria=criteriaBuilder.createQuery(Order.class);
  Root<Order> orderRoot=criteria.from(Order.class);
  Path simplePath=orderRoot.get("totalPrice");
  try {
    simplePath.get("yabbadabbado");
    fail("Attempt to dereference basic path should throw IllegalStateException");
  }
 catch (  IllegalStateException expected) {
  }
}
  finally {
  em.close();
}

====================================================
TransactionUtil.java at Line:53 col: 2
try (Session session=sessionFactory.openSession()){
  final Transaction txn=session.getTransaction();
  txn.begin();
  try {
    function.accept(session);
  }
 catch (  Throwable e) {
    try {
      txn.rollback();
    }
  finally {
      throw e;
    }
  }
  txn.commit();
}
 
====================================================
AbstractEntityPersister.java at Line:3505 col: 2
try {
  PreparedStatement delete;
  int index=1;
  if (useBatch) {
    delete=session.getJdbcCoordinator().getBatch(deleteBatchKey).getBatchStatement(sql,callable);
  }
 else {
    delete=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(sql,callable);
  }
  try {
    index+=expectation.prepare(delete);
    getIdentifierType().nullSafeSet(delete,id,index,session);
    index+=getIdentifierColumnSpan();
    if (useVersion) {
      getVersionType().nullSafeSet(delete,version,index,session);
    }
 else     if (isAllOrDirtyOptLocking() && loadedState != null) {
      boolean[] versionability=getPropertyVersionability();
      Type[] types=getPropertyTypes();
      for (int i=0; i < entityMetamodel.getPropertySpan(); i++) {
        if (isPropertyOfTable(i,j) && versionability[i]) {
          boolean[] settable=types[i].toColumnNullness(loadedState[i],getFactory());
          types[i].nullSafeSet(delete,loadedState[i],index,settable,session);
          index+=ArrayHelper.countTrue(settable);
        }
      }
    }
    if (useBatch) {
      session.getJdbcCoordinator().getBatch(deleteBatchKey).addToBatch();
    }
 else {
      check(session.getJdbcCoordinator().getResultSetReturn().executeUpdate(delete),id,j,expectation,delete);
    }
  }
 catch (  SQLException sqle) {
    if (useBatch) {
      session.getJdbcCoordinator().abortBatch();
    }
    throw sqle;
  }
 finally {
    if (!useBatch) {
      session.getJdbcCoordinator().getResourceRegistry().release(delete);
      session.getJdbcCoordinator().afterStatementExecution();
    }
  }
}
 catch (SQLException sqle) {
  throw getFactory().getSQLExceptionHelper().convert(sqle,"could not delete: " + MessageHelper.infoString(this,id,getFactory()),sql);
}

====================================================
HSQLStoreProcedureTest.java at Line:194 col: 2
try {
  conn=connectionAccess.obtainConnection();
  conn.setAutoCommit(false);
  try {
    Statement statement=conn.createStatement();
    statement.execute(toExecute);
    try {
      statement.close();
    }
 catch (    SQLException e) {
      fail(e.getMessage());
    }
  }
  finally {
    try {
      conn.commit();
    }
 catch (    SQLException e) {
      fail(e.getMessage());
    }
    try {
      connectionAccess.releaseConnection(conn);
    }
 catch (    SQLException e) {
      fail(e.getMessage());
    }
  }
}
 catch (SQLException e) {
  throw new RuntimeException("Unable to create stored procedures",e);
}

====================================================
PersistentClass.java at Line:461 col: 2
try {
  while (st.hasMoreElements()) {
    final String element=(String)st.nextElement();
    if (property == null) {
      Property identifierProperty=getIdentifierProperty();
      if (identifierProperty != null && identifierProperty.getName().equals(element)) {
        property=identifierProperty;
      }
 else       if (identifierProperty == null && getIdentifierMapper() != null) {
        try {
          identifierProperty=getProperty(element,getIdentifierMapper().getPropertyIterator());
          if (identifierProperty != null) {
            property=identifierProperty;
          }
        }
 catch (        MappingException ignore) {
        }
      }
      if (property == null) {
        property=getProperty(element,iter);
      }
    }
 else {
      property=((Component)property.getValue()).getProperty(element);
    }
  }
}
 catch (MappingException e) {
  throw new MappingException("property [" + propertyPath + "] not found on entity ["+ getEntityName()+ "]");
}

====================================================
EntityTuplizerFactory.java at Line:132 col: 2
try {
  constructor=clazz.getDeclaredConstructor(constructorArgs);
  try {
    ReflectHelper.ensureAccessibility(constructor);
  }
 catch (  SecurityException e) {
    constructor=null;
  }
}
 catch (NoSuchMethodException ignore) {
}

====================================================
StoreProcedureOutParameterByPositionTest.java at Line:139 col: 3
try {
  Statement statement=conn.createStatement();
  statement.execute(storedProc);
  try {
    statement.close();
  }
 catch (  SQLException ignore) {
    fail();
  }
}
  finally {
  try {
    conn.commit();
  }
 catch (  SQLException e) {
    System.out.println("Unable to commit transaction after creating creating procedures");
    fail();
  }
  try {
    connectionAccess.releaseConnection(conn);
  }
 catch (  SQLException ignore) {
    fail();
  }
}

====================================================
OracleStoredProcedureTest.java at Line:422 col: 16
try (CallableStatement function=connection.prepareCall("{ ? = call fn_person_and_phones( ? ) }")){
  try {
    function.registerOutParameter(1,Types.REF_CURSOR);
  }
 catch (  SQLException e) {
    function.registerOutParameter(1,-10);
  }
  function.setInt(2,1);
  function.execute();
  try (ResultSet resultSet=(ResultSet)function.getObject(1)){
    while (resultSet.next()) {
      Long postCommentId=resultSet.getLong(1);
      String review=resultSet.getString(2);
    }
  }
 }
 
====================================================
IdTableHelper.java at Line:67 col: 2
try {
  Connection connection;
  try {
    connection=connectionAccess.obtainConnection();
  }
 catch (  UnsupportedOperationException e) {
    log.debug("Unable to obtain JDBC connection; assuming ID tables already exist or wont be needed");
    return;
  }
  try {
    Statement statement=connection.createStatement();
    for (    String creationStatement : creationStatements) {
      try {
        jdbcServices.getSqlStatementLogger().logStatement(creationStatement);
        statement.execute(creationStatement);
      }
 catch (      SQLException e) {
        log.debugf("Error attempting to export id-table [%s] : %s",creationStatement,e.getMessage());
      }
    }
    statement.close();
  }
 catch (  SQLException e) {
    log.error("Unable to use JDBC Connection to create Statement",e);
  }
 finally {
    try {
      connectionAccess.releaseConnection(connection);
    }
 catch (    SQLException ignore) {
    }
  }
}
 catch (SQLException e) {
  log.error("Unable obtain JDBC Connection",e);
}

====================================================
OracleExtractSequenceMetadataTest.java at Line:60 col: 2
try (Connection conn=getConnection()){
  try (Statement stmt=conn.createStatement()){
    try {
      stmt.execute(String.format("DROP USER %s CASCADE",OTHER_SCHEMA_NAME));
    }
 catch (    Exception ignore) {
    }
    stmt.execute(String.format("CREATE USER %s IDENTIFIED BY whatever",OTHER_SCHEMA_NAME));
    stmt.execute(String.format("CREATE SEQUENCE %s.%s START WITH 1 INCREMENT BY %s",OTHER_SCHEMA_NAME,SEQUENCE_NAME,SEQUENCE_INCREMENT_SIZE_FROM_OTHER_SCHEMA));
    try {
      stmt.execute(String.format("DROP SEQUENCE %s",SEQUENCE_NAME));
    }
 catch (    Exception ignore) {
    }
  }
 }
 
====================================================
TypeInfo.java at Line:83 col: 2
try {
  final ResultSet resultSet=metaData.getTypeInfo();
  try {
    while (resultSet.next()) {
      typeInfoSet.add(new TypeInfo(resultSet.getString("TYPE_NAME"),resultSet.getInt("DATA_TYPE"),interpretCreateParams(resultSet.getString("CREATE_PARAMS")),resultSet.getBoolean("UNSIGNED_ATTRIBUTE"),resultSet.getInt("PRECISION"),resultSet.getShort("MINIMUM_SCALE"),resultSet.getShort("MAXIMUM_SCALE"),resultSet.getBoolean("FIXED_PREC_SCALE"),resultSet.getString("LITERAL_PREFIX"),resultSet.getString("LITERAL_SUFFIX"),resultSet.getBoolean("CASE_SENSITIVE"),TypeSearchability.interpret(resultSet.getShort("SEARCHABLE")),TypeNullability.interpret(resultSet.getShort("NULLABLE"))));
    }
  }
 catch (  SQLException e) {
    LOG.unableToAccessTypeInfoResultSet(e.toString());
  }
 finally {
    try {
      resultSet.close();
    }
 catch (    SQLException e) {
      LOG.unableToReleaseTypeInfoResultSet();
    }
  }
}
 catch (SQLException e) {
  LOG.unableToRetrieveTypeInfoResultSet(e.toString());
}

====================================================
LobCreatorBuilderImpl.java at Line:97 col: 2
try {
  try {
    final DatabaseMetaData meta=jdbcConnection.getMetaData();
    if (meta.getJDBCMajorVersion() < 4) {
      LOG.disablingContextualLOBCreationSinceOldJdbcVersion(meta.getJDBCMajorVersion());
      return false;
    }
    if (!dialect.supportsJdbcConnectionLobCreation(meta)) {
      return false;
    }
  }
 catch (  SQLException ignore) {
  }
  final Class connectionClass=Connection.class;
  final Method createClobMethod=connectionClass.getMethod("createClob",NO_ARG_SIG);
  if (createClobMethod.getDeclaringClass().equals(Connection.class)) {
    try {
      final Object clob=createClobMethod.invoke(jdbcConnection,NO_ARGS);
      try {
        final Method freeMethod=clob.getClass().getMethod("free",NO_ARG_SIG);
        freeMethod.invoke(clob,NO_ARGS);
      }
 catch (      Throwable ignore) {
        LOG.tracef("Unable to free CLOB created to test createClob() implementation : %s",ignore);
      }
      return true;
    }
 catch (    Throwable t) {
      LOG.disablingContextualLOBCreationSinceCreateClobFailed(t);
    }
  }
}
 catch (NoSuchMethodException ignore) {
}

====================================================
UUIDGenerator.java at Line:66 col: 4
try {
  final ClassLoaderService cls=serviceRegistry.getService(ClassLoaderService.class);
  final Class strategyClass=cls.classForName(strategyClassName);
  try {
    strategy=(UUIDGenerationStrategy)strategyClass.newInstance();
  }
 catch (  Exception ignore) {
    LOG.unableToInstantiateUuidGenerationStrategy(ignore);
  }
}
 catch (ClassLoadingException ignore) {
  LOG.unableToLocateUuidGenerationStrategy(strategyClassName);
}

====================================================
UpdateEntitiesWithPackageNamesStartingWithKeywordsTest.java at Line:65 col: 2
try (Session session=openSession()){
  session.getTransaction().begin();
  try {
    session.createQuery("DELETE FROM Any").executeUpdate();
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().getStatus() == TransactionStatus.ACTIVE) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
JdbcResourceLocalTransactionCoordinatorImpl.java at Line:258 col: 3
try {
  if (rollbackOnly) {
    log.debugf("On commit, transaction was marked for roll-back only, rolling back");
    try {
      rollback();
      if (jpaCompliance.isJpaTransactionComplianceEnabled()) {
        log.debugf("Throwing RollbackException on roll-back of transaction marked rollback-only on commit");
        throw new RollbackException("Transaction was marked for rollback-only");
      }
      return;
    }
 catch (    RollbackException e) {
      throw e;
    }
catch (    RuntimeException e) {
      log.debug("Encountered failure rolling back failed commit",e);
      throw e;
    }
  }
  JdbcResourceLocalTransactionCoordinatorImpl.this.beforeCompletionCallback();
  jdbcResourceTransaction.commit();
  JdbcResourceLocalTransactionCoordinatorImpl.this.afterCompletionCallback(true);
}
 catch (RollbackException e) {
  throw e;
}
catch (RuntimeException e) {
  try {
    rollback();
  }
 catch (  RuntimeException e2) {
    log.debug("Encountered failure rolling back failed commit",e2);
  }
  throw e;
}

====================================================
AbstractEntityPersister.java at Line:3361 col: 2
try {
  int index=1;
  final PreparedStatement update;
  if (useBatch) {
    update=session.getJdbcCoordinator().getBatch(updateBatchKey).getBatchStatement(sql,callable);
  }
 else {
    update=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(sql,callable);
  }
  try {
    index+=expectation.prepare(update);
    index=dehydrate(id,fields,rowId,includeProperty,propertyColumnUpdateable,j,update,session,index,true);
    if (useVersion && entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.VERSION) {
      if (checkVersion(includeProperty)) {
        getVersionType().nullSafeSet(update,oldVersion,index,session);
      }
    }
 else     if (isAllOrDirtyOptLocking() && oldFields != null) {
      boolean[] versionability=getPropertyVersionability();
      boolean[] includeOldField=entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.ALL ? getPropertyUpdateability() : includeProperty;
      Type[] types=getPropertyTypes();
      for (int i=0; i < entityMetamodel.getPropertySpan(); i++) {
        boolean include=includeOldField[i] && isPropertyOfTable(i,j) && versionability[i];
        if (include) {
          boolean[] settable=types[i].toColumnNullness(oldFields[i],getFactory());
          types[i].nullSafeSet(update,oldFields[i],index,settable,session);
          index+=ArrayHelper.countTrue(settable);
        }
      }
    }
    if (useBatch) {
      session.getJdbcCoordinator().getBatch(updateBatchKey).addToBatch();
      return true;
    }
 else {
      return check(session.getJdbcCoordinator().getResultSetReturn().executeUpdate(update),id,j,expectation,update);
    }
  }
 catch (  SQLException e) {
    if (useBatch) {
      session.getJdbcCoordinator().abortBatch();
    }
    throw e;
  }
 finally {
    if (!useBatch) {
      session.getJdbcCoordinator().getResourceRegistry().release(update);
      session.getJdbcCoordinator().afterStatementExecution();
    }
  }
}
 catch (SQLException e) {
  throw getFactory().getSQLExceptionHelper().convert(e,"could not update: " + MessageHelper.infoString(this,id,getFactory()),sql);
}

====================================================
HANAStoredProcedureTest.java at Line:237 col: 2
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (Statement statement=connection.createStatement()){
      statement.executeUpdate("DROP PROCEDURE sp_count_phones");
    }
 catch (    SQLException ignore) {
    }
  }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
LocalSchema.java at Line:84 col: 2
try {
  InputStream schemaStream=schemaUrl.openStream();
  try {
    StreamSource source=new StreamSource(schemaUrl.openStream());
    SchemaFactory schemaFactory=SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
    return schemaFactory.newSchema(source);
  }
 catch (  Exception e) {
    throw new XmlInfrastructureException("Unable to load schema [" + schemaUrl.toExternalForm() + "]",e);
  }
 finally {
    try {
      schemaStream.close();
    }
 catch (    IOException e) {
      log.debugf("Problem closing schema stream - %s",e.toString());
    }
  }
}
 catch (IOException e) {
  throw new XmlInfrastructureException("Stream error handling schema url [" + schemaUrl.toExternalForm() + "]");
}

====================================================
LockTest.java at Line:880 col: 2
try {
  lock.setName("testContendedPessimisticWriteLockNoWait");
  doInJPA(this::entityManagerFactory,em -> {
    em.persist(lock);
  }
);
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.lock(_lock,LockModeType.PESSIMISTIC_WRITE);
    final Integer id=_lock.getId();
    _lock.getName();
    log.info("testContendedPessimisticWriteLockNoWait: got write lock");
    try {
      t.start();
      boolean latchSet=latch.await(10,TimeUnit.SECONDS);
      assertTrue("background test thread finished (lock timeout is broken)",latchSet);
      assertTrue("background test thread timed out on lock attempt",bgTask.get());
    }
 catch (    InterruptedException e) {
      Thread.interrupted();
    }
catch (    ExecutionException e) {
      fail(e.getMessage());
    }
  }
);
}
  finally {
  t.join();
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.remove(_lock);
  }
);
}

====================================================
OneToManyPersister.java at Line:212 col: 3
try {
  if (entries.hasNext()) {
    int nextIndex=resetIndex ? 0 : getSize(id,session);
    Expectation expectation=Expectations.appropriateExpectation(getUpdateCheckStyle());
    while (entries.hasNext()) {
      final Object entry=entries.next();
      if (entry != null && collection.entryExists(entry,nextIndex)) {
        int offset=1;
        PreparedStatement st=null;
        boolean callable=isUpdateCallable();
        boolean useBatch=expectation.canBeBatched();
        String sql=getSQLUpdateRowString();
        if (useBatch) {
          if (recreateBatchKey == null) {
            recreateBatchKey=new BasicBatchKey(getRole() + "#RECREATE",expectation);
          }
          st=session.getJdbcCoordinator().getBatch(recreateBatchKey).getBatchStatement(sql,callable);
        }
 else {
          st=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(sql,callable);
        }
        try {
          offset+=expectation.prepare(st);
          if (hasIdentifier) {
            offset=writeIdentifier(st,collection.getIdentifier(entry,nextIndex),offset,session);
          }
          offset=writeIndex(st,collection.getIndex(entry,nextIndex,this),offset,session);
          offset=writeElement(st,collection.getElement(entry),offset,session);
          if (useBatch) {
            session.getJdbcCoordinator().getBatch(recreateBatchKey).addToBatch();
          }
 else {
            expectation.verifyOutcome(session.getJdbcCoordinator().getResultSetReturn().executeUpdate(st),st,-1);
          }
        }
 catch (        SQLException sqle) {
          if (useBatch) {
            session.getJdbcCoordinator().abortBatch();
          }
          throw sqle;
        }
 finally {
          if (!useBatch) {
            session.getJdbcCoordinator().getResourceRegistry().release(st);
            session.getJdbcCoordinator().afterStatementExecution();
          }
        }
      }
      nextIndex++;
    }
  }
}
 catch (SQLException sqle) {
  throw sqlExceptionHelper.convert(sqle,"could not update collection: " + MessageHelper.collectionInfoString(this,collection,id,session),getSQLUpdateRowString());
}

====================================================
InformationExtractorJdbcDatabaseMetaDataImpl.java at Line:111 col: 2
try {
  final ResultSet resultSet=extractionContext.getJdbcDatabaseMetaData().getCatalogs();
  try {
    while (resultSet.next()) {
      final String existingCatalogName=resultSet.getString("TABLE_CAT");
      if (catalog.getText().equalsIgnoreCase(existingCatalogName)) {
        return true;
      }
    }
    return false;
  }
  finally {
    try {
      resultSet.close();
    }
 catch (    SQLException ignore) {
    }
  }
}
 catch (SQLException sqlException) {
  throw convertSQLException(sqlException,"Unable to query DatabaseMetaData for existing catalogs");
}

====================================================
JarFileBasedArchiveDescriptor.java at Line:56 col: 2
try {
  final Enumeration<? extends ZipEntry> zipEntries=jarFile.entries();
  while (zipEntries.hasMoreElements()) {
    final ZipEntry zipEntry=zipEntries.nextElement();
    final String entryName=extractName(zipEntry);
    if (getEntryBasePrefix() != null && !entryName.startsWith(getEntryBasePrefix())) {
      continue;
    }
    if (zipEntry.isDirectory()) {
      continue;
    }
    if (entryName.equals(getEntryBasePrefix())) {
      try (final InputStream is=new BufferedInputStream(jarFile.getInputStream(zipEntry));final JarInputStream jarInputStream=new JarInputStream(is)){
        ZipEntry subZipEntry=jarInputStream.getNextEntry();
        while (subZipEntry != null) {
          if (!subZipEntry.isDirectory()) {
            final String name=extractName(subZipEntry);
            final String relativeName=extractRelativeName(subZipEntry);
            final InputStreamAccess inputStreamAccess=buildByteBasedInputStreamAccess(name,jarInputStream);
            final ArchiveEntry entry=new ArchiveEntry(){
              @Override public String getName(){
                return name;
              }
              @Override public String getNameWithinArchive(){
                return relativeName;
              }
              @Override public InputStreamAccess getStreamAccess(){
                return inputStreamAccess;
              }
            }
;
            final ArchiveEntryHandler entryHandler=context.obtainArchiveEntryHandler(entry);
            entryHandler.handleEntry(entry,context);
          }
          subZipEntry=jarInputStream.getNextEntry();
        }
      }
 catch (      Exception e) {
        throw new ArchiveException("Error accessing JarFile entry [" + zipEntry.getName() + "]",e);
      }
    }
 else {
      final String name=extractName(zipEntry);
      final String relativeName=extractRelativeName(zipEntry);
      final InputStreamAccess inputStreamAccess;
      try (InputStream is=jarFile.getInputStream(zipEntry)){
        inputStreamAccess=buildByteBasedInputStreamAccess(name,is);
      }
 catch (      IOException e) {
        throw new ArchiveException(String.format("Unable to access stream from jar file [%s] for entry [%s]",jarFile.getName(),zipEntry.getName()));
      }
      final ArchiveEntry entry=new ArchiveEntry(){
        @Override public String getName(){
          return name;
        }
        @Override public String getNameWithinArchive(){
          return relativeName;
        }
        @Override public InputStreamAccess getStreamAccess(){
          return inputStreamAccess;
        }
      }
;
      final ArchiveEntryHandler entryHandler=context.obtainArchiveEntryHandler(entry);
      entryHandler.handleEntry(entry,context);
    }
  }
}
  finally {
  try {
    jarFile.close();
  }
 catch (  Exception ignore) {
  }
}

====================================================
LockTest.java at Line:758 col: 5
try {
  AtomicBoolean timedOut=new AtomicBoolean();
  doInJPA(this::entityManagerFactory,_entityManager -> {
    log.info("testContendedPessimisticWriteLockTimeout: (BG) about to read write-locked entity");
    Lock lock2=_entityManager.getReference(Lock.class,lock.getId());
    lock2.getName();
    log.info("testContendedPessimisticWriteLockTimeout: (BG) read write-locked entity");
    Map<String,Object> props=new HashMap<String,Object>();
    props.put(AvailableSettings.LOCK_TIMEOUT,1000);
    try {
      _entityManager.lock(lock2,LockModeType.PESSIMISTIC_WRITE,props);
    }
 catch (    LockTimeoutException e) {
      log.info("testContendedPessimisticWriteLockTimeout: (BG) got expected timeout exception");
      timedOut.set(true);
    }
catch (    Throwable e) {
      log.info("Expected LockTimeoutException but got unexpected exception",e);
    }
  }
);
  return timedOut.get();
}
  finally {
  latch.countDown();
}

====================================================
BeanValidationIntegrator.java at Line:50 col: 2
try {
  final Class activatorClass=BeanValidationIntegrator.class.getClassLoader().loadClass(ACTIVATOR_CLASS_NAME);
  try {
    final Method validateMethod=activatorClass.getMethod(VALIDATE_SUPPLIED_FACTORY_METHOD_NAME,Object.class);
    try {
      validateMethod.invoke(null,object);
    }
 catch (    InvocationTargetException e) {
      if (e.getTargetException() instanceof HibernateException) {
        throw (HibernateException)e.getTargetException();
      }
      throw new HibernateException("Unable to check validity of passed ValidatorFactory",e);
    }
catch (    IllegalAccessException e) {
      throw new HibernateException("Unable to check validity of passed ValidatorFactory",e);
    }
  }
 catch (  HibernateException e) {
    throw e;
  }
catch (  Exception e) {
    throw new HibernateException("Could not locate method needed for ValidatorFactory validation",e);
  }
}
 catch (HibernateException e) {
  throw e;
}
catch (Exception e) {
  throw new HibernateException("Could not locate TypeSafeActivator class",e);
}

====================================================
LockExceptionTests.java at Line:57 col: 2
try {
  inTransaction(session -> {
    session.find(Item.class,item.getId(),LockModeType.PESSIMISTIC_WRITE);
    TransactionUtil2.inTransaction(sessionFactory(),secondSession -> {
      try {
        secondSession.find(Item.class,item.getId(),LockModeType.PESSIMISTIC_WRITE,Collections.singletonMap(AvailableSettings.JPA_LOCK_TIMEOUT,LockOptions.NO_WAIT));
        fail("Expecting a failure");
      }
 catch (      LockTimeoutException|PessimisticLockException expected) {
      }
    }
);
  }
);
}
 catch (Exception e) {
  log.error("Exception thrown",e);
}
 finally {
  inTransaction(session -> session.createQuery("delete Item").executeUpdate());
}

====================================================
JarInputStreamBasedArchiveDescriptor.java at Line:59 col: 2
try {
  JarEntry jarEntry;
  while ((jarEntry=jarInputStream.getNextJarEntry()) != null) {
    final String jarEntryName=jarEntry.getName();
    if (getEntryBasePrefix() != null && !jarEntryName.startsWith(getEntryBasePrefix())) {
      continue;
    }
    if (jarEntry.isDirectory()) {
      continue;
    }
    if (jarEntryName.equals(getEntryBasePrefix())) {
      try {
        final JarInputStream subJarInputStream=new JarInputStream(jarInputStream);
        try {
          ZipEntry subZipEntry=jarInputStream.getNextEntry();
          while (subZipEntry != null) {
            if (!subZipEntry.isDirectory()) {
              final String subName=extractName(subZipEntry);
              final InputStreamAccess inputStreamAccess=buildByteBasedInputStreamAccess(subName,subJarInputStream);
              final ArchiveEntry entry=new ArchiveEntry(){
                @Override public String getName(){
                  return subName;
                }
                @Override public String getNameWithinArchive(){
                  return subName;
                }
                @Override public InputStreamAccess getStreamAccess(){
                  return inputStreamAccess;
                }
              }
;
              context.obtainArchiveEntryHandler(entry).handleEntry(entry,context);
            }
            subZipEntry=jarInputStream.getNextJarEntry();
          }
        }
  finally {
          subJarInputStream.close();
        }
      }
 catch (      Exception e) {
        throw new ArchiveException("Error accessing nested jar",e);
      }
    }
 else {
      final String entryName=extractName(jarEntry);
      final InputStreamAccess inputStreamAccess=buildByteBasedInputStreamAccess(entryName,jarInputStream);
      final String relativeName=extractRelativeName(jarEntry);
      final ArchiveEntry entry=new ArchiveEntry(){
        @Override public String getName(){
          return entryName;
        }
        @Override public String getNameWithinArchive(){
          return relativeName;
        }
        @Override public InputStreamAccess getStreamAccess(){
          return inputStreamAccess;
        }
      }
;
      context.obtainArchiveEntryHandler(entry).handleEntry(entry,context);
    }
  }
  jarInputStream.close();
}
 catch (IOException ioe) {
  throw new ArchiveException(String.format("Error accessing JarInputStream [%s]",getArchiveUrl()),ioe);
}

====================================================
StoreProcedureOutParameterByNameTest.java at Line:139 col: 3
try {
  Statement statement=conn.createStatement();
  statement.execute(storedProc);
  try {
    statement.close();
  }
 catch (  SQLException ignore) {
    fail();
  }
}
  finally {
  try {
    conn.commit();
  }
 catch (  SQLException e) {
    System.out.println("Unable to commit transaction after creating creating procedures");
    fail();
  }
  try {
    connectionAccess.releaseConnection(conn);
  }
 catch (  SQLException ignore) {
    fail();
  }
}

====================================================
ASTParserLoadingTest.java at Line:890 col: 2
try (final SessionImplementor s=(SessionImplementor)openSession()){
  inTransaction(s,session -> {
    s.createQuery("from Animal a join a.offspring o where o.description = 'xyz'").list();
    s.createQuery("from Animal a join a.offspring o where o.father.description = 'xyz'").list();
    s.createQuery("from Animal a join a.offspring o order by o.description").list();
    s.createQuery("from Animal a join a.offspring o order by o.father.description").list();
  }
);
  inTransaction(s,session -> {
    try {
      s.createQuery("from Animal a where a.offspring.description = 'xyz'").list();
      fail("illegal collection dereference semantic did not cause failure");
    }
 catch (    IllegalArgumentException e) {
      assertTyping(QueryException.class,e.getCause());
    }
catch (    QueryException qe) {
      log.trace("expected failure...",qe);
    }
  }
);
  inTransaction(s,session -> {
    try {
      s.createQuery("from Animal a where a.offspring.father.description = 'xyz'").list();
      fail("illegal collection dereference semantic did not cause failure");
    }
 catch (    IllegalArgumentException e) {
      assertTyping(QueryException.class,e.getCause());
    }
catch (    QueryException qe) {
      log.trace("expected failure...",qe);
    }
  }
);
  inTransaction(s,session -> {
    try {
      s.createQuery("from Animal a order by a.offspring.description").list();
      fail("illegal collection dereference semantic did not cause failure");
    }
 catch (    IllegalArgumentException e) {
      assertTyping(QueryException.class,e.getCause());
    }
catch (    QueryException qe) {
      log.trace("expected failure...",qe);
    }
  }
);
  inTransaction(s,session -> {
    try {
      s.createQuery("from Animal a order by a.offspring.father.description").list();
      fail("illegal collection dereference semantic did not cause failure");
    }
 catch (    IllegalArgumentException e) {
      assertTyping(QueryException.class,e.getCause());
    }
catch (    QueryException qe) {
      log.trace("expected failure...",qe);
    }
  }
);
}
 
====================================================
LockModeTest.java at Line:247 col: 2
try {
  executeSync(() -> {
    doInHibernate(this::sessionFactory,_session -> {
      TransactionUtil.setJdbcTimeout(_session);
      try {
        A it=_session.get(A.class,id,new LockOptions(LockMode.NONE).setTimeOut(LockOptions.NO_WAIT));
        _session.createNativeQuery(updateStatement()).setParameter("value","changed").setParameter("id",it.getId()).executeUpdate();
        fail("Pessimistic lock not obtained/held");
      }
 catch (      Exception e) {
        if (!ExceptionUtil.isSqlLockTimeout(e)) {
          fail("Unexpected error type testing pessimistic locking : " + e.getClass().getName());
        }
      }
    }
);
  }
);
}
 catch (Exception e) {
  if (!ExceptionUtil.isConnectionClose(e)) {
    fail("Unknown exception thrown: " + e.getMessage());
  }
}

====================================================
BatchingBatch.java at Line:111 col: 2
try {
  for (  Map.Entry<String,PreparedStatement> entry : getStatements().entrySet()) {
    String sql=entry.getKey();
    try {
      final PreparedStatement statement=entry.getValue();
      final int[] rowCounts;
      try {
        getJdbcCoordinator().getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcExecuteBatchStart();
        rowCounts=statement.executeBatch();
      }
  finally {
        getJdbcCoordinator().getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcExecuteBatchEnd();
      }
      checkRowCounts(rowCounts,statement);
    }
 catch (    SQLException e) {
      abortBatch();
      LOG.unableToExecuteBatch(e,sql);
      throw sqlExceptionHelper().convert(e,"could not execute batch",sql);
    }
catch (    RuntimeException re) {
      abortBatch();
      LOG.unableToExecuteBatch(re,sql);
      throw re;
    }
  }
}
  finally {
  batchPosition=0;
}

====================================================
ClassLoadingStrategyHelper.java at Line:40 col: 2
try {
  Object privateLookup;
  try {
    privateLookup=privateLookupIn.invoke(null,originalClass,LOOKUP);
  }
 catch (  InvocationTargetException exception) {
    if (exception.getCause() instanceof IllegalAccessException) {
      return new ClassLoadingStrategy.ForUnsafeInjection(originalClass.getProtectionDomain());
    }
 else {
      throw new HibernateException(LOG.bytecodeEnhancementFailed(originalClass.getName()),exception.getCause());
    }
  }
  return ClassLoadingStrategy.UsingLookup.of(privateLookup);
}
 catch (Throwable e) {
  throw new HibernateException(LOG.bytecodeEnhancementFailedUnableToGetPrivateLookupFor(originalClass.getName()),e);
}

====================================================
PrivateConstructorTest.java at Line:64 col: 2
try {
  entityManager=createEntityManager();
  txn=entityManager.getTransaction();
  txn.begin();
  entityManager.persist(child);
  txn.commit();
  entityManager.clear();
  Integer childId=child.getId();
  Triggerable triggerable=logInspection.watchForLogMessages("HHH000143:");
  Child childReference=entityManager.getReference(Child.class,childId);
  try {
    assertEquals(child.getParent().getName(),childReference.getParent().getName());
  }
 catch (  Exception expected) {
    assertEquals(NoSuchMethodException.class,ExceptionUtil.rootCause(expected).getClass());
    assertTrue(expected.getMessage().contains("Bytecode enhancement failed because no public, protected or package-private default constructor was found for entity"));
  }
  assertTrue(triggerable.wasTriggered());
}
 catch (Throwable e) {
  if (txn != null && txn.isActive()) {
    txn.rollback();
  }
  throw e;
}
 finally {
  if (entityManager != null) {
    entityManager.close();
  }
}

====================================================
JtaIsolationDelegate.java at Line:106 col: 2
try {
  Transaction surroundingTransaction=transactionManager.suspend();
  LOG.debugf("Surrounding JTA transaction suspended [%s]",surroundingTransaction);
  boolean hadProblems=false;
  try {
    return callable.call();
  }
 catch (  HibernateException e) {
    hadProblems=true;
    throw e;
  }
 finally {
    try {
      transactionManager.resume(surroundingTransaction);
      LOG.debugf("Surrounding JTA transaction resumed [%s]",surroundingTransaction);
    }
 catch (    Throwable t) {
      if (!hadProblems) {
        throw new HibernateException("Unable to resume previously suspended transaction",t);
      }
    }
  }
}
 catch (SystemException e) {
  throw new HibernateException("Unable to suspend current JTA transaction",e);
}

====================================================
BasicCdiTest.java at Line:52 col: 2
try (final SeContainer cdiContainer=cdiInitializer.initialize()){
  BootstrapServiceRegistry bsr=new BootstrapServiceRegistryBuilder().build();
  final StandardServiceRegistry ssr=new StandardServiceRegistryBuilder(bsr).applySetting(AvailableSettings.CDI_BEAN_MANAGER,cdiContainer.getBeanManager()).applySetting(AvailableSettings.DELAY_CDI_ACCESS,"true").applySetting(AvailableSettings.HBM2DDL_AUTO,Action.CREATE_DROP).build();
  final SessionFactoryImplementor sessionFactory;
  try {
    sessionFactory=(SessionFactoryImplementor)new MetadataSources(ssr).addAnnotatedClass(MyEntity.class).buildMetadata().getSessionFactoryBuilder().build();
  }
 catch (  Exception e) {
    StandardServiceRegistryBuilder.destroy(ssr);
    throw e;
  }
  try {
    inTransaction(sessionFactory,session -> session.persist(new MyEntity(1)));
    assertEquals(1,count);
    inTransaction(sessionFactory,session -> {
      MyEntity it=session.find(MyEntity.class,1);
      assertNotNull(it);
    }
);
  }
  finally {
    inTransaction(sessionFactory,session -> {
      session.createQuery("delete MyEntity").executeUpdate();
    }
);
    sessionFactory.close();
  }
}
 
====================================================
SchemaToolTransactionHandlingTest.java at Line:93 col: 3
try {
  try {
    schemaDropper.doDrop(mappings,ExecutionOptionsTestImpl.INSTANCE,SourceDescriptorImpl.INSTANCE,TargetDescriptorImpl.INSTANCE);
  }
 catch (  CommandAcceptanceException e) {
  }
  schemaCreator.doCreation(mappings,ExecutionOptionsTestImpl.INSTANCE,SourceDescriptorImpl.INSTANCE,TargetDescriptorImpl.INSTANCE);
}
  finally {
  try {
    schemaDropper.doDrop(mappings,ExecutionOptionsTestImpl.INSTANCE,SourceDescriptorImpl.INSTANCE,TargetDescriptorImpl.INSTANCE);
  }
 catch (  Exception ignore) {
  }
}

====================================================
TableBasedDeleteHandlerImpl.java at Line:110 col: 2
try {
  PreparedStatement ps=null;
  int resultCount=0;
  try {
    try {
      ps=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(idInsertSelect,false);
      int position=1;
      position+=handlePrependedParametersOnIdSelection(ps,session,position);
      for (      ParameterSpecification parameterSpecification : idSelectParameterSpecifications) {
        position+=parameterSpecification.bind(ps,queryParameters,session,position);
      }
      resultCount=session.getJdbcCoordinator().getResultSetReturn().executeUpdate(ps);
    }
  finally {
      if (ps != null) {
        session.getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(ps);
        session.getJdbcCoordinator().afterStatementExecution();
      }
    }
  }
 catch (  SQLException e) {
    throw session.getJdbcServices().getSqlExceptionHelper().convert(e,"could not insert/select ids for bulk delete",idInsertSelect);
  }
  for (  String delete : deletes) {
    try {
      try {
        ps=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(delete,false);
        handleAddedParametersOnDelete(ps,session);
        session.getJdbcCoordinator().getResultSetReturn().executeUpdate(ps);
      }
  finally {
        if (ps != null) {
          session.getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(ps);
          session.getJdbcCoordinator().afterStatementExecution();
        }
      }
    }
 catch (    SQLException e) {
      throw session.getJdbcServices().getSqlExceptionHelper().convert(e,"error performing bulk delete",delete);
    }
  }
  return resultCount;
}
  finally {
  releaseFromUse(targetedPersister,session);
}

====================================================
SerializationHelper.java at Line:217 col: 2
try {
  CustomObjectInputStream in=new CustomObjectInputStream(inputStream,loader,fallbackLoader1,fallbackLoader2);
  try {
    return (T)in.readObject();
  }
 catch (  ClassNotFoundException e) {
    throw new SerializationException("could not deserialize",e);
  }
catch (  IOException e) {
    throw new SerializationException("could not deserialize",e);
  }
 finally {
    try {
      in.close();
    }
 catch (    IOException ignore) {
    }
  }
}
 catch (IOException e) {
  throw new SerializationException("could not deserialize",e);
}

====================================================
JmxServiceImpl.java at Line:72 col: 2
try {
  if (startedServer || registeredMBeans != null) {
    MBeanServer mBeanServer=findServer();
    if (mBeanServer == null) {
      LOG.unableToLocateMBeanServer();
      return;
    }
    if (registeredMBeans != null) {
      for (      ObjectName objectName : registeredMBeans) {
        try {
          LOG.tracev("Unregistering registered MBean [ON={0}]",objectName);
          mBeanServer.unregisterMBean(objectName);
        }
 catch (        Exception e) {
          LOG.debugf("Unable to unregsiter registered MBean [ON=%s] : %s",objectName,e.toString());
        }
      }
    }
    if (startedServer) {
      LOG.trace("Attempting to release created MBeanServer");
      try {
        MBeanServerFactory.releaseMBeanServer(mBeanServer);
      }
 catch (      Exception e) {
        LOG.unableToReleaseCreatedMBeanServer(e.toString());
      }
    }
  }
}
  finally {
  startedServer=false;
  if (registeredMBeans != null) {
    registeredMBeans.clear();
    registeredMBeans=null;
  }
}

====================================================
PersistenceXmlParser.java at Line:439 col: 3
try {
  try (InputStream inputStream=conn.getInputStream()){
    final InputSource inputSource=new InputSource(inputStream);
    try {
      DocumentBuilder documentBuilder=documentBuilderFactory().newDocumentBuilder();
      try {
        Document document=documentBuilder.parse(inputSource);
        validate(document);
        return document;
      }
 catch (      SAXException|IOException e) {
        throw new PersistenceException("Unexpected error parsing [" + resourceName + "]",e);
      }
    }
 catch (    ParserConfigurationException e) {
      throw new PersistenceException("Unable to generate javax.xml.parsers.DocumentBuilder instance",e);
    }
  }
 }
 catch (IOException e) {
  throw new PersistenceException("Unable to obtain input stream from [" + resourceName + "]",e);
}

====================================================
SessionCreateQueryFromCriteriaTest.java at Line:118 col: 2
try (Session s=openSession()){
  session.getTransaction().begin();
  try {
    s.save(entity);
    s.getTransaction().commit();
  }
 catch (  Exception e) {
    if (s.getTransaction().isActive()) {
      s.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
LobCreatorBuilder.java at Line:94 col: 4
try {
  final Object clob=createClobMethod.invoke(jdbcConnection,NO_ARGS);
  try {
    final Method freeMethod=clob.getClass().getMethod("free",NO_ARG_SIG);
    freeMethod.invoke(clob,NO_ARGS);
  }
 catch (  Throwable ignore) {
    LOG.tracef("Unable to free CLOB created to test createClob() implementation : %s",ignore);
  }
  return true;
}
 catch (Throwable t) {
  LOG.disablingContextualLOBCreationSinceCreateClobFailed(t);
}

====================================================
SchemaToolTransactionHandlingTest.java at Line:87 col: 2
try {
  final SchemaManagementTool smt=registry.getService(SchemaManagementTool.class);
  final SchemaDropper schemaDropper=smt.getSchemaDropper(Collections.emptyMap());
  final SchemaCreator schemaCreator=smt.getSchemaCreator(Collections.emptyMap());
  final Metadata mappings=buildMappings(registry);
  try {
    try {
      schemaDropper.doDrop(mappings,ExecutionOptionsTestImpl.INSTANCE,SourceDescriptorImpl.INSTANCE,TargetDescriptorImpl.INSTANCE);
    }
 catch (    CommandAcceptanceException e) {
    }
    schemaCreator.doCreation(mappings,ExecutionOptionsTestImpl.INSTANCE,SourceDescriptorImpl.INSTANCE,TargetDescriptorImpl.INSTANCE);
  }
  finally {
    try {
      schemaDropper.doDrop(mappings,ExecutionOptionsTestImpl.INSTANCE,SourceDescriptorImpl.INSTANCE,TargetDescriptorImpl.INSTANCE);
    }
 catch (    Exception ignore) {
    }
  }
}
  finally {
  try {
    jtaTransaction.commit();
    ((StandardServiceRegistryImpl)registry).destroy();
  }
 catch (  Exception e) {
  }
}

====================================================
AbstractCollectionPersister.java at Line:2003 col: 2
try {
  final JdbcCoordinator jdbcCoordinator=session.getJdbcCoordinator();
  PreparedStatement st=jdbcCoordinator.getStatementPreparer().prepareStatement(sql);
  try {
    getKeyType().nullSafeSet(st,key,1,session);
    indexOrElementType.nullSafeSet(st,indexOrElement,keyColumnNames.length + 1,session);
    ResultSet rs=jdbcCoordinator.getResultSetReturn().extract(st);
    try {
      return rs.next();
    }
  finally {
      jdbcCoordinator.getResourceRegistry().release(rs,st);
    }
  }
 catch (  TransientObjectException e) {
    return false;
  }
 finally {
    jdbcCoordinator.getResourceRegistry().release(st);
    jdbcCoordinator.afterStatementExecution();
  }
}
 catch (SQLException sqle) {
  throw getSQLExceptionHelper().convert(sqle,"could not check row existence: " + MessageHelper.collectionInfoString(this,key,getFactory()),sqlSelectSizeString);
}

====================================================
TransactionRollbackTest.java at Line:42 col: 2
try {
  final Session session=em.unwrap(Session.class);
  final OperationCollectorObserver transactionObserver=new OperationCollectorObserver();
  ((JdbcSessionOwner)session).getTransactionCoordinator().addObserver(transactionObserver);
  em.getTransaction().begin();
  em.persist(new Shipment("shipment-1","INITIAL"));
  em.persist(new Shipment("shipment-2","INITIAL"));
  em.flush();
  em.clear();
  try {
    em.persist(new Shipment("shipment-1","INITIAL"));
    em.getTransaction().commit();
    fail("Expected exception was not raised");
  }
 catch (  Exception e) {
  }
  assertThat(transactionObserver.getUnSuccessfulAfterCompletion(),is(1));
  em.clear();
  em.getTransaction().begin();
  Shipment shipment=em.find(Shipment.class,"shipment-1");
  if (shipment != null) {
    em.remove(shipment);
  }
  shipment=em.find(Shipment.class,"shipment-2");
  if (shipment != null) {
    em.remove(shipment);
  }
  em.getTransaction().commit();
}
  finally {
  em.close();
}

====================================================
EntityTransactionTests.java at Line:41 col: 2
try {
  final SessionFactoryImplementor sessionFactory=(SessionFactoryImplementor)new MetadataSources(ssr).buildMetadata().buildSessionFactory();
  try {
    inSession(sessionFactory,session -> {
      final Transaction transaction=session.getTransaction();
      assertFalse(transaction.isActive());
      try {
        transaction.getRollbackOnly();
        fail("Expecting failure #getRollbackOnly on non-active txn");
      }
 catch (      IllegalStateException expected) {
      }
    }
);
  }
  finally {
    sessionFactory.close();
  }
}
  finally {
  StandardServiceRegistryBuilder.destroy(ssr);
}

====================================================
PersistenceXmlParser.java at Line:442 col: 5
try {
  DocumentBuilder documentBuilder=documentBuilderFactory().newDocumentBuilder();
  try {
    Document document=documentBuilder.parse(inputSource);
    validate(document);
    return document;
  }
 catch (  SAXException|IOException e) {
    throw new PersistenceException("Unexpected error parsing [" + resourceName + "]",e);
  }
}
 catch (ParserConfigurationException e) {
  throw new PersistenceException("Unable to generate javax.xml.parsers.DocumentBuilder instance",e);
}

====================================================
ScanningCoordinator.java at Line:126 col: 4
try {
  final Constructor<? extends Scanner> constructor=scannerImplClass.getConstructor(SINGLE_ARG);
  try {
    return constructor.newInstance(archiveDescriptorFactory);
  }
 catch (  Exception e) {
    throw new IllegalStateException("Error trying to instantiate custom specified Scanner [" + scannerImplClass.getName() + "]",e);
  }
}
 catch (NoSuchMethodException e) {
  throw new IllegalArgumentException("Configuration named a custom Scanner and a custom ArchiveDescriptorFactory, but " + "Scanner impl did not define a constructor accepting ArchiveDescriptorFactory");
}

====================================================
PessimisticReadSelectLockingStrategy.java at Line:59 col: 2
try {
  final Lockable lockable=getLockable();
  try {
    final JdbcCoordinator jdbcCoordinator=session.getJdbcCoordinator();
    final PreparedStatement st=jdbcCoordinator.getStatementPreparer().prepareStatement(sql);
    try {
      lockable.getIdentifierType().nullSafeSet(st,id,1,session);
      if (lockable.isVersioned()) {
        lockable.getVersionType().nullSafeSet(st,version,lockable.getIdentifierType().getColumnSpan(factory) + 1,session);
      }
      final ResultSet rs=jdbcCoordinator.getResultSetReturn().extract(st);
      if (!rs.next()) {
        final StatisticsImplementor statistics=factory.getStatistics();
        if (statistics.isStatisticsEnabled()) {
          statistics.optimisticFailure(lockable.getEntityName());
        }
        throw new StaleObjectStateException(lockable.getEntityName(),id);
      }
    }
  finally {
      jdbcCoordinator.getLogicalConnection().getResourceRegistry().release(st);
      jdbcCoordinator.afterStatementExecution();
    }
  }
 catch (  SQLException e) {
    throw session.getJdbcServices().getSqlExceptionHelper().convert(e,"could not lock: " + MessageHelper.infoString(lockable,id,session.getFactory()),sql);
  }
}
 catch (JDBCException e) {
  throw new PessimisticEntityLockException(object,"could not obtain pessimistic lock",e);
}

====================================================
JdbcProperties.java at Line:33 col: 2
try {
  inputStream=Thread.currentThread().getContextClassLoader().getResourceAsStream("hibernate.properties");
  try {
    connectionProperties.load(inputStream);
    url=connectionProperties.getProperty("hibernate.connection.url");
    user=connectionProperties.getProperty("hibernate.connection.username");
    password=connectionProperties.getProperty("hibernate.connection.password");
  }
 catch (  IOException e) {
    throw new IllegalArgumentException(e);
  }
}
  finally {
  try {
    if (inputStream != null) {
      inputStream.close();
    }
  }
 catch (  IOException ignore) {
    log.error(ignore.getMessage());
  }
}

====================================================
PessimisticWriteSelectLockingStrategy.java at Line:58 col: 2
try {
  final Lockable lockable=getLockable();
  try {
    final JdbcCoordinator jdbcCoordinator=session.getJdbcCoordinator();
    final PreparedStatement st=jdbcCoordinator.getStatementPreparer().prepareStatement(sql);
    try {
      lockable.getIdentifierType().nullSafeSet(st,id,1,session);
      if (lockable.isVersioned()) {
        lockable.getVersionType().nullSafeSet(st,version,lockable.getIdentifierType().getColumnSpan(factory) + 1,session);
      }
      final ResultSet rs=jdbcCoordinator.getResultSetReturn().extract(st);
      try {
        if (!rs.next()) {
          final StatisticsImplementor statistics=factory.getStatistics();
          if (statistics.isStatisticsEnabled()) {
            statistics.optimisticFailure(lockable.getEntityName());
          }
          throw new StaleObjectStateException(lockable.getEntityName(),id);
        }
      }
  finally {
        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release(rs,st);
      }
    }
  finally {
      jdbcCoordinator.getLogicalConnection().getResourceRegistry().release(st);
      jdbcCoordinator.afterStatementExecution();
    }
  }
 catch (  SQLException e) {
    throw session.getJdbcServices().getSqlExceptionHelper().convert(e,"could not lock: " + MessageHelper.infoString(lockable,id,session.getFactory()),sql);
  }
}
 catch (JDBCException e) {
  throw new PessimisticEntityLockException(object,"could not obtain pessimistic lock",e);
}

====================================================
JaxbCfgProcessor.java at Line:160 col: 2
try {
  InputStream schemaStream=url.openStream();
  try {
    StreamSource source=new StreamSource(url.openStream());
    SchemaFactory schemaFactory=SchemaFactory.newInstance(schemaLanguage);
    return schemaFactory.newSchema(source);
  }
 catch (  SAXException e) {
    throw new XsdException("Unable to load schema [" + schemaName + "]",e,schemaName);
  }
catch (  IOException e) {
    throw new XsdException("Unable to load schema [" + schemaName + "]",e,schemaName);
  }
 finally {
    try {
      schemaStream.close();
    }
 catch (    IOException e) {
      log.debugf("Problem closing schema stream [%s]",e.toString());
    }
  }
}
 catch (IOException e) {
  throw new XsdException("Stream error handling schema url [" + url.toExternalForm() + "]",schemaName);
}

====================================================
IdTableHelper.java at Line:78 col: 3
try {
  Statement statement=connection.createStatement();
  for (  String creationStatement : creationStatements) {
    try {
      jdbcServices.getSqlStatementLogger().logStatement(creationStatement);
      statement.execute(creationStatement);
    }
 catch (    SQLException e) {
      log.debugf("Error attempting to export id-table [%s] : %s",creationStatement,e.getMessage());
    }
  }
  statement.close();
}
 catch (SQLException e) {
  log.error("Unable to use JDBC Connection to create Statement",e);
}
 finally {
  try {
    connectionAccess.releaseConnection(connection);
  }
 catch (  SQLException ignore) {
  }
}

====================================================
IndividuallySchemaValidatorImplTest.java at Line:221 col: 2
try {
  new SchemaCreatorImpl(ssr).doCreation(metadata,serviceRegistry,settings,true,schemaGenerator);
  metadataSources=new MetadataSources(ssr);
  metadataSources.addAnnotatedClass(IntegerNameColumn.class);
  metadata=(MetadataImplementor)metadataSources.buildMetadata();
  metadata.validate();
  try {
    getSchemaValidator(metadata);
    Assert.fail("SchemaManagementException expected");
  }
 catch (  SchemaManagementException e) {
    assertEquals("Schema-validation: wrong column type encountered in column [name] in table [SomeSchema.ColumnEntity]; found [varchar (Types#VARCHAR)], but expecting [integer (Types#INTEGER)]",e.getMessage());
  }
}
  finally {
  new SchemaDropperImpl(serviceRegistry).doDrop(metadata,false,schemaGenerator);
  serviceRegistry.destroy();
  connectionProvider.stop();
}

====================================================
PostgreSQLMultipleSchemaSequenceTest.java at Line:102 col: 4
try {
  final MetadataImplementor metadata2=(MetadataImplementor)new MetadataSources(ssr2).addAnnotatedClass(Box.class).buildMetadata();
  try {
    new SchemaExport().setOutputFile(output.getAbsolutePath()).create(EnumSet.of(TargetType.DATABASE,TargetType.SCRIPT),metadata2);
  }
  finally {
    final ConnectionProvider connectionProvider2=ssr2.getService(ConnectionProvider.class);
    DdlTransactionIsolatorTestingImpl ddlTransactionIsolator2=new DdlTransactionIsolatorTestingImpl(ssr2,new JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess(connectionProvider2));
    try (Statement statement=ddlTransactionIsolator2.getIsolatedConnection().createStatement()){
      try (ResultSet resultSet=statement.executeQuery("SELECT NEXTVAL('SEQ_TEST')")){
        while (resultSet.next()) {
          Long sequenceValue=resultSet.getLong(1);
          assertEquals(Long.valueOf(1L),sequenceValue);
        }
      }
       statement.execute(String.format("DROP SCHEMA IF EXISTS %s CASCADE",extraSchemaName));
    }
 catch (    SQLException e) {
      fail(e.getMessage());
    }
    new SchemaExport().drop(EnumSet.of(TargetType.DATABASE),metadata2);
  }
}
  finally {
  StandardServiceRegistryBuilder.destroy(ssr2);
}

====================================================
EntityTransactionTests.java at Line:218 col: 2
try {
  final SessionFactoryImplementor sessionFactory=(SessionFactoryImplementor)new MetadataSources(ssr).buildMetadata().buildSessionFactory();
  try {
    inSession(sessionFactory,session -> {
      final Transaction transaction=session.getTransaction();
      assertFalse(transaction.isActive());
      try {
        transaction.rollback();
        fail("Expecting failure #rollback on non-active txn");
      }
 catch (      IllegalStateException expected) {
      }
    }
);
  }
  finally {
    sessionFactory.close();
  }
}
  finally {
  StandardServiceRegistryBuilder.destroy(ssr);
}

====================================================
IdTableHelper.java at Line:123 col: 3
try {
  Statement statement=connection.createStatement();
  for (  String dropStatement : dropStatements) {
    try {
      jdbcServices.getSqlStatementLogger().logStatement(dropStatement);
      statement.execute(dropStatement);
    }
 catch (    SQLException e) {
      log.debugf("Error attempting to cleanup id-table : [%s]",e.getMessage());
    }
  }
  statement.close();
}
 catch (SQLException e) {
  log.error("Unable to use JDBC Connection to create Statement",e);
}
 finally {
  try {
    connectionAccess.releaseConnection(connection);
  }
 catch (  SQLException ignore) {
  }
}

====================================================
AbstractSchemaMigrator.java at Line:95 col: 3
try {
  final DatabaseInformation databaseInformation=Helper.buildDatabaseInformation(tool.getServiceRegistry(),ddlTransactionIsolator,metadata.getDatabase().getDefaultNamespace().getName());
  final GenerationTarget[] targets=tool.buildGenerationTargets(targetDescriptor,ddlTransactionIsolator,options.getConfigurationValues());
  try {
    for (    GenerationTarget target : targets) {
      target.prepare();
    }
    try {
      performMigration(metadata,databaseInformation,options,jdbcContext.getDialect(),targets);
    }
  finally {
      for (      GenerationTarget target : targets) {
        try {
          target.release();
        }
 catch (        Exception e) {
          log.debugf("Problem releasing GenerationTarget [%s] : %s",target,e.getMessage());
        }
      }
    }
  }
  finally {
    try {
      databaseInformation.cleanup();
    }
 catch (    Exception e) {
      log.debug("Problem releasing DatabaseInformation : " + e.getMessage());
    }
  }
}
  finally {
  ddlTransactionIsolator.release();
}

====================================================
EntityTransactionTests.java at Line:111 col: 2
try {
  final SessionFactoryImplementor sessionFactory=(SessionFactoryImplementor)new MetadataSources(ssr).buildMetadata().buildSessionFactory();
  try {
    inSession(sessionFactory,session -> {
      final Transaction transaction=session.getTransaction();
      transaction.begin();
      try {
        assertTrue(transaction.isActive());
        transaction.setRollbackOnly();
        assertTrue(transaction.isActive());
        assertTrue(transaction.getRollbackOnly());
      }
  finally {
        if (transaction.isActive()) {
          transaction.rollback();
        }
      }
    }
);
    inSession(sessionFactory,session -> {
      final Transaction transaction=session.getTransaction();
      transaction.begin();
      try {
        assertTrue(transaction.isActive());
        transaction.setRollbackOnly();
        assertTrue(transaction.isActive());
        assertTrue(transaction.getRollbackOnly());
        try {
          transaction.commit();
        }
 catch (        RollbackException e) {
          assertFalse(transaction.isActive());
          assertThat(transaction.getStatus(),CoreMatchers.is(TransactionStatus.ROLLED_BACK));
        }
      }
  finally {
        if (transaction.isActive()) {
          transaction.rollback();
        }
      }
    }
);
  }
  finally {
    sessionFactory.close();
  }
}
  finally {
  StandardServiceRegistryBuilder.destroy(ssr);
}

====================================================
LockTest.java at Line:670 col: 5
try {
  AtomicBoolean timedOut=new AtomicBoolean();
  doInJPA(this::entityManagerFactory,_entityManager -> {
    log.info("testContendedPessimisticReadLockTimeout: (BG) about to read write-locked entity");
    Lock lock2=_entityManager.getReference(Lock.class,lock.getId());
    lock2.getName();
    log.info("testContendedPessimisticReadLockTimeout: (BG) read write-locked entity");
    Map<String,Object> props=new HashMap<String,Object>();
    props.put(AvailableSettings.LOCK_TIMEOUT,1000);
    try {
      _entityManager.lock(lock2,LockModeType.PESSIMISTIC_READ,props);
    }
 catch (    LockTimeoutException e) {
      log.info("testContendedPessimisticReadLockTimeout: (BG) got expected timeout exception");
      timedOut.set(true);
    }
catch (    Throwable e) {
      log.info("Expected LockTimeoutException but got unexpected exception",e);
      throw new RuntimeException("Expected LockTimeoutException but got unexpected exception",e);
    }
  }
);
  return timedOut.get();
}
  finally {
  latch.countDown();
}

====================================================
EntityTransactionTests.java at Line:223 col: 3
try {
  inSession(sessionFactory,session -> {
    final Transaction transaction=session.getTransaction();
    assertFalse(transaction.isActive());
    try {
      transaction.rollback();
      fail("Expecting failure #rollback on non-active txn");
    }
 catch (    IllegalStateException expected) {
    }
  }
);
}
  finally {
  sessionFactory.close();
}

====================================================
MySQLStoredProcedureTest.java at Line:163 col: 2
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (Statement statement=connection.createStatement()){
      statement.executeUpdate("DROP PROCEDURE IF EXISTS sp_count_phones");
    }
 catch (    SQLException ignore) {
    }
  }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
DelayedCdiSupportTest.java at Line:47 col: 2
try (final SeContainer cdiContainer=cdiInitializer.initialize()){
  BootstrapServiceRegistry bsr=new BootstrapServiceRegistryBuilder().build();
  final StandardServiceRegistry ssr=new StandardServiceRegistryBuilder(bsr).applySetting(AvailableSettings.HBM2DDL_AUTO,Action.CREATE_DROP).applySetting(AvailableSettings.CDI_BEAN_MANAGER,cdiContainer.getBeanManager()).applySetting(AvailableSettings.DELAY_CDI_ACCESS,"true").build();
  final SessionFactoryImplementor sessionFactory;
  try {
    sessionFactory=(SessionFactoryImplementor)new MetadataSources(ssr).addAnnotatedClass(TheEntity.class).buildMetadata().getSessionFactoryBuilder().build();
  }
 catch (  Exception e) {
    StandardServiceRegistryBuilder.destroy(ssr);
    throw e;
  }
  assertFalse(Monitor.wasInstantiated());
  assertEquals(0,Monitor.currentCount());
  try {
    inTransaction(sessionFactory,session -> session.persist(new TheEntity(1)));
    assertTrue(Monitor.wasInstantiated());
    assertEquals(1,Monitor.currentCount());
    inTransaction(sessionFactory,session -> {
      TheEntity it=session.find(TheEntity.class,1);
      assertNotNull(it);
    }
);
  }
  finally {
    inTransaction(sessionFactory,session -> {
      session.createQuery("delete TheEntity").executeUpdate();
    }
);
    sessionFactory.close();
  }
}
 
====================================================
MetadataSources.java at Line:447 col: 2
try {
  JarFile jarFile=new JarFile(jar);
  final boolean TRACE=LOG.isTraceEnabled();
  try {
    Enumeration jarEntries=jarFile.entries();
    while (jarEntries.hasMoreElements()) {
      final ZipEntry zipEntry=(ZipEntry)jarEntries.nextElement();
      if (zipEntry.getName().endsWith(".hbm.xml")) {
        if (TRACE) {
          LOG.tracef("found mapping document : %s",zipEntry.getName());
        }
        getXmlBindingsForWrite().add(new JarFileEntryXmlSource(origin,jarFile,zipEntry).doBind(getXmlMappingBinderAccess().getMappingBinder()));
      }
    }
  }
  finally {
    try {
      jarFile.close();
    }
 catch (    Exception ignore) {
    }
  }
}
 catch (IOException e) {
  throw new MappingNotFoundException(e,origin);
}

====================================================
TestConnectionPool.java at Line:72 col: 3
try {
  for (int j=0; j < 2; j++) {
    try {
      final CriteriaBuilder builder=entityManager.getCriteriaBuilder();
      final CriteriaQuery<TestEntity> criteriaQuery=builder.createQuery(TestEntity.class);
      criteriaQuery.select(criteriaQuery.from(TestEntity.class));
      entityManager.createQuery(criteriaQuery).getResultList();
    }
 catch (    PersistenceException e) {
      if (e.getCause() instanceof SQLGrammarException) {
      }
 else {
        throw e;
      }
    }
  }
}
  finally {
  entityManager.close();
}

====================================================
StandardCdiSupportTest.java at Line:46 col: 2
try (final SeContainer cdiContainer=cdiInitializer.initialize()){
  BootstrapServiceRegistry bsr=new BootstrapServiceRegistryBuilder().build();
  final StandardServiceRegistry ssr=new StandardServiceRegistryBuilder(bsr).applySetting(AvailableSettings.HBM2DDL_AUTO,Action.CREATE_DROP).applySetting(AvailableSettings.CDI_BEAN_MANAGER,cdiContainer.getBeanManager()).build();
  final SessionFactoryImplementor sessionFactory;
  try {
    sessionFactory=(SessionFactoryImplementor)new MetadataSources(ssr).addAnnotatedClass(TheEntity.class).buildMetadata().getSessionFactoryBuilder().build();
  }
 catch (  Exception e) {
    StandardServiceRegistryBuilder.destroy(ssr);
    throw e;
  }
  assertTrue(Monitor.wasInstantiated());
  assertEquals(0,Monitor.currentCount());
  try {
    inTransaction(sessionFactory,session -> session.persist(new TheEntity(1)));
    assertEquals(1,Monitor.currentCount());
    inTransaction(sessionFactory,session -> {
      TheEntity it=session.find(TheEntity.class,1);
      assertNotNull(it);
    }
);
  }
  finally {
    inTransaction(sessionFactory,session -> {
      session.createQuery("delete TheEntity").executeUpdate();
    }
);
    sessionFactory.close();
  }
}
 
====================================================
UpdateEntitiesWithPackageNamesStartingWithKeywordsTest.java at Line:114 col: 2
try (Session session=openSession()){
  session.getTransaction().begin();
  try {
    session.createQuery("DELETE FROM In").executeUpdate();
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().getStatus() == TransactionStatus.ACTIVE) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
AbstractEntityPersister.java at Line:3203 col: 2
try {
  final PreparedStatement insert;
  if (useBatch) {
    insert=session.getJdbcCoordinator().getBatch(inserBatchKey).getBatchStatement(sql,callable);
  }
 else {
    insert=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(sql,callable);
  }
  try {
    int index=1;
    index+=expectation.prepare(insert);
    dehydrate(id,fields,null,notNull,propertyColumnInsertable,j,insert,session,index,false);
    if (useBatch) {
      session.getJdbcCoordinator().getBatch(inserBatchKey).addToBatch();
    }
 else {
      expectation.verifyOutcome(session.getJdbcCoordinator().getResultSetReturn().executeUpdate(insert),insert,-1);
    }
  }
 catch (  SQLException|JDBCException e) {
    if (useBatch) {
      session.getJdbcCoordinator().abortBatch();
    }
    throw e;
  }
 finally {
    if (!useBatch) {
      session.getJdbcCoordinator().getResourceRegistry().release(insert);
      session.getJdbcCoordinator().afterStatementExecution();
    }
  }
}
 catch (SQLException e) {
  throw getFactory().getSQLExceptionHelper().convert(e,"could not insert: " + MessageHelper.infoString(this),sql);
}

====================================================
EmbeddableIntegratorTest.java at Line:44 col: 2
try {
  Session sess=sf.openSession();
  try {
    sess.getTransaction().begin();
    Investor myInv=getInvestor();
    myInv.setId(1L);
    sess.save(myInv);
    sess.flush();
    fail("A JDBCException expected");
    sess.clear();
    Investor inv=(Investor)sess.get(Investor.class,1L);
    assertEquals(new BigDecimal("100"),inv.getInvestments().get(0).getAmount().getAmount());
  }
 catch (  PersistenceException e) {
    assertTyping(JDBCException.class,e.getCause());
    sess.getTransaction().rollback();
  }
  sess.close();
}
  finally {
  sf.close();
}

====================================================
NonJpaComplianceAlreadyStartedTransactionTest.java at Line:53 col: 2
try (Session s=openSession()){
  Transaction tx=s.beginTransaction();
  try {
    s.saveOrUpdate(new TestEntity("ABC"));
    tx.commit();
  }
 catch (  Exception e) {
    if (tx.isActive()) {
      tx.rollback();
    }
    throw e;
  }
}
 
====================================================
AbstractProducedQuery.java at Line:1020 col: 2
try {
  if (HINT_TIMEOUT.equals(hintName)) {
    applied=applyTimeoutHint(ConfigurationHelper.getInteger(value));
  }
 else   if (SPEC_HINT_TIMEOUT.equals(hintName)) {
    int timeout=(int)Math.round(ConfigurationHelper.getInteger(value).doubleValue() / 1000.0);
    applied=applyTimeoutHint(timeout);
  }
 else   if (JPA_LOCK_TIMEOUT.equals(hintName)) {
    applied=applyLockTimeoutHint(ConfigurationHelper.getInteger(value));
  }
 else   if (HINT_COMMENT.equals(hintName)) {
    applied=applyCommentHint((String)value);
  }
 else   if (HINT_FETCH_SIZE.equals(hintName)) {
    applied=applyFetchSizeHint(ConfigurationHelper.getInteger(value));
  }
 else   if (HINT_CACHEABLE.equals(hintName)) {
    applied=applyCacheableHint(ConfigurationHelper.getBoolean(value));
  }
 else   if (HINT_CACHE_REGION.equals(hintName)) {
    applied=applyCacheRegionHint((String)value);
  }
 else   if (HINT_READONLY.equals(hintName)) {
    applied=applyReadOnlyHint(ConfigurationHelper.getBoolean(value));
  }
 else   if (HINT_FLUSH_MODE.equals(hintName)) {
    applied=applyFlushModeHint(ConfigurationHelper.getFlushMode(value));
  }
 else   if (HINT_CACHE_MODE.equals(hintName)) {
    applied=applyCacheModeHint(ConfigurationHelper.getCacheMode(value));
  }
 else   if (JPA_SHARED_CACHE_RETRIEVE_MODE.equals(hintName)) {
    final CacheRetrieveMode retrieveMode=value != null ? CacheRetrieveMode.valueOf(value.toString()) : null;
    applied=applyJpaCacheRetrieveMode(retrieveMode);
  }
 else   if (JPA_SHARED_CACHE_STORE_MODE.equals(hintName)) {
    final CacheStoreMode storeMode=value != null ? CacheStoreMode.valueOf(value.toString()) : null;
    applied=applyJpaCacheStoreMode(storeMode);
  }
 else   if (QueryHints.HINT_NATIVE_LOCKMODE.equals(hintName)) {
    applied=applyNativeQueryLockMode(value);
  }
 else   if (hintName.startsWith(ALIAS_SPECIFIC_LOCK_MODE)) {
    if (canApplyAliasSpecificLockModeHints()) {
      final String alias=hintName.substring(ALIAS_SPECIFIC_LOCK_MODE.length() + 1);
      try {
        final LockMode lockMode=LockModeTypeHelper.interpretLockMode(value);
        applyAliasSpecificLockModeHint(alias,lockMode);
      }
 catch (      Exception e) {
        MSG_LOGGER.unableToDetermineLockModeValue(hintName,value);
        applied=false;
      }
    }
 else {
      applied=false;
    }
  }
 else   if (HINT_FETCHGRAPH.equals(hintName) || HINT_LOADGRAPH.equals(hintName)) {
    if (value instanceof RootGraph) {
      applyGraph((RootGraph)value,GraphSemantic.fromJpaHintName(hintName));
      applyEntityGraphQueryHint(new EntityGraphQueryHint(hintName,(RootGraphImpl)value));
    }
 else {
      MSG_LOGGER.warnf("The %s hint was set, but the value was not an EntityGraph!",hintName);
    }
    applied=true;
  }
 else   if (HINT_FOLLOW_ON_LOCKING.equals(hintName)) {
    applied=applyFollowOnLockingHint(ConfigurationHelper.getBoolean(value));
  }
 else   if (QueryHints.HINT_PASS_DISTINCT_THROUGH.equals(hintName)) {
    applied=applyPassDistinctThrough(ConfigurationHelper.getBoolean(value));
  }
 else {
    MSG_LOGGER.ignoringUnrecognizedQueryHint(hintName);
  }
}
 catch (ClassCastException e) {
  throw new IllegalArgumentException("Value for hint");
}

====================================================
ThreadLocalSessionContext.java at Line:203 col: 3
try {
  final Transaction orphanTransaction=orphan.getTransaction();
  if (orphanTransaction != null && orphanTransaction.getStatus() == TransactionStatus.ACTIVE) {
    try {
      orphanTransaction.rollback();
    }
 catch (    Throwable t) {
      LOG.debug("Unable to rollback transaction for orphaned session",t);
    }
  }
}
  finally {
  try {
    orphan.close();
  }
 catch (  Throwable t) {
    LOG.debug("Unable to close orphaned session",t);
  }
}

====================================================
OracleStoredProcedureTest.java at Line:419 col: 8
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (CallableStatement function=connection.prepareCall("{ ? = call fn_person_and_phones( ? ) }")){
      try {
        function.registerOutParameter(1,Types.REF_CURSOR);
      }
 catch (      SQLException e) {
        function.registerOutParameter(1,-10);
      }
      function.setInt(2,1);
      function.execute();
      try (ResultSet resultSet=(ResultSet)function.getObject(1)){
        while (resultSet.next()) {
          Long postCommentId=resultSet.getLong(1);
          String review=resultSet.getString(2);
        }
      }
     }
   }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
BeanValidationIntegrator.java at Line:104 col: 3
try {
  final Class typeSafeActivatorClass=loadTypeSafeActivatorClass(classLoaderService);
  @SuppressWarnings("unchecked") final Method activateMethod=typeSafeActivatorClass.getMethod(ACTIVATE_METHOD_NAME,ActivationContext.class);
  final ActivationContext activationContext=new ActivationContext(){
    @Override public Set<ValidationMode> getValidationModes(){
      return modes;
    }
    @Override public Metadata getMetadata(){
      return metadata;
    }
    @Override public SessionFactoryImplementor getSessionFactory(){
      return sessionFactory;
    }
    @Override public SessionFactoryServiceRegistry getServiceRegistry(){
      return serviceRegistry;
    }
  }
;
  try {
    activateMethod.invoke(null,activationContext);
  }
 catch (  InvocationTargetException e) {
    if (HibernateException.class.isInstance(e.getTargetException())) {
      throw ((HibernateException)e.getTargetException());
    }
    throw new IntegrationException("Error activating Bean Validation integration",e.getTargetException());
  }
catch (  Exception e) {
    throw new IntegrationException("Error activating Bean Validation integration",e);
  }
}
 catch (NoSuchMethodException e) {
  throw new HibernateException("Unable to locate TypeSafeActivator#activate method",e);
}

====================================================
ExplodedArchiveDescriptor.java at Line:148 col: 2
try (final JarFile jarFile=new JarFile(rootFile)){
  final Enumeration<? extends ZipEntry> entries=jarFile.entries();
  while (entries.hasMoreElements()) {
    final ZipEntry zipEntry=entries.nextElement();
    if (zipEntry.isDirectory()) {
      continue;
    }
    final String name=extractName(zipEntry);
    final String relativeName=extractRelativeName(zipEntry);
    final InputStreamAccess inputStreamAccess;
    try {
      inputStreamAccess=buildByteBasedInputStreamAccess(name,jarFile.getInputStream(zipEntry));
    }
 catch (    IOException e) {
      throw new ArchiveException(String.format("Unable to access stream from jar file [%s] for entry [%s]",jarFile.getName(),zipEntry.getName()));
    }
    final ArchiveEntry entry=new ArchiveEntry(){
      @Override public String getName(){
        return name;
      }
      @Override public String getNameWithinArchive(){
        return relativeName;
      }
      @Override public InputStreamAccess getStreamAccess(){
        return inputStreamAccess;
      }
    }
;
    context.obtainArchiveEntryHandler(entry).handleEntry(entry,context);
  }
}
 catch (IOException e) {
  throw new ArchiveException("Error accessing jar file [" + rootFile.getAbsolutePath() + "]",e);
}

====================================================
ComponentTuplizerFactory.java at Line:143 col: 2
try {
  constructor=clazz.getDeclaredConstructor(COMPONENT_TUP_CTOR_SIG);
  try {
    ReflectHelper.ensureAccessibility(constructor);
  }
 catch (  SecurityException e) {
    constructor=null;
  }
}
 catch (NoSuchMethodException ignore) {
}

====================================================
PersistenceXmlParser.java at Line:440 col: 4
try (InputStream inputStream=conn.getInputStream()){
  final InputSource inputSource=new InputSource(inputStream);
  try {
    DocumentBuilder documentBuilder=documentBuilderFactory().newDocumentBuilder();
    try {
      Document document=documentBuilder.parse(inputSource);
      validate(document);
      return document;
    }
 catch (    SAXException|IOException e) {
      throw new PersistenceException("Unexpected error parsing [" + resourceName + "]",e);
    }
  }
 catch (  ParserConfigurationException e) {
    throw new PersistenceException("Unable to generate javax.xml.parsers.DocumentBuilder instance",e);
  }
}
 
====================================================
InterceptorTest.java at Line:164 col: 2
try {
  MetadataSources metadataSources=new MetadataSources(standardRegistry);
  for (  Class annotatedClass : getAnnotatedClasses()) {
    metadataSources.addAnnotatedClass(annotatedClass);
  }
  Metadata metadata=metadataSources.getMetadataBuilder().build();
  SessionFactoryBuilder sessionFactoryBuilder=metadata.getSessionFactoryBuilder();
  sessionFactoryBuilder.applyStatelessInterceptor(LocalExceptionInterceptor.class);
  sessionFactory=sessionFactoryBuilder.build();
  final SessionFactory sessionFactoryInstance=sessionFactory;
  Supplier<SessionFactory> sessionFactorySupplier=() -> sessionFactoryInstance;
  Item i=new Item();
  i.setName("Laptop");
  try {
    doInHibernate(sessionFactorySupplier,session -> {
      session.persist(i);
      fail("No interceptor");
      return null;
    }
);
  }
 catch (  IllegalStateException e) {
    assertEquals(LocalExceptionInterceptor.LOCAL_EXCEPTION_MESSAGE,e.getMessage());
  }
}
  finally {
  if (sessionFactory != null) {
    sessionFactory.close();
  }
  standardRegistry.destroy();
}

====================================================
DriverManagerConnectionProviderImpl.java at Line:414 col: 3
try {
  if (!active) {
    return;
  }
  log.cleaningUpConnectionPool(pool.getUrl());
  active=false;
  if (executorService != null) {
    executorService.shutdown();
  }
  executorService=null;
  try {
    pool.close();
  }
 catch (  SQLException e) {
    log.unableToClosePooledConnection(e);
  }
}
  finally {
  statelock.writeLock().unlock();
}

====================================================
InvalidExtendedCdiSupportTest.java at Line:77 col: 2
try {
  assertFalse(Monitor.wasInstantiated());
  assertEquals(0,Monitor.currentCount());
  try {
    inTransaction(sessionFactory,session -> session.persist(new TheEntity(1)));
    inTransaction(sessionFactory,session -> {
      session.createQuery("delete TheEntity").executeUpdate();
    }
);
    fail("Expecting failure");
  }
 catch (  IllegalStateException expected) {
  }
}
  finally {
  sessionFactory.close();
}

====================================================
LockTest.java at Line:795 col: 2
try {
  lock.setName("testContendedPessimisticWriteLockTimeout");
  doInJPA(this::entityManagerFactory,em -> {
    em.persist(lock);
  }
);
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.lock(_lock,LockModeType.PESSIMISTIC_WRITE);
    final Integer id=_lock.getId();
    _lock.getName();
    log.info("testContendedPessimisticWriteLockTimeout: got write lock");
    try {
      t.start();
      boolean latchSet=latch.await(10,TimeUnit.SECONDS);
      assertTrue("background test thread finished (lock timeout is broken)",latchSet);
      assertTrue("background test thread timed out on lock attempt",bgTask.get());
    }
 catch (    InterruptedException e) {
      Thread.interrupted();
    }
catch (    ExecutionException e) {
      fail(e.getMessage());
    }
  }
);
}
  finally {
  t.join();
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.remove(_lock);
  }
);
}

====================================================
HiLoSequenceMismatchStrategyTest.java at Line:66 col: 2
try (Connection connection=connectionProvider.getConnection();Statement statement=connection.createStatement()){
  for (  String dropSequenceStatement : dropSequenceStatements) {
    try {
      statement.execute(dropSequenceStatement);
    }
 catch (    SQLException e) {
    }
  }
  for (  String createSequenceStatement : createSequenceStatements) {
    statement.execute(createSequenceStatement);
  }
}
 catch (SQLException e) {
  fail(e.getMessage());
}

====================================================
CaseStatementTest.java at Line:72 col: 2
try (final SessionImplementor s=(SessionImplementor)openSession()){
  inTransaction(s,session -> {
    try {
      s.createQuery("select case p.name when 'Steve' then :opt1 else :opt2 end from Person p").setString("opt1","x").setString("opt2","y").list();
      fail("was expecting an exception");
    }
 catch (    IllegalArgumentException e) {
      assertTyping(QueryException.class,e.getCause());
    }
catch (    QueryException expected) {
    }
  }
);
  inTransaction(s,session -> {
    s.createQuery("select case p.name when 'Steve' then cast( :opt1 as string ) else cast( :opt2 as string) end from Person p").setString("opt1","x").setString("opt2","y").list();
  }
);
  inTransaction(s,session -> {
    try {
      s.createQuery("select case p.name when 'Steve' then :opt1 else :opt2 end from Person p").setString("opt1","x").setString("opt2","y").list();
      fail("was expecting an exception");
    }
 catch (    IllegalArgumentException e) {
      assertTyping(QueryException.class,e.getCause());
    }
catch (    QueryException expected) {
    }
  }
);
}
 
====================================================
TransactionUtil.java at Line:294 col: 2
try {
  session=factorySupplier.get().openSession();
  function.beforeTransactionCompletion();
  txn=session.beginTransaction();
  result=function.apply(session);
  if (!txn.getRollbackOnly()) {
    txn.commit();
  }
 else {
    try {
      txn.rollback();
    }
 catch (    Exception e) {
      log.error("Rollback failure",e);
    }
  }
}
 catch (Throwable t) {
  if (txn != null && txn.isActive()) {
    try {
      txn.rollback();
    }
 catch (    Exception e) {
      log.error("Rollback failure",e);
    }
  }
  throw t;
}
 finally {
  function.afterTransactionCompletion();
  if (session != null) {
    session.close();
  }
}

====================================================
DdlTransactionIsolatorNonJtaImpl.java at Line:45 col: 4
try {
  if (!jdbcConnection.getAutoCommit()) {
    ConnectionAccessLogger.INSTANCE.informConnectionLocalTransactionForNonJtaDdl(jdbcContext.getJdbcConnectionAccess());
    try {
      jdbcConnection.commit();
      jdbcConnection.setAutoCommit(true);
    }
 catch (    SQLException e) {
      throw jdbcContext.getSqlExceptionHelper().convert(e,"Unable to set JDBC Connection into auto-commit mode in preparation for DDL execution");
    }
  }
}
 catch (SQLException e) {
  throw jdbcContext.getSqlExceptionHelper().convert(e,"Unable to check JDBC Connection auto-commit in preparation for DDL execution");
}

====================================================
SequenceInformationMariaDBTest.java at Line:127 col: 2
try (Connection connection=connectionProvider.getConnection();Statement statement=connection.createStatement()){
  try {
    statement.execute("DROP SEQUENCE book_sequence");
    statement.execute("DROP SEQUENCE author_sequence");
  }
 catch (  SQLException e) {
  }
  try {
    statement.execute("DROP TABLE TBL_BOOK");
    statement.execute("DROP TABLE TBL_AUTHOR");
  }
 catch (  SQLException e) {
  }
}
 catch (SQLException e) {
  fail(e.getMessage());
}

====================================================
JpaTckUsageTest.java at Line:304 col: 2
try {
  conn=connectionAccess.obtainConnection();
  conn.setAutoCommit(false);
  try {
    Statement statement=conn.createStatement();
    try {
      dropProcedures(statement);
    }
 catch (    SQLException ignore) {
    }
    createProcedureFindOneUser(statement);
    createProcedureDeleteAllUsers(statement);
    try {
      statement.close();
    }
 catch (    SQLException ignore) {
    }
  }
  finally {
    try {
      conn.commit();
    }
 catch (    SQLException e) {
      System.out.println("Unable to commit transaction after creating creating procedures");
    }
    try {
      connectionAccess.releaseConnection(conn);
    }
 catch (    SQLException ignore) {
    }
  }
}
 catch (SQLException e) {
  throw new RuntimeException("Unable to create stored procedures",e);
}

====================================================
UpdateEntitiesWithPackageNamesStartingWithKeywordsTest.java at Line:84 col: 2
try (Session session=openSession()){
  session.getTransaction().begin();
  try {
    session.save(entity);
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().getStatus() == TransactionStatus.ACTIVE) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
JpaTckUsageTest.java at Line:419 col: 2
try {
  conn=connectionAccess.obtainConnection();
  conn.setAutoCommit(false);
  try {
    Statement statement=conn.createStatement();
    dropProcedures(statement);
    try {
      statement.close();
    }
 catch (    SQLException ignore) {
    }
  }
  finally {
    try {
      conn.commit();
    }
 catch (    SQLException e) {
      System.out.println("Unable to commit transaction after creating dropping procedures");
    }
    try {
      connectionAccess.releaseConnection(conn);
    }
 catch (    SQLException ignore) {
    }
  }
}
 catch (SQLException e) {
  throw new RuntimeException("Unable to drop stored procedures",e);
}

====================================================
QueryTest.java at Line:1177 col: 2
try {
  Wallet w=new Wallet();
  w.setBrand("Lacoste");
  w.setModel("Minimic");
  w.setSerial("0100202002");
  em.persist(w);
  em.flush();
  Query jpaQuery=em.createQuery("select w from Wallet w");
  try {
    Parameter<?> parameter=jpaQuery.getParameter("brand");
    fail("Should fail due to user error in parameters");
  }
 catch (  Exception e) {
    assertTyping(IllegalArgumentException.class,e);
  }
  jpaQuery=em.createQuery("select w from Wallet w");
  try {
    Parameter<String> parameter=jpaQuery.getParameter("brand",String.class);
    fail("Should fail due to user error in parameters");
  }
 catch (  Exception e) {
    assertTyping(IllegalArgumentException.class,e);
  }
}
  finally {
  if (em.getTransaction() != null && em.getTransaction().isActive()) {
    em.getTransaction().rollback();
  }
  em.close();
}

====================================================
SecuredBindingTest.java at Line:43 col: 2
try {
  serviceRegistry=ServiceRegistryBuilder.buildServiceRegistry(p);
  sf=ac.buildSessionFactory(serviceRegistry);
  try {
    sf.close();
  }
 catch (  Exception ignore) {
  }
  Assert.fail("Driver property overriding should work");
}
 catch (HibernateException he) {
}
 finally {
  if (sf != null) {
    sf.close();
  }
  if (serviceRegistry != null) {
    ServiceRegistryBuilder.destroy(serviceRegistry);
  }
}

====================================================
LockExceptionTests.java at Line:100 col: 2
try {
  inTransaction(session -> {
    session.find(Item.class,item.getId(),LockModeType.PESSIMISTIC_WRITE);
    TransactionUtil2.inTransaction(sessionFactory(),secondSession -> {
      try {
        Item item2=secondSession.get(Item.class,item.getId());
        secondSession.refresh(item2,LockModeType.PESSIMISTIC_WRITE,Collections.singletonMap(AvailableSettings.JPA_LOCK_TIMEOUT,LockOptions.NO_WAIT));
        fail("Expecting a failure");
      }
 catch (      LockTimeoutException|PessimisticLockException expected) {
      }
    }
);
  }
);
}
  finally {
  inTransaction(session -> session.createQuery("delete Item").executeUpdate());
}

====================================================
DefaultSchemaNameResolver.java at Line:42 col: 2
try {
  final Class<? extends Connection> jdbcConnectionClass=connection.getClass();
  final Method getSchemaMethod=jdbcConnectionClass.getMethod("getSchema");
  if (getSchemaMethod != null && getSchemaMethod.getReturnType().equals(String.class)) {
    try {
      connection.getSchema();
      return new SchemaNameResolverJava17Delegate();
    }
 catch (    java.lang.AbstractMethodError e) {
      log.debugf("Unable to use Java 1.7 Connection#getSchema");
      return SchemaNameResolverFallbackDelegate.INSTANCE;
    }
  }
 else {
    log.debugf("Unable to use Java 1.7 Connection#getSchema");
    return SchemaNameResolverFallbackDelegate.INSTANCE;
  }
}
 catch (Exception ignore) {
  log.debugf("Unable to use Java 1.7 Connection#getSchema : An error occurred trying to resolve the connection default schema resolver: " + ignore.getMessage());
  return SchemaNameResolverFallbackDelegate.INSTANCE;
}

====================================================
BatchOptimisticLockingTest.java at Line:69 col: 2
try {
  doInHibernate(this::sessionFactory,session -> {
    List<Person> persons=session.createQuery("select p from Person p").getResultList();
    for (int i=0; i < persons.size(); i++) {
      Person person=persons.get(i);
      person.name+=" Person";
      if (i == 1) {
        try {
          executorService.submit(() -> {
            doInHibernate(this::sessionFactory,_session -> {
              Person _person=_session.find(Person.class,person.id);
              _person.name+=" Person is the new Boss!";
            }
);
          }
).get();
        }
 catch (        InterruptedException|ExecutionException e) {
          fail(e.getMessage());
        }
      }
    }
  }
);
}
 catch (Exception expected) {
  assertEquals(OptimisticLockException.class,expected.getClass());
}

====================================================
Helper.java at Line:41 col: 2
try {
  PreparedStatement ps=null;
  try {
    ps=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(sql,false);
    bindSessionIdentifier(ps,session,1);
    session.getJdbcCoordinator().getResultSetReturn().executeUpdate(ps);
  }
  finally {
    if (ps != null) {
      try {
        session.getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(ps);
      }
 catch (      Throwable ignore) {
      }
    }
  }
}
 catch (SQLException e) {
  throw session.getJdbcServices().getSqlExceptionHelper().convert(e,"Unable to clean up id table [" + tableName + "]",sql);
}

====================================================
ASTParserLoadingTest.java at Line:1658 col: 2
try (final SessionImplementor s=(SessionImplementor)openSession()){
  inTransaction(s,session -> {
    try {
      s.createQuery("from Human h join fetch h.friends f join fetch f.friends fof").list();
      fail("failure expected");
    }
 catch (    IllegalArgumentException e) {
      assertTyping(MultipleBagFetchException.class,e.getCause());
    }
catch (    HibernateException e) {
      assertTrue("unexpected failure reason : " + e,e.getMessage().indexOf("multiple bags") > 0);
    }
  }
);
}
 
====================================================
PersistenceXmlParser.java at Line:436 col: 2
try {
  URLConnection conn=xmlUrl.openConnection();
  conn.setUseCaches(false);
  try {
    try (InputStream inputStream=conn.getInputStream()){
      final InputSource inputSource=new InputSource(inputStream);
      try {
        DocumentBuilder documentBuilder=documentBuilderFactory().newDocumentBuilder();
        try {
          Document document=documentBuilder.parse(inputSource);
          validate(document);
          return document;
        }
 catch (        SAXException|IOException e) {
          throw new PersistenceException("Unexpected error parsing [" + resourceName + "]",e);
        }
      }
 catch (      ParserConfigurationException e) {
        throw new PersistenceException("Unable to generate javax.xml.parsers.DocumentBuilder instance",e);
      }
    }
   }
 catch (  IOException e) {
    throw new PersistenceException("Unable to obtain input stream from [" + resourceName + "]",e);
  }
}
 catch (IOException e) {
  throw new PersistenceException("Unable to access [" + resourceName + "]",e);
}

====================================================
StoredProcedureNullParameterByNameTest.java at Line:114 col: 3
try {
  Statement statement=conn.createStatement();
  statement.execute(storedProc);
  try {
    statement.close();
  }
 catch (  SQLException ignore) {
    fail();
  }
}
  finally {
  try {
    conn.commit();
  }
 catch (  SQLException e) {
    System.out.println("Unable to commit transaction after creating creating procedures");
    fail();
  }
  try {
    connectionAccess.releaseConnection(conn);
  }
 catch (  SQLException ignore) {
    fail();
  }
}

====================================================
BasicJdbcTransactionTests.java at Line:83 col: 2
try (final SessionFactoryImplementor sf=generateSessionFactory()){
  inSession(sf,session -> {
    final TransactionCoordinator coordinator=session.getTransactionCoordinator();
    assertEquals(TransactionStatus.NOT_ACTIVE,coordinator.getTransactionDriverControl().getStatus());
    session.getTransaction().begin();
    assertEquals(TransactionStatus.ACTIVE,coordinator.getTransactionDriverControl().getStatus());
    session.getTransaction().markRollbackOnly();
    assertEquals(TransactionStatus.MARKED_ROLLBACK,coordinator.getTransactionDriverControl().getStatus());
    try {
      session.getTransaction().commit();
    }
 catch (    TransactionException expected) {
    }
 finally {
      assertThat(coordinator.getTransactionDriverControl().getStatus(),anyOf(is(TransactionStatus.NOT_ACTIVE),is(TransactionStatus.ROLLED_BACK)));
    }
  }
);
}
 
====================================================
TransactionUtil.java at Line:633 col: 2
try {
  try (Connection connection=ssr.getService(JdbcServices.class).getBootstrapJdbcConnectionAccess().obtainConnection();Statement statement=connection.createStatement()){
    connection.setAutoCommit(true);
    consumer.accept(statement);
  }
 catch (  SQLException e) {
    log.debug(e.getMessage());
  }
}
  finally {
  StandardServiceRegistryBuilder.destroy(ssr);
}

====================================================
NamedQueryTransactionFailureTest.java at Line:103 col: 2
try {
  doInJPA(this::entityManagerFactory,entityManager -> {
    try {
      Mockito.reset(transactionCoordinator);
      doNothing().doThrow(IllegalStateException.class).when(transactionCoordinator).pulse();
      entityManager.createNamedQuery("NamedQuery");
    }
 catch (    Exception e) {
      assertEquals(IllegalArgumentException.class,e.getClass());
      assertEquals(IllegalStateException.class,e.getCause().getClass());
    }
  }
);
}
 catch (Exception ignore) {
}

====================================================
JdbcCoordinatorImpl.java at Line:379 col: 2
try {
  try {
    if (statement.getMaxRows() != 0) {
      statement.setMaxRows(0);
    }
    if (statement.getQueryTimeout() != 0) {
      statement.setQueryTimeout(0);
    }
  }
 catch (  SQLException sqle) {
    if (LOG.isDebugEnabled()) {
      LOG.debugf("Exception clearing maxRows/queryTimeout [%s]",sqle.getMessage());
    }
    return;
  }
  statement.close();
  if (lastQuery == statement) {
    lastQuery=null;
  }
}
 catch (SQLException e) {
  LOG.debugf("Unable to release JDBC statement [%s]",e.getMessage());
}
catch (Exception e) {
  LOG.debugf("Unable to release JDBC statement [%s]",e.getMessage());
}

====================================================
HANAStoredProcedureTest.java at Line:309 col: 2
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (Statement statement=connection.createStatement()){
      statement.executeUpdate("DROP PROCEDURE outAndRefCursor");
    }
 catch (    SQLException ignore) {
    }
  }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
CdiBeanContainerBuilder.java at Line:68 col: 2
try {
  final Constructor<? extends BeanContainer> ctor=containerClass.getDeclaredConstructor(ctorArgType);
  try {
    ReflectHelper.ensureAccessibility(ctor);
    return ctor.newInstance(ctorArgType.cast(beanManagerRef));
  }
 catch (  InvocationTargetException e) {
    throw new HibernateException("Problem building " + containerClass.getName(),e.getCause());
  }
catch (  Exception e) {
    throw new HibernateException("Problem building " + containerClass.getName(),e);
  }
}
 catch (NoSuchMethodException e) {
  throw new HibernateException(String.format(Locale.ENGLISH,"Could not locate proper %s constructor",containerClass.getName()),e);
}

====================================================
StoreProcedureOutParameterByPositionTest.java at Line:135 col: 2
try {
  conn=connectionAccess.obtainConnection();
  conn.setAutoCommit(false);
  try {
    Statement statement=conn.createStatement();
    statement.execute(storedProc);
    try {
      statement.close();
    }
 catch (    SQLException ignore) {
      fail();
    }
  }
  finally {
    try {
      conn.commit();
    }
 catch (    SQLException e) {
      System.out.println("Unable to commit transaction after creating creating procedures");
      fail();
    }
    try {
      connectionAccess.releaseConnection(conn);
    }
 catch (    SQLException ignore) {
      fail();
    }
  }
}
 catch (SQLException e) {
  throw new RuntimeException("Unable to create stored procedures",e);
}

====================================================
MySQLStoredProcedureTest.java at Line:181 col: 2
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (Statement statement=connection.createStatement()){
      statement.executeUpdate("DROP PROCEDURE IF EXISTS sp_phones");
    }
 catch (    SQLException ignore) {
    }
  }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
PersistentAttributesEnhancer.java at Line:163 col: 2
try {
  boolean declared=persistentField.getDeclaringClass().equals(managedCtClass);
  String declaredReadFragment="this." + fieldName;
  String superReadFragment="super." + readerName + "()";
  if (!declared) {
    try {
      persistentField.getDeclaringClass().getDeclaredMethod(readerName);
      persistentField.getDeclaringClass().getDeclaredMethod(writerName);
    }
 catch (    NotFoundException nfe) {
      tmpSuperReader=MethodWriter.addGetter(persistentField.getDeclaringClass(),persistentField.getName(),readerName);
      tmpSuperWriter=MethodWriter.addSetter(persistentField.getDeclaringClass(),persistentField.getName(),writerName);
    }
  }
  if (!enhancementContext.hasLazyLoadableAttributes(managedCtClass) || !enhancementContext.isLazyLoadable(persistentField)) {
    reader=MethodWriter.write(managedCtClass,"public %s %s() {  return %s;%n}",persistentField.getType().getName(),readerName,declared ? declaredReadFragment : superReadFragment);
  }
 else {
    reader=MethodWriter.write(managedCtClass,"public %s %s() {%n%s%n  return %s;%n}",persistentField.getType().getName(),readerName,typeDescriptor.buildReadInterceptionBodyFragment(fieldName),declared ? declaredReadFragment : superReadFragment);
  }
  if (tmpSuperReader != null) {
    persistentField.getDeclaringClass().removeMethod(tmpSuperReader);
  }
  if (tmpSuperWriter != null) {
    persistentField.getDeclaringClass().removeMethod(tmpSuperWriter);
  }
  return reader;
}
 catch (CannotCompileException cce) {
  final String msg=String.format("Could not enhance entity class [%s] to add field reader method [%s]",managedCtClass.getName(),readerName);
  throw new EnhancementException(msg,cce);
}
catch (NotFoundException nfe) {
  final String msg=String.format("Could not enhance entity class [%s] to add field reader method [%s]",managedCtClass.getName(),readerName);
  throw new EnhancementException(msg,nfe);
}

====================================================
StoreProcedureRefCursorOutParameterByPositionTest.java at Line:76 col: 2
try {
  conn=connectionAccess.obtainConnection();
  conn.setAutoCommit(false);
  try {
    Statement statement=conn.createStatement();
    statement.execute("CREATE OR REPLACE PROCEDURE PROC_EXAMPLE ( " + "  USER_NAME_PARAM IN VARCHAR2, CURSOR_PARAM OUT SYS_REFCURSOR ) " + "AS "+ "BEGIN "+ "  OPEN CURSOR_PARAM FOR "+ "  SELECT * FROM USERS WHERE NAME = USER_NAME_PARAM; "+ "END PROC_EXAMPLE; ");
    try {
      statement.close();
    }
 catch (    SQLException ignore) {
      fail();
    }
  }
  finally {
    try {
      conn.commit();
    }
 catch (    SQLException e) {
      System.out.println("Unable to commit transaction after creating creating procedures");
      fail();
    }
    try {
      connectionAccess.releaseConnection(conn);
    }
 catch (    SQLException ignore) {
      fail();
    }
  }
}
 catch (SQLException e) {
  throw new RuntimeException("Unable to create stored procedures",e);
}

====================================================
SchemaToolTransactionHandlingTest.java at Line:159 col: 2
try {
  final SchemaManagementTool smt=registry.getService(SchemaManagementTool.class);
  final Metadata mappings=buildMappings(registry);
  try {
    smt.getSchemaCreator(Collections.emptyMap()).doCreation(mappings,ExecutionOptionsTestImpl.INSTANCE,SourceDescriptorImpl.INSTANCE,TargetDescriptorImpl.INSTANCE);
  }
 catch (  Exception e) {
    throw new RuntimeException("Unable to create schema to validation tests",e);
  }
  try {
    smt.getSchemaValidator(Collections.emptyMap()).doValidation(mappings,ExecutionOptionsTestImpl.INSTANCE);
  }
  finally {
    try {
      smt.getSchemaDropper(Collections.emptyMap()).doDrop(mappings,ExecutionOptionsTestImpl.INSTANCE,SourceDescriptorImpl.INSTANCE,TargetDescriptorImpl.INSTANCE);
    }
 catch (    Exception ignore) {
    }
  }
}
  finally {
  try {
    jtaTransaction.commit();
    ((StandardServiceRegistryImpl)registry).destroy();
  }
 catch (  Exception e) {
  }
}

====================================================
TransactionUtil.java at Line:519 col: 2
try {
  session=sessionBuilderSupplier.get().openSession();
  function.beforeTransactionCompletion();
  txn=session.beginTransaction();
  function.accept(session);
  if (!txn.getRollbackOnly()) {
    txn.commit();
  }
 else {
    try {
      txn.rollback();
    }
 catch (    Exception e) {
      log.error("Rollback failure",e);
    }
  }
}
 catch (Throwable t) {
  if (txn != null && txn.isActive()) {
    try {
      txn.rollback();
    }
 catch (    Exception e) {
      log.error("Rollback failure",e);
    }
  }
  throw t;
}
 finally {
  function.afterTransactionCompletion();
  if (session != null) {
    session.close();
  }
}

====================================================
LocalXsdResolver.java at Line:91 col: 2
try {
  InputStream schemaStream=url.openStream();
  try {
    StreamSource source=new StreamSource(url.openStream());
    SchemaFactory schemaFactory=SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
    return schemaFactory.newSchema(source);
  }
 catch (  SAXException|IOException e) {
    throw new XsdException("Unable to load schema [" + schemaResourceName + "]",e,schemaResourceName);
  }
 finally {
    try {
      schemaStream.close();
    }
 catch (    IOException e) {
      Logger.getLogger(LocalXsdResolver.class).debugf("Problem closing schema stream [%s]",e.toString());
    }
  }
}
 catch (IOException e) {
  throw new XsdException("Stream error handling schema url [" + url.toExternalForm() + "]",schemaResourceName);
}

====================================================
TypeFactorySerializationTest.java at Line:36 col: 2
try {
  assertSame(factory,SessionFactoryRegistry.INSTANCE.getNamedSessionFactory(NAME));
  TypeFactory typeFactory=factory.getTypeResolver().getTypeFactory();
  byte[] typeFactoryBytes=SerializationHelper.serialize(typeFactory);
  factory.close();
  try {
    typeFactory=(TypeFactory)SerializationHelper.deserialize(typeFactoryBytes);
    fail();
  }
 catch (  HibernateException expected) {
  }
}
  finally {
  if (factory != null && factory.isOpen()) {
    factory.close();
  }
}

====================================================
MariaDBExtractSequenceMatadataTest.java at Line:60 col: 2
try (Connection conn=getConnection()){
  try (Statement stmt=conn.createStatement()){
    stmt.execute("DROP DATABASE IF EXISTS " + secondaryDbName);
  }
 catch (  Exception e) {
  }
  try (Statement stmt=conn.createStatement()){
    stmt.execute("DROP SEQUENCE IF EXISTS " + primarySequenceName);
  }
 catch (  Exception e) {
  }
}
 
====================================================
JdbcConnectionAccessConnectionProviderImpl.java at Line:42 col: 2
try {
  wasInitiallyAutoCommit=jdbcConnection.getAutoCommit();
  if (!wasInitiallyAutoCommit) {
    try {
      jdbcConnection.setAutoCommit(true);
    }
 catch (    SQLException e) {
      throw new PersistenceException(String.format("Could not set provided connection [%s] to auto-commit mode" + " (needed for schema generation)",jdbcConnection),e);
    }
  }
}
 catch (SQLException ignore) {
  wasInitiallyAutoCommit=false;
}

====================================================
Environment.java at Line:180 col: 2
try {
  InputStream stream=ConfigHelper.getResourceAsStream("/hibernate.properties");
  try {
    GLOBAL_PROPERTIES.load(stream);
    LOG.propertiesLoaded(ConfigurationHelper.maskOut(GLOBAL_PROPERTIES,PASS));
  }
 catch (  Exception e) {
    LOG.unableToLoadProperties();
  }
 finally {
    try {
      stream.close();
    }
 catch (    IOException ioe) {
      LOG.unableToCloseStreamError(ioe);
    }
  }
}
 catch (HibernateException he) {
  LOG.propertiesNotFound();
}

====================================================
CascadeTest.java at Line:127 col: 2
try {
  Session s=openSession();
  s.beginTransaction();
  Parent p=new Parent("parent");
  ParentInfo info=new ParentInfo("xyz");
  p.setInfo(info);
  info.setOwner(p);
  s.persist(p);
  try {
    s.getTransaction().commit();
    fail("expecting TransientObjectException on flush");
  }
 catch (  TransientObjectException e) {
    log.trace("handled expected exception",e);
    s.getTransaction().rollback();
  }
 finally {
    s.close();
  }
}
  finally {
  cleanupData();
}

====================================================
OracleStoredProcedureTest.java at Line:275 col: 8
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (Statement statement=connection.createStatement()){
      statement.executeUpdate("DROP PROCEDURE sp_person_phones");
    }
 catch (    SQLException ignore) {
    }
  }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
StoreProcedureRefCursorOutParameterByPositionTest.java at Line:80 col: 3
try {
  Statement statement=conn.createStatement();
  statement.execute("CREATE OR REPLACE PROCEDURE PROC_EXAMPLE ( " + "  USER_NAME_PARAM IN VARCHAR2, CURSOR_PARAM OUT SYS_REFCURSOR ) " + "AS "+ "BEGIN "+ "  OPEN CURSOR_PARAM FOR "+ "  SELECT * FROM USERS WHERE NAME = USER_NAME_PARAM; "+ "END PROC_EXAMPLE; ");
  try {
    statement.close();
  }
 catch (  SQLException ignore) {
    fail();
  }
}
  finally {
  try {
    conn.commit();
  }
 catch (  SQLException e) {
    System.out.println("Unable to commit transaction after creating creating procedures");
    fail();
  }
  try {
    connectionAccess.releaseConnection(conn);
  }
 catch (  SQLException ignore) {
    fail();
  }
}

====================================================
CascadeTest.java at Line:260 col: 2
try {
  Session s=openSession();
  s.beginTransaction();
  ChildAssigned c2=new ChildAssigned(new Long(3),"c3");
  ChildInfoAssigned info=new ChildInfoAssigned(new Long(4),"blah blah blah");
  c2.setInfo(info);
  info.setOwner(c2);
  s.persist(c2);
  try {
    s.getTransaction().commit();
    fail("expecting TransientObjectException on flush");
  }
 catch (  TransientObjectException e) {
    log.trace("handled expected exception : " + e);
    s.getTransaction().rollback();
  }
 finally {
    s.close();
  }
}
  finally {
  cleanupData();
}

====================================================
HiloOptimizerConcurrencyTest.java at Line:72 col: 2
try {
  final Session session1=openSession();
  try {
    session1.beginTransaction();
    HibPerson p=new HibPerson();
    session1.save(p);
  }
  finally {
    session1.getTransaction().commit();
  }
  createSchema=false;
  buildResources();
  final Session session2=openSession();
  try {
    session2.beginTransaction();
    HibPerson p=new HibPerson();
    session2.save(p);
  }
  finally {
    session2.getTransaction().commit();
  }
  final List<Throwable> errs=new CopyOnWriteArrayList<>();
  CountDownLatch firstLatch=new CountDownLatch(1);
  CountDownLatch secondLatch=new CountDownLatch(1);
  Callable<Void> callable1=() -> {
    try {
      for (int i=2; i < 6; i++) {
        try {
          session1.beginTransaction();
          HibPerson p=new HibPerson();
          session1.save(p);
        }
  finally {
          session1.getTransaction().commit();
        }
      }
      firstLatch.countDown();
      secondLatch.await();
      try {
        session1.beginTransaction();
        HibPerson p=new HibPerson();
        session1.save(p);
      }
  finally {
        session1.getTransaction().commit();
      }
    }
 catch (    Throwable t) {
      errs.add(t);
    }
    return null;
  }
;
  Callable<Void> callable2=() -> {
    try {
      firstLatch.await();
      secondLatch.countDown();
      try {
        session2.beginTransaction();
        HibPerson p=new HibPerson();
        session2.save(p);
      }
  finally {
        session2.getTransaction().commit();
      }
    }
 catch (    Throwable t) {
      errs.add(t);
    }
    return null;
  }
;
  executor.invokeAll(Arrays.asList(callable1,callable2),30,TimeUnit.SECONDS).forEach(c -> {
    try {
      c.get();
    }
 catch (    InterruptedException|ExecutionException e) {
      Thread.interrupted();
      fail(e.getMessage());
    }
  }
);
  for (  Throwable ex : errs) {
    fail(ex.getMessage());
  }
}
 catch (InterruptedException e) {
  fail(e.getMessage());
}
 finally {
  releaseResources(serviceRegistry,sessionFactory);
}

====================================================
InterceptorTest.java at Line:254 col: 2
try {
  doInJPA(this::entityManagerFactory,entityManager -> {
    entityManager.persist(i);
    entityManager.persist(i);
    entityManager.flush();
    entityManager.clear();
    try {
      entityManager.find(Item.class,i.getName());
      fail("No interceptor");
    }
 catch (    IllegalStateException e) {
      assertEquals(ExceptionInterceptor.EXCEPTION_MESSAGE,e.getMessage());
    }
  }
);
}
 catch (IllegalStateException e) {
  assertEquals(LocalExceptionInterceptor.LOCAL_EXCEPTION_MESSAGE,e.getMessage());
}

====================================================
ScrollableTest.java at Line:41 col: 2
try (Session session=openSession()){
  session.getTransaction().begin();
  try {
    session.save(new MyEntity(1L,"entity_1"));
    session.save(new MyEntity(2L,"entity_2"));
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().isActive()) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
PostgreSQLMultipleSchemaSequenceTest.java at Line:73 col: 3
try {
  new SchemaExport().setOutputFile(output.getAbsolutePath()).create(EnumSet.of(TargetType.DATABASE,TargetType.SCRIPT),metadata1);
  final ConnectionProvider connectionProvider1=ssr1.getService(ConnectionProvider.class);
  DdlTransactionIsolatorTestingImpl ddlTransactionIsolator1=new DdlTransactionIsolatorTestingImpl(ssr1,new JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess(connectionProvider1));
  try (Statement statement=ddlTransactionIsolator1.getIsolatedConnection().createStatement()){
    statement.execute(String.format("DROP SCHEMA IF EXISTS %s CASCADE",extraSchemaName));
    statement.execute(String.format("CREATE SCHEMA %s",extraSchemaName));
    try (ResultSet resultSet=statement.executeQuery("SELECT NEXTVAL('SEQ_TEST')")){
      while (resultSet.next()) {
        Long sequenceValue=resultSet.getLong(1);
        assertEquals(Long.valueOf(1L),sequenceValue);
      }
    }
   }
 catch (  SQLException e) {
    fail(e.getMessage());
  }
  StandardServiceRegistry ssr2=new StandardServiceRegistryBuilder().applySetting(AvailableSettings.URL,Environment.getProperties().get(AvailableSettings.URL) + "?currentSchema=" + extraSchemaName).build();
  try {
    final MetadataImplementor metadata2=(MetadataImplementor)new MetadataSources(ssr2).addAnnotatedClass(Box.class).buildMetadata();
    try {
      new SchemaExport().setOutputFile(output.getAbsolutePath()).create(EnumSet.of(TargetType.DATABASE,TargetType.SCRIPT),metadata2);
    }
  finally {
      final ConnectionProvider connectionProvider2=ssr2.getService(ConnectionProvider.class);
      DdlTransactionIsolatorTestingImpl ddlTransactionIsolator2=new DdlTransactionIsolatorTestingImpl(ssr2,new JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess(connectionProvider2));
      try (Statement statement=ddlTransactionIsolator2.getIsolatedConnection().createStatement()){
        try (ResultSet resultSet=statement.executeQuery("SELECT NEXTVAL('SEQ_TEST')")){
          while (resultSet.next()) {
            Long sequenceValue=resultSet.getLong(1);
            assertEquals(Long.valueOf(1L),sequenceValue);
          }
        }
         statement.execute(String.format("DROP SCHEMA IF EXISTS %s CASCADE",extraSchemaName));
      }
 catch (      SQLException e) {
        fail(e.getMessage());
      }
      new SchemaExport().drop(EnumSet.of(TargetType.DATABASE),metadata2);
    }
  }
  finally {
    StandardServiceRegistryBuilder.destroy(ssr2);
  }
}
  finally {
  new SchemaExport().drop(EnumSet.of(TargetType.DATABASE),metadata1);
}

====================================================
LockTest.java at Line:611 col: 2
try {
  lock.setName("testContendedPessimisticLock");
  doInJPA(this::entityManagerFactory,em -> {
    em.persist(lock);
  }
);
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.lock(_lock,LockModeType.PESSIMISTIC_WRITE);
    _lock.setName("foo");
    em.flush();
    log.info("testContendedPessimisticLock: got write lock");
    try {
      t.start();
      boolean backGroundThreadCompleted=latch.await(10,TimeUnit.SECONDS);
      if (backGroundThreadCompleted) {
        assertFalse("The background thread is not allowed to see the updated value while the first transaction has not committed yet",backgroundThreadHasReadNewValue.get());
      }
 else {
        log.debug("The background thread was blocked");
        assertTrue("Background thread should read the new value after being unblocked",backgroundThreadHasReadNewValue.get());
      }
    }
 catch (    InterruptedException e) {
      Thread.interrupted();
    }
  }
);
}
  finally {
  t.join();
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.remove(_lock);
  }
);
}

====================================================
JtaIsolationDelegate.java at Line:139 col: 2
try {
  transactionManager.begin();
  try {
    T result=callable.call();
    transactionManager.commit();
    return result;
  }
 catch (  Exception e) {
    try {
      transactionManager.rollback();
    }
 catch (    Exception ignore) {
      LOG.unableToRollbackIsolatedTransaction(e,ignore);
    }
    throw new HibernateException("Could not apply work",e);
  }
}
 catch (SystemException e) {
  throw new HibernateException("Unable to start isolated transaction",e);
}
catch (NotSupportedException e) {
  throw new HibernateException("Unable to start isolated transaction",e);
}

====================================================
StoreProcedureRefCursorOutParameterByNameTest.java at Line:80 col: 3
try {
  Statement statement=conn.createStatement();
  statement.execute("CREATE OR REPLACE PROCEDURE PROC_EXAMPLE ( " + "  USER_NAME_PARAM IN VARCHAR2, CURSOR_PARAM OUT SYS_REFCURSOR ) " + "AS "+ "BEGIN "+ "  OPEN CURSOR_PARAM FOR "+ "  SELECT * FROM USERS WHERE NAME = USER_NAME_PARAM; "+ "END PROC_EXAMPLE; ");
  try {
    statement.close();
  }
 catch (  SQLException ignore) {
    fail();
  }
}
  finally {
  try {
    conn.commit();
  }
 catch (  SQLException e) {
    System.out.println("Unable to commit transaction after creating creating procedures");
    fail();
  }
  try {
    connectionAccess.releaseConnection(conn);
  }
 catch (  SQLException ignore) {
    fail();
  }
}

====================================================
SchemaUpdateSchemaNameTest.java at Line:108 col: 2
try {
  final Configuration cfg=buildConfiguration(SimpleNext.class);
  ssr=new StandardServiceRegistryBuilder(new BootstrapServiceRegistryBuilder().build(),cfg.getStandardServiceRegistryBuilder().getAggregatedCfgXml()).applySettings(cfg.getProperties()).build();
  SessionFactory sf=cfg.buildSessionFactory(ssr);
  try {
    Session session=sf.openSession();
    try {
      session.getTransaction().begin();
      session.createQuery("FROM Simple",SimpleNext.class).getResultList();
      session.getTransaction().commit();
    }
 catch (    Throwable t) {
      if (session.getTransaction().isActive()) {
        session.getTransaction().rollback();
      }
      throw t;
    }
 finally {
      session.close();
    }
  }
  finally {
    sf.close();
  }
}
  finally {
  StandardServiceRegistryBuilder.destroy(ssr);
}

====================================================
IdTableHelper.java at Line:120 col: 2
try {
  Connection connection=connectionAccess.obtainConnection();
  try {
    Statement statement=connection.createStatement();
    for (    String dropStatement : dropStatements) {
      try {
        jdbcServices.getSqlStatementLogger().logStatement(dropStatement);
        statement.execute(dropStatement);
      }
 catch (      SQLException e) {
        log.debugf("Error attempting to cleanup id-table : [%s]",e.getMessage());
      }
    }
    statement.close();
  }
 catch (  SQLException e) {
    log.error("Unable to use JDBC Connection to create Statement",e);
  }
 finally {
    try {
      connectionAccess.releaseConnection(connection);
    }
 catch (    SQLException ignore) {
    }
  }
}
 catch (SQLException e) {
  log.error("Unable obtain JDBC Connection",e);
}

====================================================
CascadeTest.java at Line:207 col: 2
try {
  Session s=openSession();
  s.beginTransaction();
  ParentAssigned p=new ParentAssigned(new Long(1),"parent");
  OtherAssigned other=new OtherAssigned(new Long(2));
  other.setOwner(p);
  s.persist(other);
  try {
    s.getTransaction().commit();
    fail("expecting TransientObjectException on flush");
  }
 catch (  TransientObjectException e) {
    log.trace("handled expected exception",e);
    s.getTransaction().rollback();
  }
 finally {
    s.close();
  }
}
  finally {
  cleanupData();
}

====================================================
Helper.java at Line:75 col: 3
try {
  Statement statement=connection.createStatement();
  try {
    statement.executeUpdate(logStatement(factory,idTableInfo.getIdTableCreationStatement()));
    factory.getServiceRegistry().getService(JdbcServices.class).getSqlExceptionHelper().handleAndClearWarnings(statement,WARNING_HANDLER);
  }
  finally {
    try {
      statement.close();
    }
 catch (    Throwable ignore) {
    }
  }
}
 catch (Exception e) {
  log.debug("unable to create temporary id table [" + e.getMessage() + "]");
}

====================================================
PersisterFactoryImpl.java at Line:149 col: 2
try {
  Constructor<? extends CollectionPersister> constructor=persisterClass.getConstructor(COLLECTION_PERSISTER_CONSTRUCTOR_ARGS);
  try {
    return constructor.newInstance(collectionBinding,cacheAccessStrategy,creationContext);
  }
 catch (  MappingException e) {
    throw e;
  }
catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof HibernateException) {
      throw (HibernateException)target;
    }
 else {
      throw new MappingException("Could not instantiate collection persister " + persisterClass.getName(),target);
    }
  }
catch (  Exception e) {
    throw new MappingException("Could not instantiate collection persister " + persisterClass.getName(),e);
  }
}
 catch (MappingException e) {
  throw e;
}
catch (Exception e) {
  throw new MappingException("Could not get constructor for " + persisterClass.getName(),e);
}

====================================================
StoreProcedureRefCursorOutParameterByNameTest.java at Line:76 col: 2
try {
  conn=connectionAccess.obtainConnection();
  conn.setAutoCommit(false);
  try {
    Statement statement=conn.createStatement();
    statement.execute("CREATE OR REPLACE PROCEDURE PROC_EXAMPLE ( " + "  USER_NAME_PARAM IN VARCHAR2, CURSOR_PARAM OUT SYS_REFCURSOR ) " + "AS "+ "BEGIN "+ "  OPEN CURSOR_PARAM FOR "+ "  SELECT * FROM USERS WHERE NAME = USER_NAME_PARAM; "+ "END PROC_EXAMPLE; ");
    try {
      statement.close();
    }
 catch (    SQLException ignore) {
      fail();
    }
  }
  finally {
    try {
      conn.commit();
    }
 catch (    SQLException e) {
      System.out.println("Unable to commit transaction after creating creating procedures");
      fail();
    }
    try {
      connectionAccess.releaseConnection(conn);
    }
 catch (    SQLException ignore) {
      fail();
    }
  }
}
 catch (SQLException e) {
  throw new RuntimeException("Unable to create stored procedures",e);
}

====================================================
OneToOneTest.java at Line:187 col: 2
try (Session s=openSession()){
  Party party=new Party();
  PartyAffiliate affiliate=new PartyAffiliate();
  affiliate.partyId="id";
  party.partyId="id";
  party.partyAffiliate=affiliate;
  affiliate.party=party;
  s.getTransaction().begin();
  try {
    s.persist(party);
    s.getTransaction().commit();
  }
 catch (  Exception e) {
    if (s.getTransaction() != null && s.getTransaction().isActive()) {
      s.getTransaction().rollback();
    }
    throw e;
  }
  s.clear();
  Transaction tx=s.beginTransaction();
  try {
    affiliate=s.get(PartyAffiliate.class,"id");
    assertNotNull(affiliate.party);
    assertEquals(affiliate.partyId,affiliate.party.partyId);
    s.clear();
    party=s.get(Party.class,"id");
    assertNotNull(party.partyAffiliate);
    assertEquals(party.partyId,party.partyAffiliate.partyId);
    s.delete(party);
    s.delete(party.partyAffiliate);
    tx.commit();
  }
 catch (  Exception e) {
    if (s.getTransaction() != null && s.getTransaction().isActive()) {
      s.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
ConfigurationTest.java at Line:57 col: 2
try (SessionFactoryImplementor sf=(SessionFactoryImplementor)cfg.buildSessionFactory()){
  assertNotNull(sf);
  inTransaction(sf,session -> {
    try {
      session.createQuery("from Boat").list();
      fail("Boat should not be mapped");
    }
 catch (    IllegalArgumentException expected) {
      assertTyping(QuerySyntaxException.class,expected.getCause());
    }
  }
);
  inTransaction(sf,session -> {
    assertEquals(0,session.createQuery("from Plane").list().size());
  }
);
}
 
====================================================
CascadeTest.java at Line:181 col: 2
try {
  Session s=openSession();
  s.beginTransaction();
  Parent p=new Parent("parent");
  Other other=new Other();
  other.setOwner(p);
  s.persist(other);
  try {
    s.getTransaction().commit();
    fail("expecting TransientObjectException on flush");
  }
 catch (  TransientObjectException e) {
    log.trace("handled expected exception",e);
    s.getTransaction().rollback();
  }
 finally {
    s.close();
  }
}
  finally {
  cleanupData();
}

====================================================
SchemaDropperImpl.java at Line:533 col: 3
try {
  for (  String command : commands) {
    try {
      target.accept(command);
    }
 catch (    CommandAcceptanceException e) {
      log.unsuccessfulSchemaManagementCommand(command);
      log.debugf(e,"Error performing delayed DROP command [%s]",command);
    }
  }
}
  finally {
  target.release();
}

====================================================
LobCreatorBuilder.java at Line:75 col: 2
try {
  try {
    final DatabaseMetaData meta=jdbcConnection.getMetaData();
    if (meta.getJDBCMajorVersion() < 4) {
      LOG.disablingContextualLOBCreationSinceOldJdbcVersion(meta.getJDBCMajorVersion());
      return false;
    }
  }
 catch (  SQLException ignore) {
  }
  final Class connectionClass=Connection.class;
  final Method createClobMethod=connectionClass.getMethod("createClob",NO_ARG_SIG);
  if (createClobMethod.getDeclaringClass().equals(Connection.class)) {
    try {
      final Object clob=createClobMethod.invoke(jdbcConnection,NO_ARGS);
      try {
        final Method freeMethod=clob.getClass().getMethod("free",NO_ARG_SIG);
        freeMethod.invoke(clob,NO_ARGS);
      }
 catch (      Throwable ignore) {
        LOG.tracef("Unable to free CLOB created to test createClob() implementation : %s",ignore);
      }
      return true;
    }
 catch (    Throwable t) {
      LOG.disablingContextualLOBCreationSinceCreateClobFailed(t);
    }
  }
}
 catch (NoSuchMethodException ignore) {
}

====================================================
UpdateEntitiesWithPackageNamesStartingWithKeywordsTest.java at Line:49 col: 2
try (Session session=openSession()){
  session.getTransaction().begin();
  try {
    final Query query=session.createQuery("UPDATE Any set prop = :prop WHERE id = :id ");
    query.setParameter("prop","1");
    query.setParameter("id",entity.getId());
    query.executeUpdate();
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().getStatus() == TransactionStatus.ACTIVE) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
DateTimeParameterTest.java at Line:275 col: 3
try {
  Statement statement=conn.createStatement();
  dropProcedures(statement);
  try {
    statement.close();
  }
 catch (  SQLException ignore) {
  }
}
  finally {
  try {
    conn.commit();
  }
 catch (  SQLException e) {
    System.out.println("Unable to commit transaction after creating dropping procedures");
  }
  try {
    connectionAccess.releaseConnection(conn);
  }
 catch (  SQLException ignore) {
  }
}

====================================================
QueryTest.java at Line:1114 col: 2
try {
  Wallet w=new Wallet();
  w.setBrand("Lacoste");
  w.setModel("Minimic");
  w.setSerial("0100202002");
  em.persist(w);
  em.flush();
  try {
    Query jpaQuery=em.createQuery("select w from Wallet w where w.brand = ?1 and w.model = ?3");
    fail("expecting error regarding gap in positional param labels");
  }
 catch (  IllegalArgumentException e) {
    assertNotNull(e.getCause());
    assertTyping(QueryException.class,e.getCause());
    assertTrue(e.getCause().getMessage().contains("gap"));
  }
  Query jpaQuery=em.createQuery("select w from Wallet w where w.brand = ?1");
  jpaQuery.setParameter(1,"Lacoste");
  try {
    jpaQuery.setParameter(2,"Expensive");
    fail("Should fail due to a user error in parameters");
  }
 catch (  Exception e) {
    assertTyping(IllegalArgumentException.class,e);
  }
  jpaQuery=em.createQuery("select w from Wallet w ");
  try {
    Parameter parameter=jpaQuery.getParameter(1);
    fail("Should fail due to a user error in parameters");
  }
 catch (  Exception e) {
    assertTyping(IllegalArgumentException.class,e);
  }
  jpaQuery=em.createQuery("select w from Wallet w");
  try {
    Parameter<Integer> parameter=jpaQuery.getParameter(1,Integer.class);
    fail("Should fail due to user error in parameters");
  }
 catch (  Exception e) {
    assertTyping(IllegalArgumentException.class,e);
  }
}
  finally {
  if (em.getTransaction() != null && em.getTransaction().isActive()) {
    em.getTransaction().rollback();
  }
  em.close();
}

====================================================
PersistenceUtilHelper.java at Line:393 col: 2
try {
  char[] string=attributeName.toCharArray();
  string[0]=Character.toUpperCase(string[0]);
  String casedAttributeName=new String(string);
  try {
    return clazz.getDeclaredMethod("get" + casedAttributeName);
  }
 catch (  NoSuchMethodException e) {
    return clazz.getDeclaredMethod("is" + casedAttributeName);
  }
}
 catch (NoSuchMethodException e) {
  return null;
}

====================================================
SequenceStructure.java at Line:94 col: 5
try {
  final ResultSet rs=session.getJdbcCoordinator().getResultSetReturn().extract(st);
  try {
    rs.next();
    final IntegralDataTypeHolder value=IdentifierGeneratorHelper.getIntegralDataTypeHolder(numberType);
    value.initialize(rs,1);
    if (LOG.isDebugEnabled()) {
      LOG.debugf("Sequence value obtained: %s",value.makeValue());
    }
    return value;
  }
  finally {
    try {
      session.getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(rs,st);
    }
 catch (    Throwable ignore) {
    }
  }
}
  finally {
  session.getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(st);
  session.getJdbcCoordinator().afterStatementExecution();
}

====================================================
ASTParserLoadingTest.java at Line:1963 col: 2
try (final SessionImplementor s=(SessionImplementor)openSession()){
  inTransaction(s,session -> {
    try {
      s.createQuery("select mother from Human a left join fetch a.mother mother").list();
      fail("invalid fetch semantic allowed!");
    }
 catch (    IllegalArgumentException e) {
      assertTyping(QueryException.class,e.getCause());
    }
catch (    QueryException e) {
    }
  }
);
  inTransaction(s,session -> {
    try {
      s.createQuery("select mother from Human a left join fetch a.mother mother").list();
      fail("invalid fetch semantic allowed!");
    }
 catch (    IllegalArgumentException e) {
      assertTyping(QueryException.class,e.getCause());
    }
catch (    QueryException e) {
    }
  }
);
}
 
====================================================
LockExceptionTests.java at Line:141 col: 2
try {
  inTransaction(session -> {
    session.find(Item.class,item.getId(),LockModeType.PESSIMISTIC_WRITE);
    TransactionUtil2.inTransaction(sessionFactory(),secondSession -> {
      try {
        Item item2=secondSession.get(Item.class,item.getId());
        secondSession.lock(item2,LockModeType.PESSIMISTIC_WRITE,Collections.singletonMap(AvailableSettings.JPA_LOCK_TIMEOUT,LockOptions.NO_WAIT));
        fail("Expecting a failure");
      }
 catch (      LockTimeoutException|PessimisticLockException expected) {
      }
    }
);
  }
);
}
  finally {
  inTransaction(session -> session.createQuery("delete Item").executeUpdate());
}

====================================================
LockTest.java at Line:970 col: 2
try {
  lock.setName("testQueryTimeout");
  doInJPA(this::entityManagerFactory,em -> {
    em.persist(lock);
  }
);
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.lock(_lock,LockModeType.PESSIMISTIC_WRITE);
    final Integer id=_lock.getId();
    _lock.getName();
    log.info("testQueryTimeout: got write lock");
    try {
      t.start();
      boolean latchSet=latch.await(10,TimeUnit.SECONDS);
      assertTrue("background test thread finished (lock timeout is broken)",latchSet);
      assertTrue("background test thread timed out on lock attempt",bgTask.get());
    }
 catch (    InterruptedException e) {
      Thread.interrupted();
    }
catch (    ExecutionException e) {
      fail(e.getMessage());
    }
  }
);
}
  finally {
  t.join();
  doInJPA(this::entityManagerFactory,em -> {
    Lock _lock=em.getReference(Lock.class,lock.getId());
    em.remove(_lock);
  }
);
}

====================================================
ModelBinder.java at Line:2363 col: 3
try {
  final DiscriminatorType metaType=(DiscriminatorType)sourceDocument.getMetadataCollector().getTypeResolver().heuristicType(discriminatorTypeResolution.typeName);
  final HashMap anyValueBindingMap=new HashMap();
  for (  Map.Entry<String,String> discriminatorValueMappings : anyMapping.getDiscriminatorSource().getValueMappings().entrySet()) {
    try {
      final Object discriminatorValue=metaType.stringToObject(discriminatorValueMappings.getKey());
      final String mappedEntityName=sourceDocument.qualifyClassName(discriminatorValueMappings.getValue());
      anyValueBindingMap.put(discriminatorValue,mappedEntityName);
    }
 catch (    Exception e) {
      throw new MappingException(String.format(Locale.ENGLISH,"Unable to interpret <meta-value value=\"%s\" class=\"%s\"/> defined as part of <any/> attribute [%s]",discriminatorValueMappings.getKey(),discriminatorValueMappings.getValue(),attributeRole.getFullPath()),e,sourceDocument.getOrigin());
    }
  }
  anyBinding.setMetaValues(anyValueBindingMap);
}
 catch (ClassCastException e) {
  throw new MappingException(String.format(Locale.ENGLISH,"Specified meta-type [%s] for <any/> attribute [%s] did not implement DiscriminatorType",discriminatorTypeResolution.typeName,attributeRole.getFullPath()),e,sourceDocument.getOrigin());
}

====================================================
DateTimeParameterTest.java at Line:271 col: 2
try {
  conn=connectionAccess.obtainConnection();
  conn.setAutoCommit(false);
  try {
    Statement statement=conn.createStatement();
    dropProcedures(statement);
    try {
      statement.close();
    }
 catch (    SQLException ignore) {
    }
  }
  finally {
    try {
      conn.commit();
    }
 catch (    SQLException e) {
      System.out.println("Unable to commit transaction after creating dropping procedures");
    }
    try {
      connectionAccess.releaseConnection(conn);
    }
 catch (    SQLException ignore) {
    }
  }
}
 catch (SQLException e) {
  throw new RuntimeException("Unable to drop stored procedures",e);
}

====================================================
SequenceInformationMariaDBTest.java at Line:73 col: 2
try (Connection connection=connectionProvider.getConnection();Statement statement=connection.createStatement()){
  try {
    statement.execute("DROP SEQUENCE IF EXISTS book_sequence");
    statement.execute("DROP SEQUENCE IF EXISTS author_sequence");
  }
 catch (  SQLException e) {
  }
  try {
    statement.execute("DROP TABLE TBL_BOOK");
    statement.execute("DROP TABLE TBL_AUTHOR");
  }
 catch (  SQLException e) {
  }
  statement.execute("CREATE TABLE `TBL_BOOK` ( " + "  `ID` int(11) NOT NULL, " + "  `TITLE` varchar(255) DEFAULT NULL, "+ "   PRIMARY KEY (`ID`) "+ ") ENGINE=InnoDB");
  statement.execute("CREATE TABLE `TBL_AUTHOR` ( " + "  `ID` int(11) NOT NULL, " + "  `firstName` varchar(255) DEFAULT NULL, "+ "  `lastName` varchar(255) DEFAULT NULL, "+ "   PRIMARY KEY (`ID`) "+ ") ENGINE=InnoDB");
  statement.execute("CREATE SEQUENCE book_sequence " + "  START WITH 1 " + "  INCREMENT BY 1 "+ "  MAXVALUE 2999999999 "+ "  MINVALUE 0 "+ "  CACHE 10");
  statement.execute("CREATE SEQUENCE author_sequence " + "  START WITH 1 " + "  INCREMENT BY 1 "+ "  MAXVALUE 2999999999 "+ "  MINVALUE 0 "+ "  CACHE 10");
}
 catch (SQLException e) {
  fail(e.getMessage());
}

====================================================
ResourceRegistryStandardImpl.java at Line:179 col: 2
try {
  try {
    if (statement.getMaxRows() != 0) {
      statement.setMaxRows(0);
    }
    if (statement.getQueryTimeout() != 0) {
      statement.setQueryTimeout(0);
    }
  }
 catch (  SQLException sqle) {
    if (log.isDebugEnabled()) {
      log.debugf("Exception clearing maxRows/queryTimeout [%s]",sqle.getMessage());
    }
    return;
  }
  statement.close();
}
 catch (SQLException e) {
  log.debugf("Unable to release JDBC statement [%s]",e.getMessage());
}
catch (Exception e) {
  log.debugf("Unable to release JDBC statement [%s]",e.getMessage());
}

====================================================
OracleExtractSequenceMetadataTest.java at Line:97 col: 2
try (Connection conn=getConnection()){
  try (Statement stmt=conn.createStatement()){
    stmt.execute(String.format("DROP USER %s CASCADE",OTHER_SCHEMA_NAME));
  }
 catch (  Exception ignore) {
  }
}
 
====================================================
AbstractCollectionPersister.java at Line:1428 col: 2
try {
  Iterator deletes=collection.getDeletes(this,!deleteByIndex);
  if (deletes.hasNext()) {
    int offset=1;
    int count=0;
    while (deletes.hasNext()) {
      final PreparedStatement st;
      boolean callable=isDeleteCallable();
      boolean useBatch=expectation.canBeBatched();
      String sql=getSQLDeleteRowString();
      if (useBatch) {
        if (deleteBatchKey == null) {
          deleteBatchKey=new BasicBatchKey(getRole() + "#DELETE",expectation);
        }
        st=session.getJdbcCoordinator().getBatch(deleteBatchKey).getBatchStatement(sql,callable);
      }
 else {
        st=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(sql,callable);
      }
      try {
        expectation.prepare(st);
        Object entry=deletes.next();
        int loc=offset;
        if (hasIdentifier) {
          writeIdentifier(st,entry,loc,session);
        }
 else {
          loc=writeKey(st,id,loc,session);
          if (deleteByIndex) {
            writeIndexToWhere(st,entry,loc,session);
          }
 else {
            writeElementToWhere(st,entry,loc,session);
          }
        }
        if (useBatch) {
          session.getJdbcCoordinator().getBatch(deleteBatchKey).addToBatch();
        }
 else {
          expectation.verifyOutcome(session.getJdbcCoordinator().getResultSetReturn().executeUpdate(st),st,-1);
        }
        count++;
      }
 catch (      SQLException sqle) {
        if (useBatch) {
          session.getJdbcCoordinator().abortBatch();
        }
        throw sqle;
      }
 finally {
        if (!useBatch) {
          session.getJdbcCoordinator().getResourceRegistry().release(st);
          session.getJdbcCoordinator().afterStatementExecution();
        }
      }
      LOG.debugf("Done deleting collection rows: %s deleted",count);
    }
  }
 else {
    LOG.debug("No rows to delete");
  }
}
 catch (SQLException sqle) {
  throw sqlExceptionHelper.convert(sqle,"could not delete collection rows: " + MessageHelper.collectionInfoString(this,collection,id,session),getSQLDeleteRowString());
}

====================================================
CascadeTest.java at Line:72 col: 2
try {
  Session s=openSession();
  s.beginTransaction();
  Parent p=new Parent("parent");
  Child c=new Child("child");
  c.setParent(p);
  s.persist(c);
  try {
    s.getTransaction().commit();
    fail("expecting TransientObjectException on flush");
  }
 catch (  TransientObjectException e) {
    log.trace("handled expected exception",e);
    s.getTransaction().rollback();
  }
 finally {
    s.close();
  }
}
  finally {
  cleanupData();
}

====================================================
EnhancementHelper.java at Line:153 col: 2
try {
  FileOutputStream outputStream=new FileOutputStream(file,false);
  try {
    outputStream.write(enhancedBytecode);
    outputStream.flush();
  }
 catch (  IOException e) {
    throw new GradleException("Error writing to enhanced class [" + file.getName() + "] to file ["+ file.getAbsolutePath()+ "]",e);
  }
 finally {
    try {
      outputStream.close();
    }
 catch (    IOException ignore) {
    }
  }
}
 catch (FileNotFoundException e) {
  throw new GradleException("Error opening class file for writing : " + file.getAbsolutePath(),e);
}

====================================================
GeneratedValueTest.java at Line:64 col: 3
try {
  TheEntity theEntity=new TheEntity();
  Session s=sf.openSession();
  s.beginTransaction();
  s.save(theEntity);
  s.getTransaction().commit();
  s.close();
  assertNotNull(theEntity.id);
  s=sf.openSession();
  s.beginTransaction();
  try {
    s.delete(theEntity);
    s.getTransaction().commit();
  }
 catch (  Exception e) {
    s.getTransaction().rollback();
    throw e;
  }
 finally {
    s.close();
  }
}
  finally {
  try {
    sf.close();
  }
 catch (  Exception ignore) {
  }
}

====================================================
JtaIsolationDelegate.java at Line:168 col: 2
try {
  Connection connection=jdbcConnectionAccess().obtainConnection();
  try {
    return work.accept(new WorkExecutor<T>(),connection);
  }
 catch (  HibernateException e) {
    throw e;
  }
catch (  Exception e) {
    throw new HibernateException("Unable to perform isolated work",e);
  }
 finally {
    try {
      jdbcConnectionAccess().releaseConnection(connection);
    }
 catch (    Throwable ignore) {
      LOG.unableToReleaseIsolatedConnection(ignore);
    }
  }
}
 catch (SQLException e) {
  throw sqlExceptionHelper().convert(e,"unable to obtain isolated JDBC connection");
}

====================================================
JaxbCfgProcessor.java at Line:62 col: 2
try {
  XMLEventReader staxReader=staxFactory().createXMLEventReader(stream);
  try {
    return unmarshal(staxReader,origin);
  }
  finally {
    try {
      staxReader.close();
    }
 catch (    Exception ignore) {
    }
  }
}
 catch (XMLStreamException e) {
  throw new HibernateException("Unable to create stax reader",e);
}

====================================================
InformationExtractorJdbcDatabaseMetaDataImpl.java at Line:143 col: 2
try {
  final String catalogFilter=determineCatalogFilter(catalog);
  final String schemaFilter=determineSchemaFilter(schema);
  final ResultSet resultSet=extractionContext.getJdbcDatabaseMetaData().getSchemas(catalogFilter,schemaFilter);
  try {
    if (!resultSet.next()) {
      return false;
    }
    if (resultSet.next()) {
      final String catalogName=catalog == null ? "" : catalog.getCanonicalName();
      final String schemaName=schema == null ? "" : schema.getCanonicalName();
      log.debugf("Multiple schemas found with that name [%s.%s]",catalogName,schemaName);
    }
    return true;
  }
  finally {
    try {
      resultSet.close();
    }
 catch (    SQLException ignore) {
    }
  }
}
 catch (SQLException sqlException) {
  throw convertSQLException(sqlException,"Unable to query DatabaseMetaData for existing schemas");
}

====================================================
Cloneable.java at Line:68 col: 2
try {
  beanInfo=Introspector.getBeanInfo(getClass(),Object.class);
  internalCheckListeners(beanInfo);
  copy=getClass().newInstance();
  PropertyDescriptor[] pds=beanInfo.getPropertyDescriptors();
  for (  PropertyDescriptor pd : pds) {
    try {
      pd.getWriteMethod().invoke(copy,pd.getReadMethod().invoke(this,READER_METHOD_ARGS));
    }
 catch (    Throwable t) {
      throw new HibernateException("Unable copy copy listener [" + pd.getName() + "]");
    }
  }
}
 catch (Exception t) {
  throw new HibernateException("Unable to copy listeners",t);
}
 finally {
  if (beanInfo != null) {
    Introspector.flushFromCaches(getClass());
  }
}

====================================================
LockTest.java at Line:1020 col: 5
try {
  AtomicBoolean timedOut=new AtomicBoolean();
  doInJPA(this::entityManagerFactory,_entityManager -> {
    log.info("testQueryTimeout: (BG) about to read write-locked entity");
    Lock lock2=_entityManager.getReference(Lock.class,lock.getId());
    lock2.getName();
    log.info("testQueryTimeout: (BG) read write-locked entity");
    try {
      Query query=_entityManager.createQuery("select L from Lock_ L where L.id < 10000 ");
      query.setLockMode(LockModeType.PESSIMISTIC_READ);
      List<Lock> resultList=query.getResultList();
      String name=resultList.get(0).getName();
      log.info("testQueryTimeout: name read =" + name);
    }
 catch (    QueryTimeoutException e) {
      log.info("testQueryTimeout: (BG) got expected timeout exception");
      timedOut.set(true);
    }
catch (    Throwable e) {
      log.info("Expected LockTimeoutException but got unexpected exception",e);
    }
  }
,timeoutProps);
  return timedOut.get();
}
  finally {
  latch.countDown();
}

====================================================
OsgiArchiveDescriptor.java at Line:53 col: 4
try {
  final InputStreamAccess inputStreamAccess=new InputStreamAccess(){
    @Override public String getStreamName(){
      return resource;
    }
    @Override public InputStream accessInputStream(){
      return openInputStream();
    }
    private InputStream openInputStream(){
      try {
        return persistenceBundle.getResource(resource).openStream();
      }
 catch (      IOException e) {
        throw new PersistenceException("Unable to open an InputStream on the OSGi Bundle resource!",e);
      }
    }
  }
;
  final ArchiveEntry entry=new ArchiveEntry(){
    @Override public String getName(){
      return resource;
    }
    @Override public String getNameWithinArchive(){
      return resource;
    }
    @Override public InputStreamAccess getStreamAccess(){
      return inputStreamAccess;
    }
  }
;
  context.obtainArchiveEntryHandler(entry).handleEntry(entry,context);
}
 catch (Exception e) {
  LOG.unableToLoadScannedClassOrResource(e);
}

====================================================
AbstractCollectionPersister.java at Line:1215 col: 3
try {
  int offset=1;
  final PreparedStatement st;
  Expectation expectation=Expectations.appropriateExpectation(getDeleteAllCheckStyle());
  boolean callable=isDeleteAllCallable();
  boolean useBatch=expectation.canBeBatched();
  String sql=getSQLDeleteString();
  if (useBatch) {
    if (removeBatchKey == null) {
      removeBatchKey=new BasicBatchKey(getRole() + "#REMOVE",expectation);
    }
    st=session.getJdbcCoordinator().getBatch(removeBatchKey).getBatchStatement(sql,callable);
  }
 else {
    st=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(sql,callable);
  }
  try {
    offset+=expectation.prepare(st);
    writeKey(st,id,offset,session);
    if (useBatch) {
      session.getJdbcCoordinator().getBatch(removeBatchKey).addToBatch();
    }
 else {
      expectation.verifyOutcome(session.getJdbcCoordinator().getResultSetReturn().executeUpdate(st),st,-1);
    }
  }
 catch (  SQLException sqle) {
    if (useBatch) {
      session.getJdbcCoordinator().abortBatch();
    }
    throw sqle;
  }
 finally {
    if (!useBatch) {
      session.getJdbcCoordinator().getResourceRegistry().release(st);
      session.getJdbcCoordinator().afterStatementExecution();
    }
  }
  LOG.debug("Done deleting collection");
}
 catch (SQLException sqle) {
  throw sqlExceptionHelper.convert(sqle,"could not delete collection: " + MessageHelper.collectionInfoString(this,id,getFactory()),getSQLDeleteString());
}

====================================================
MySQLStoredProcedureTest.java at Line:217 col: 2
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (Statement statement=connection.createStatement()){
      statement.executeUpdate("DROP PROCEDURE IF EXISTS sp_is_null");
    }
 catch (    SQLException ignore) {
    }
  }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
HANAStoredProcedureTest.java at Line:273 col: 2
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (Statement statement=connection.createStatement()){
      statement.executeUpdate("DROP FUNCTION fn_count_phones");
    }
 catch (    SQLException ignore) {
    }
  }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
EntityTransactionTests.java at Line:188 col: 3
try {
  inSession(sessionFactory,session -> {
    final Transaction transaction=session.getTransaction();
    assertFalse(transaction.isActive());
    try {
      transaction.setRollbackOnly();
      fail("Expecting failure #setRollbackOnly on non-active txn");
    }
 catch (    IllegalStateException expected) {
    }
  }
);
}
  finally {
  sessionFactory.close();
}

====================================================
ReflectHelper.java at Line:354 col: 2
try {
  constructor=clazz.getDeclaredConstructor(constructorArgs);
  try {
    ReflectHelper.ensureAccessibility(constructor);
  }
 catch (  SecurityException e) {
    constructor=null;
  }
}
 catch (NoSuchMethodException ignore) {
}

====================================================
AbstractSchemaMigrator.java at Line:108 col: 4
try {
  for (  GenerationTarget target : targets) {
    target.prepare();
  }
  try {
    performMigration(metadata,databaseInformation,options,jdbcContext.getDialect(),targets);
  }
  finally {
    for (    GenerationTarget target : targets) {
      try {
        target.release();
      }
 catch (      Exception e) {
        log.debugf("Problem releasing GenerationTarget [%s] : %s",target,e.getMessage());
      }
    }
  }
}
  finally {
  try {
    databaseInformation.cleanup();
  }
 catch (  Exception e) {
    log.debug("Problem releasing DatabaseInformation : " + e.getMessage());
  }
}

====================================================
ScanningCoordinator.java at Line:163 col: 5
try {
  final Constructor<? extends Scanner> constructor=scannerImplClass.getConstructor();
  try {
    return constructor.newInstance();
  }
 catch (  Exception e2) {
    throw new IllegalStateException("Error trying to instantiate custom specified Scanner [" + scannerImplClass.getName() + "]",e2);
  }
}
 catch (NoSuchMethodException ignore) {
  throw new IllegalArgumentException("Configuration named a custom Scanner, but we were unable to locate " + "an appropriate constructor");
}

====================================================
SchemaUpdateSchemaNameTest.java at Line:79 col: 3
try {
  Session session=sf.openSession();
  try {
    session.getTransaction().begin();
    session.createNativeQuery("DROP TABLE Simple").executeUpdate();
    session.getTransaction().commit();
  }
 catch (  Throwable t) {
    if (session.getTransaction().isActive()) {
      session.getTransaction().rollback();
    }
    throw t;
  }
 finally {
    session.close();
  }
}
  finally {
  sf.close();
}

====================================================
CdiHostedConverterTest.java at Line:43 col: 2
try (final SeContainer cdiContainer=cdiInitializer.initialize()){
  BootstrapServiceRegistry bsr=new BootstrapServiceRegistryBuilder().build();
  final StandardServiceRegistry ssr=new StandardServiceRegistryBuilder(bsr).applySetting(AvailableSettings.HBM2DDL_AUTO,Action.CREATE_DROP).applySetting(AvailableSettings.CDI_BEAN_MANAGER,cdiContainer.getBeanManager()).build();
  final SessionFactoryImplementor sessionFactory;
  try {
    sessionFactory=(SessionFactoryImplementor)new MetadataSources(ssr).addAnnotatedClass(TheEntity.class).buildMetadata().getSessionFactoryBuilder().build();
  }
 catch (  Exception e) {
    StandardServiceRegistryBuilder.destroy(ssr);
    throw e;
  }
  assertTrue(MonitorBean.wasInstantiated());
  assertEquals(0,MonitorBean.currentFromDbCount());
  assertEquals(0,MonitorBean.currentToDbCount());
  try {
    inTransaction(sessionFactory,session -> session.persist(new TheEntity(1,"me",5)));
    assertEquals(0,MonitorBean.currentFromDbCount());
    assertEquals(1,MonitorBean.currentToDbCount());
    inTransaction(sessionFactory,session -> {
      TheEntity it=session.find(TheEntity.class,1);
      assertNotNull(it);
    }
);
    assertEquals(1,MonitorBean.currentFromDbCount());
    assertEquals(1,MonitorBean.currentToDbCount());
  }
  finally {
    inTransaction(sessionFactory,session -> {
      session.createQuery("delete TheEntity").executeUpdate();
    }
);
    sessionFactory.close();
  }
}
 
====================================================
UpgradeLockTest.java at Line:39 col: 2
try {
  Lock lock=new Lock();
  lock.setName("name");
  em.getTransaction().begin();
  em.persist(lock);
  em.getTransaction().commit();
  em.getTransaction().begin();
  lock=em.getReference(Lock.class,lock.getId());
  final Integer id=lock.getId();
  em.lock(lock,LockModeType.READ);
  em.lock(lock,LockModeType.OPTIMISTIC_FORCE_INCREMENT);
  lock.setName("surname");
  final CountDownLatch latch=new CountDownLatch(1);
  Thread t=new Thread(new Runnable(){
    public void run(){
      try {
        em2.getTransaction().begin();
        Lock lock2=em2.getReference(Lock.class,id);
        lock2.setName("renamed");
      }
  finally {
        em2.getTransaction().commit();
        em2.close();
        latch.countDown();
      }
    }
  }
);
  t.setDaemon(true);
  t.setName("testUpgradeReadLockToOptimisticForceIncrement tx2");
  t.start();
  log.info("testUpgradeReadLockToOptimisticForceIncrement:  wait on BG thread");
  boolean latchSet=latch.await(10,TimeUnit.SECONDS);
  assertTrue("background test thread finished (lock timeout is broken)",latchSet);
  try {
    em.getTransaction().commit();
  }
 catch (  Throwable expectedToFail) {
    while (expectedToFail != null && !(expectedToFail instanceof javax.persistence.OptimisticLockException)) {
      expectedToFail=expectedToFail.getCause();
    }
    assertTrue("upgrade to OPTIMISTIC_FORCE_INCREMENT is expected to fail at end of transaction1 since tranaction2 already updated the entity",expectedToFail instanceof javax.persistence.OptimisticLockException);
  }
}
  finally {
  em.close();
}

====================================================
AuthorService.java at Line:33 col: 2
try (Session session=sessionFactory.openSession()){
  session.getTransaction().begin();
  try {
    Author entity=new Author();
    entity.setName(name);
    entity.setFavoriteNumber(favoriteNumber);
    session.save(entity);
    session.getTransaction().commit();
  }
 catch (  Throwable e) {
    try {
      session.getTransaction().rollback();
    }
 catch (    Throwable e2) {
      e.addSuppressed(e2);
    }
    throw e;
  }
}
 
====================================================
AuthorService.java at Line:55 col: 2
try (Session session=sessionFactory.openSession()){
  session.getTransaction().begin();
  try {
    Author entity=session.bySimpleNaturalId(Author.class).getReference(name);
    entity.setFavoriteNumber(favoriteNumber);
    session.getTransaction().commit();
  }
 catch (  Throwable e) {
    try {
      session.getTransaction().rollback();
    }
 catch (    Throwable e2) {
      e.addSuppressed(e2);
    }
    throw e;
  }
}
 
====================================================
LockTest.java at Line:284 col: 3
try {
  doInJPA(this::entityManagerFactory,entityManager -> {
    TransactionUtil.setJdbcTimeout(entityManager.unwrap(Session.class));
    try {
      entityManager.createNativeQuery(updateStatement()).setParameter("name","changed").setParameter("id",lock.getId()).executeUpdate();
      fail("Should throw Exception");
    }
 catch (    Exception e) {
      if (!ExceptionUtil.isSqlLockTimeout(e)) {
        fail("Unknown exception thrown: " + e.getMessage());
      }
    }
  }
);
}
 catch (Exception e) {
  log.error("Failure",e);
}

====================================================
LockTest.java at Line:327 col: 3
try {
  doInJPA(this::entityManagerFactory,entityManager -> {
    try {
      TransactionUtil.setJdbcTimeout(entityManager.unwrap(Session.class));
      entityManager.createNativeQuery(updateStatement()).setParameter("name","changed").setParameter("id",lock.getId()).executeUpdate();
    }
 catch (    Exception e) {
      if (ExceptionUtil.isSqlLockTimeout(e)) {
        failureExpected.set(true);
      }
    }
  }
);
}
 catch (Exception e) {
  if (!failureExpected.get()) {
    fail("Should throw LockTimeoutException or PessimisticLockException");
  }
}

====================================================
ClosedFactoryTests.java at Line:36 col: 2
try {
  final SessionFactoryBuilderImplementor factoryBuilder=(SessionFactoryBuilderImplementor)new MetadataSources(ssr).buildMetadata().getSessionFactoryBuilder();
  final SessionFactory sf=factoryBuilder.build();
  sf.close();
  assertTrue(sf.isClosed());
  try {
    sf.getCache();
    fail("#getCache did not fail");
  }
 catch (  IllegalStateException expected) {
  }
catch (  Exception e) {
    fail("#getCache failed, but not with the expected IllegalStateException : " + e.toString());
  }
  try {
    sf.getMetamodel();
    fail("#getMetamodel did not fail");
  }
 catch (  IllegalStateException expected) {
  }
catch (  Exception e) {
    fail("#getMetamodel failed, but not with the expected IllegalStateException : " + e.toString());
  }
  try {
    sf.getCriteriaBuilder();
    fail("#getCriteriaBuilder did not fail");
  }
 catch (  IllegalStateException expected) {
  }
catch (  Exception e) {
    fail("#getCriteriaBuilder failed, but not with the expected IllegalStateException : " + e.toString());
  }
  try {
    sf.getProperties();
    fail("#getProperties did not fail");
  }
 catch (  IllegalStateException expected) {
  }
catch (  Exception e) {
    fail("#getProperties failed, but not with the expected IllegalStateException : " + e.toString());
  }
  try {
    sf.getPersistenceUnitUtil();
    fail("#getPersistenceUnitUtil did not fail");
  }
 catch (  IllegalStateException expected) {
  }
catch (  Exception e) {
    fail("#getPersistenceUnitUtil failed, but not with the expected IllegalStateException : " + e.toString());
  }
  try {
    sf.close();
    fail("#close did not fail");
  }
 catch (  IllegalStateException expected) {
  }
catch (  Exception e) {
    fail("#close failed, but not with the expected IllegalStateException : " + e.toString());
  }
  try {
    sf.createEntityManager();
    fail("#createEntityManager did not fail");
  }
 catch (  IllegalStateException expected) {
  }
catch (  Exception e) {
    fail("#createEntityManager failed, but not with the expected IllegalStateException : " + e.toString());
  }
  try {
    sf.createEntityManager(Collections.emptyMap());
    fail("#createEntityManager(Map) did not fail");
  }
 catch (  IllegalStateException expected) {
  }
catch (  Exception e) {
    fail("#createEntityManager(Map) failed, but not with the expected IllegalStateException : " + e.toString());
  }
}
 catch (Exception e) {
  StandardServiceRegistryBuilder.destroy(ssr);
}

====================================================
JdbcConnectionAccessProvidedConnectionImpl.java at Line:33 col: 2
try {
  wasInitiallyAutoCommit=jdbcConnection.getAutoCommit();
  if (!wasInitiallyAutoCommit) {
    try {
      jdbcConnection.setAutoCommit(true);
    }
 catch (    SQLException e) {
      throw new PersistenceException(String.format("Could not set provided connection [%s] to auto-commit mode" + " (needed for schema generation)",jdbcConnection),e);
    }
  }
}
 catch (SQLException ignore) {
  wasInitiallyAutoCommit=false;
}

====================================================
HANAStoredProcedureTest.java at Line:255 col: 2
try {
  Session session=entityManager.unwrap(Session.class);
  session.doWork(connection -> {
    try (Statement statement=connection.createStatement()){
      statement.executeUpdate("DROP PROCEDURE sp_person_phones");
    }
 catch (    SQLException ignore) {
    }
  }
);
}
  finally {
  entityManager.getTransaction().rollback();
  entityManager.close();
}

====================================================
EntityTransactionTests.java at Line:46 col: 3
try {
  inSession(sessionFactory,session -> {
    final Transaction transaction=session.getTransaction();
    assertFalse(transaction.isActive());
    try {
      transaction.getRollbackOnly();
      fail("Expecting failure #getRollbackOnly on non-active txn");
    }
 catch (    IllegalStateException expected) {
    }
  }
);
}
  finally {
  sessionFactory.close();
}

====================================================
JdbcEnvironmentInitiator.java at Line:67 col: 3
try {
  final Connection connection=jdbcConnectionAccess.obtainConnection();
  try {
    final DatabaseMetaData dbmd=connection.getMetaData();
    if (log.isDebugEnabled()) {
      log.debugf("Database ->\n" + "       name : %s\n" + "    version : %s\n"+ "      major : %s\n"+ "      minor : %s",dbmd.getDatabaseProductName(),dbmd.getDatabaseProductVersion(),dbmd.getDatabaseMajorVersion(),dbmd.getDatabaseMinorVersion());
      log.debugf("Driver ->\n" + "       name : %s\n" + "    version : %s\n"+ "      major : %s\n"+ "      minor : %s",dbmd.getDriverName(),dbmd.getDriverVersion(),dbmd.getDriverMajorVersion(),dbmd.getDriverMinorVersion());
      log.debugf("JDBC version : %s.%s",dbmd.getJDBCMajorVersion(),dbmd.getJDBCMinorVersion());
    }
    Dialect dialect=dialectFactory.buildDialect(configurationValues,new DialectResolutionInfoSource(){
      @Override public DialectResolutionInfo getDialectResolutionInfo(){
        try {
          return new DatabaseMetaDataDialectResolutionInfoAdapter(connection.getMetaData());
        }
 catch (        SQLException sqlException) {
          throw new HibernateException("Unable to access java.sql.DatabaseMetaData to determine appropriate Dialect to use",sqlException);
        }
      }
    }
);
    return new JdbcEnvironmentImpl(registry,dialect,dbmd);
  }
 catch (  SQLException e) {
    log.unableToObtainConnectionMetadata(e.getMessage());
  }
 finally {
    try {
      jdbcConnectionAccess.releaseConnection(connection);
    }
 catch (    SQLException ignore) {
    }
  }
}
 catch (Exception e) {
  log.unableToObtainConnectionToQueryMetadata(e.getMessage());
}

====================================================
SQLExceptionConverterFactory.java at Line:90 col: 2
try {
  LOG.tracev("Attempting to construct instance of specified SQLExceptionConverter [{0}]",converterClassName);
  final Class converterClass=ReflectHelper.classForName(converterClassName);
  final Constructor[] ctors=converterClass.getDeclaredConstructors();
  for (  Constructor ctor : ctors) {
    final Class[] parameterTypes=ctor.getParameterTypes();
    if (parameterTypes != null && ctor.getParameterCount() == 1) {
      if (ViolatedConstraintNameExtracter.class.isAssignableFrom(parameterTypes[0])) {
        try {
          return (SQLExceptionConverter)ctor.newInstance(violatedConstraintNameExtracter);
        }
 catch (        Throwable ignore) {
        }
      }
    }
  }
  return (SQLExceptionConverter)converterClass.newInstance();
}
 catch (Throwable t) {
  LOG.unableToConstructSqlExceptionConverter(t);
}

====================================================
TransactionUtil.java at Line:228 col: 2
try {
  entityManager=properties == null ? factorySupplier.get().createEntityManager() : factorySupplier.get().createEntityManager(properties);
  function.beforeTransactionCompletion();
  txn=entityManager.getTransaction();
  txn.begin();
  function.accept(entityManager);
  if (!txn.getRollbackOnly()) {
    txn.commit();
  }
 else {
    try {
      txn.rollback();
    }
 catch (    Exception e) {
      log.error("Rollback failure",e);
    }
  }
}
 catch (Throwable t) {
  if (txn != null && txn.isActive()) {
    try {
      txn.rollback();
    }
 catch (    Exception e) {
      log.error("Rollback failure",e);
    }
  }
  throw t;
}
 finally {
  function.afterTransactionCompletion();
  if (entityManager != null) {
    entityManager.close();
  }
}

====================================================
NativeQueryScrollableResults.java at Line:41 col: 2
try (Session session=openSession()){
  session.getTransaction().begin();
  try {
    session.save(new MyEntity(1L,"entity_1",new BigInteger("3")));
    session.save(new MyEntity(2L,"entity_2",new BigInteger("6")));
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().isActive()) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
SybaseTimestampVersioningTest.java at Line:54 col: 2
try {
  s1=sessionFactory().openSession();
  t1=s1.beginTransaction();
  s2=sessionFactory().openSession();
  t2=s2.beginTransaction();
  User user1=(User)s1.get(User.class,steve.getId());
  User user2=(User)s2.get(User.class,steve.getId());
  user1.setUsername("se");
  t1.commit();
  t1=null;
  user2.setUsername("steve-e");
  try {
    t2.commit();
    fail("optimistic lock check did not fail");
  }
 catch (  OptimisticLockException e) {
    try {
      t2.rollback();
    }
 catch (    Throwable ignore) {
    }
  }
}
 catch (Throwable error) {
  if (t1 != null) {
    try {
      t1.rollback();
    }
 catch (    Throwable ignore) {
    }
  }
  if (t2 != null) {
    try {
      t2.rollback();
    }
 catch (    Throwable ignore) {
    }
  }
  throw error;
}
 finally {
  if (s1 != null) {
    try {
      s1.close();
    }
 catch (    Throwable ignore) {
    }
  }
  if (s2 != null) {
    try {
      s2.close();
    }
 catch (    Throwable ignore) {
    }
  }
}

====================================================
JtaWithFailingBatchTest.java at Line:54 col: 2
try {
  transactionManager.begin();
  em.setFlushMode(FlushModeType.AUTO);
  EventLog eventLog1=new EventLog();
  eventLog1.setMessage("Foo1");
  em.persist(eventLog1);
  EventLog eventLog2=new EventLog();
  eventLog2.setMessage("Foo2");
  em.persist(eventLog2);
  Comment comment=new Comment();
  comment.setMessage("Bar");
  try {
    em.persist(comment);
    transactionManager.commit();
  }
 catch (  Exception expected) {
    if (transactionManager.getStatus() == Status.STATUS_ACTIVE) {
      transactionManager.rollback();
    }
  }
  assertThat("AbstractBatchImpl#releaseStatements() has not been callled",testBatch.calledReleaseStatements,is(true));
  assertAllStatementsAreClosed(testBatch.createdStatements);
  assertStatementsListIsCleared();
}
  finally {
  em.close();
}

====================================================
SessionCreateQueryFromCriteriaTest.java at Line:44 col: 2
try (Session s=openSession()){
  session.getTransaction().begin();
  try {
    s.createQuery("delete from TestEntity").executeUpdate();
    s.getTransaction().commit();
  }
 catch (  Exception e) {
    if (s.getTransaction().isActive()) {
      s.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
HSQLStoreProcedureTest.java at Line:148 col: 2
try {
  StoredProcedureQuery query=em.createNamedStoredProcedureQuery("User.inoutprocpositional");
  final Set<Parameter<?>> parameters=query.getParameters();
  assertThat(parameters.size(),is(2));
  assertThat(query.getParameter(1),not(nullValue()));
  assertThat(query.getParameter(2),not(nullValue()));
  assertThat(query.getParameter(1,Integer.class),not(nullValue()));
  try {
    query.getParameter(3);
    fail("An IllegalArgumentException is expected, A parameter at position 3 does not exist");
  }
 catch (  IllegalArgumentException iae) {
  }
  try {
    query.getParameter(1,String.class);
    fail("An IllegalArgumentException is expected, The parameter at position 1 is of type Integer not String");
  }
 catch (  IllegalArgumentException iae) {
  }
}
  finally {
  em.close();
}

====================================================
ScrollableTest.java at Line:59 col: 2
try (Session session=openSession()){
  session.getTransaction().begin();
  try {
    session.createQuery("delete from MyEntity").executeUpdate();
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().isActive()) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
PessimisticWriteUpdateLockingStrategy.java at Line:77 col: 2
try {
  try {
    final JdbcCoordinator jdbcCoordinator=session.getJdbcCoordinator();
    final PreparedStatement st=jdbcCoordinator.getStatementPreparer().prepareStatement(sql);
    try {
      lockable.getVersionType().nullSafeSet(st,version,1,session);
      int offset=2;
      lockable.getIdentifierType().nullSafeSet(st,id,offset,session);
      offset+=lockable.getIdentifierType().getColumnSpan(factory);
      if (lockable.isVersioned()) {
        lockable.getVersionType().nullSafeSet(st,version,offset,session);
      }
      final int affected=jdbcCoordinator.getResultSetReturn().executeUpdate(st);
      if (affected < 0) {
        final StatisticsImplementor statistics=factory.getStatistics();
        if (statistics.isStatisticsEnabled()) {
          statistics.optimisticFailure(lockable.getEntityName());
        }
        throw new StaleObjectStateException(lockable.getEntityName(),id);
      }
    }
  finally {
      jdbcCoordinator.getLogicalConnection().getResourceRegistry().release(st);
      jdbcCoordinator.afterStatementExecution();
    }
  }
 catch (  SQLException e) {
    throw session.getJdbcServices().getSqlExceptionHelper().convert(e,"could not lock: " + MessageHelper.infoString(lockable,id,session.getFactory()),sql);
  }
}
 catch (JDBCException e) {
  throw new PessimisticEntityLockException(object,"could not obtain pessimistic lock",e);
}

====================================================
OneToManyPersister.java at Line:331 col: 2
try {
  int count=0;
  if (isRowDeleteEnabled()) {
    final Expectation deleteExpectation=Expectations.appropriateExpectation(getDeleteCheckStyle());
    final boolean useBatch=deleteExpectation.canBeBatched();
    if (useBatch && deleteRowBatchKey == null) {
      deleteRowBatchKey=new BasicBatchKey(getRole() + "#DELETEROW",deleteExpectation);
    }
    final String sql=getSQLDeleteRowString();
    PreparedStatement st=null;
    try {
      int i=0;
      Iterator entries=collection.entries(this);
      int offset=1;
      while (entries.hasNext()) {
        Object entry=entries.next();
        if (collection.needsUpdating(entry,i,elementType)) {
          if (useBatch) {
            st=session.getJdbcCoordinator().getBatch(deleteRowBatchKey).getBatchStatement(sql,isDeleteCallable());
          }
 else {
            st=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(sql,isDeleteCallable());
          }
          int loc=writeKey(st,id,offset,session);
          writeElementToWhere(st,collection.getSnapshotElement(entry,i),loc,session);
          if (useBatch) {
            session.getJdbcCoordinator().getBatch(deleteRowBatchKey).addToBatch();
          }
 else {
            deleteExpectation.verifyOutcome(session.getJdbcCoordinator().getResultSetReturn().executeUpdate(st),st,-1);
          }
          count++;
        }
        i++;
      }
    }
 catch (    SQLException e) {
      if (useBatch) {
        session.getJdbcCoordinator().abortBatch();
      }
      throw e;
    }
 finally {
      if (!useBatch) {
        session.getJdbcCoordinator().getResourceRegistry().release(st);
        session.getJdbcCoordinator().afterStatementExecution();
      }
    }
  }
  if (isRowInsertEnabled()) {
    final Expectation insertExpectation=Expectations.appropriateExpectation(getInsertCheckStyle());
    boolean useBatch=insertExpectation.canBeBatched();
    boolean callable=isInsertCallable();
    if (useBatch && insertRowBatchKey == null) {
      insertRowBatchKey=new BasicBatchKey(getRole() + "#INSERTROW",insertExpectation);
    }
    final String sql=getSQLInsertRowString();
    PreparedStatement st=null;
    try {
      int i=0;
      Iterator entries=collection.entries(this);
      while (entries.hasNext()) {
        Object entry=entries.next();
        int offset=1;
        if (collection.needsUpdating(entry,i,elementType)) {
          if (useBatch) {
            st=session.getJdbcCoordinator().getBatch(insertRowBatchKey).getBatchStatement(sql,callable);
          }
 else {
            st=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(sql,callable);
          }
          offset+=insertExpectation.prepare(st);
          int loc=writeKey(st,id,offset,session);
          if (hasIndex && !indexContainsFormula) {
            loc=writeIndexToWhere(st,collection.getIndex(entry,i,this),loc,session);
          }
          writeElementToWhere(st,collection.getElement(entry),loc,session);
          if (useBatch) {
            session.getJdbcCoordinator().getBatch(insertRowBatchKey).addToBatch();
          }
 else {
            insertExpectation.verifyOutcome(session.getJdbcCoordinator().getResultSetReturn().executeUpdate(st),st,-1);
          }
          count++;
        }
        i++;
      }
    }
 catch (    SQLException sqle) {
      if (useBatch) {
        session.getJdbcCoordinator().abortBatch();
      }
      throw sqle;
    }
 finally {
      if (!useBatch) {
        session.getJdbcCoordinator().getResourceRegistry().release(st);
        session.getJdbcCoordinator().afterStatementExecution();
      }
    }
  }
  return count;
}
 catch (SQLException sqle) {
  throw getFactory().getSQLExceptionHelper().convert(sqle,"could not update collection rows: " + MessageHelper.collectionInfoString(this,collection,id,session),getSQLInsertRowString());
}

====================================================
LobCreatorBuilderImpl.java at Line:120 col: 4
try {
  final Object clob=createClobMethod.invoke(jdbcConnection,NO_ARGS);
  try {
    final Method freeMethod=clob.getClass().getMethod("free",NO_ARG_SIG);
    freeMethod.invoke(clob,NO_ARGS);
  }
 catch (  Throwable ignore) {
    LOG.tracef("Unable to free CLOB created to test createClob() implementation : %s",ignore);
  }
  return true;
}
 catch (Throwable t) {
  LOG.disablingContextualLOBCreationSinceCreateClobFailed(t);
}

====================================================
JdbcIsolationDelegate.java at Line:47 col: 2
try {
  Connection connection=jdbcConnectionAccess().obtainConnection();
  try {
    if (transacted) {
      if (connection.getAutoCommit()) {
        wasAutoCommit=true;
        connection.setAutoCommit(false);
      }
    }
    T result=work.accept(new WorkExecutor<T>(),connection);
    if (transacted) {
      connection.commit();
    }
    return result;
  }
 catch (  Exception e) {
    try {
      if (transacted && !connection.isClosed()) {
        connection.rollback();
      }
    }
 catch (    Exception ignore) {
      LOG.unableToRollbackConnection(ignore);
    }
    if (e instanceof HibernateException) {
      throw (HibernateException)e;
    }
 else     if (e instanceof SQLException) {
      throw sqlExceptionHelper().convert((SQLException)e,"error performing isolated work");
    }
 else {
      throw new HibernateException("error performing isolated work",e);
    }
  }
 finally {
    if (transacted && wasAutoCommit) {
      try {
        connection.setAutoCommit(true);
      }
 catch (      Exception ignore) {
        LOG.trace("was unable to reset connection back to auto-commit");
      }
    }
    try {
      jdbcConnectionAccess().releaseConnection(connection);
    }
 catch (    Exception ignore) {
      LOG.unableToReleaseIsolatedConnection(ignore);
    }
  }
}
 catch (SQLException sqle) {
  throw sqlExceptionHelper().convert(sqle,"unable to obtain isolated JDBC connection");
}

====================================================
TransactionUtil.java at Line:470 col: 2
try {
  session=sessionBuilderSupplier.get().openSession();
  function.beforeTransactionCompletion();
  txn=session.beginTransaction();
  result=function.apply(session);
  if (!txn.getRollbackOnly()) {
    txn.commit();
  }
 else {
    try {
      txn.rollback();
    }
 catch (    Exception e) {
      log.error("Rollback failure",e);
    }
  }
}
 catch (Throwable t) {
  if (txn != null && txn.isActive()) {
    try {
      txn.rollback();
    }
 catch (    Exception e) {
      log.error("Rollback failure",e);
    }
  }
  throw t;
}
 finally {
  function.afterTransactionCompletion();
  if (session != null) {
    session.close();
  }
}

====================================================
DeleteExecutor.java at Line:55 col: 2
try {
  final DeleteStatement deleteStatement=(DeleteStatement)walker.getAST();
  final String idSubselectWhere;
  if (deleteStatement.hasWhereClause()) {
    final AST whereClause=deleteStatement.getWhereClause();
    final SqlGenerator gen=new SqlGenerator(factory);
    gen.whereClause(whereClause);
    parameterSpecifications=gen.getCollectedParameters();
    String sql=gen.getSQL();
    idSubselectWhere=sql.length() > 7 ? sql : "";
  }
 else {
    parameterSpecifications=new ArrayList<>();
    idSubselectWhere="";
  }
  final boolean commentsEnabled=factory.getSessionFactoryOptions().isCommentsEnabled();
  final MetamodelImplementor metamodel=factory.getMetamodel();
  final boolean notSupportingTuplesInSubqueries=!dialect.supportsTuplesInSubqueries();
  for (  Type type : persister.getPropertyTypes()) {
    if (type.isCollectionType()) {
      final CollectionType cType=(CollectionType)type;
      final AbstractCollectionPersister cPersister=(AbstractCollectionPersister)metamodel.collectionPersister(cType.getRole());
      if (cPersister.isManyToMany()) {
        Type keyType=cPersister.getKeyType();
        String[] columnNames;
        if (keyType.isComponentType()) {
          ComponentType componentType=(ComponentType)keyType;
          List<String> columns=new ArrayList<>(componentType.getPropertyNames().length);
          try {
            for (            String propertyName : componentType.getPropertyNames()) {
              Collections.addAll(columns,persister.toColumns(propertyName));
            }
            columnNames=columns.toArray(new String[0]);
          }
 catch (          MappingException e) {
            columnNames=persister.getIdentifierColumnNames();
          }
        }
 else {
          columnNames=persister.getIdentifierColumnNames();
        }
        if (columnNames.length > 1 && notSupportingTuplesInSubqueries) {
          LOG.warn("This dialect is unable to cascade the delete into the many-to-many join table" + " when the entity has multiple primary keys.  Either properly setup cascading on" + " the constraints or manually clear the associations prior to deleting the entities.");
        }
 else {
          StringBuilder whereBuilder=new StringBuilder();
          whereBuilder.append('(');
          append(", ",cPersister.getKeyColumnNames(),whereBuilder);
          whereBuilder.append(") in (select ");
          append(", ",columnNames,whereBuilder);
          final String where=whereBuilder.append(" from ").append(persister.getTableName()).append(idSubselectWhere).append(")").toString();
          final Delete delete=new Delete().setTableName(cPersister.getTableName()).setWhere(where);
          if (commentsEnabled) {
            delete.setComment("delete FKs in join table");
          }
          deletes.add(delete.toStatementString());
        }
      }
    }
  }
}
 catch (RecognitionException e) {
  throw new HibernateException("Unable to delete the FKs in the join table!",e);
}

====================================================
QueryTest.java at Line:1494 col: 2
try {
  for (int i=0; i < 1000; i++) {
    try {
      entityManager.createNativeQuery("Select 1 from NotExistedTable").getResultList();
      fail("expected PersistenceException");
    }
 catch (    PersistenceException e) {
    }
  }
}
  finally {
  entityManager.close();
}

====================================================
LockTest.java at Line:843 col: 5
try {
  AtomicBoolean timedOut=new AtomicBoolean();
  doInJPA(this::entityManagerFactory,_entityManager -> {
    log.info("testContendedPessimisticWriteLockNoWait: (BG) about to read write-locked entity");
    Lock lock2=_entityManager.getReference(Lock.class,lock.getId());
    lock2.getName();
    log.info("testContendedPessimisticWriteLockNoWait: (BG) read write-locked entity");
    Map<String,Object> props=new HashMap<String,Object>();
    props.put(AvailableSettings.LOCK_TIMEOUT,0);
    try {
      _entityManager.lock(lock2,LockModeType.PESSIMISTIC_WRITE,props);
    }
 catch (    LockTimeoutException e) {
      log.info("testContendedPessimisticWriteLockNoWait: (BG) got expected timeout exception");
      timedOut.set(true);
    }
catch (    Throwable e) {
      log.info("Expected LockTimeoutException but got unexpected exception",e);
    }
  }
);
  return timedOut.get();
}
  finally {
  latch.countDown();
}

====================================================
ArchiveHelper.java at Line:49 col: 2
try {
  final String protocol=url.getProtocol();
  if ("jar".equals(protocol) || "wsjar".equals(protocol)) {
    jarUrl=new URL(file);
    if ("file".equals(jarUrl.getProtocol())) {
      if (file.indexOf(' ') != -1) {
        jarUrl=new File(jarUrl.getFile()).toURI().toURL();
      }
    }
  }
 else   if ("zip".equals(protocol) || "code-source".equals(url.getProtocol()) || "file".equals(protocol)) {
    if (file.indexOf(' ') != -1) {
      jarUrl=new File(file).toURI().toURL();
    }
 else {
      jarUrl=new File(file).toURL();
    }
  }
 else {
    try {
      jarUrl=new URL(protocol,url.getHost(),url.getPort(),file);
    }
 catch (    final MalformedURLException e) {
      jarUrl=url;
    }
  }
}
 catch (MalformedURLException e) {
  throw new IllegalArgumentException("Unable to determine JAR Url from " + url + ". Cause: "+ e.getMessage());
}

====================================================
PersistenceContextTest.java at Line:194 col: 2
try {
  doInJPA(this::entityManagerFactory,entityManager -> {
    Long personId=_personId;
    try {
      Person person=entityManager.find(Person.class,personId);
      Book book=new Book();
      book.setId(100L);
      book.setTitle("Hibernate User Guide");
      book.setAuthor(person);
      person.getBooks().add(book);
      entityManager.refresh(person);
    }
 catch (    EntityNotFoundException expected) {
      log.info("Beware when cascading the refresh associations to transient entities!");
    }
  }
);
}
 catch (Exception expected) {
}

====================================================
ConfigLoader.java at Line:144 col: 2
try {
  final InputStream stream=new FileInputStream(file);
  try {
    Properties properties=new Properties();
    properties.load(stream);
    return properties;
  }
 catch (  IOException e) {
    throw new ConfigurationException("Unable to apply settings from properties file [" + file.getAbsolutePath() + "]",e);
  }
 finally {
    try {
      stream.close();
    }
 catch (    IOException e) {
      log.debug(String.format("Unable to close properties file [%s] stream",file.getAbsolutePath()),e);
    }
  }
}
 catch (FileNotFoundException e) {
  throw new ConfigurationException("Unable locate specified properties file [" + file.getAbsolutePath() + "]",e);
}

====================================================
SequenceInformationExtractorLegacyImpl.java at Line:41 col: 2
try {
  final ResultSet resultSet=statement.executeQuery(lookupSql);
  try {
    final List<SequenceInformation> sequenceInformationList=new ArrayList<>();
    while (resultSet.next()) {
      sequenceInformationList.add(new SequenceInformationImpl(new QualifiedSequenceName(identifierHelper.toIdentifier(resultSetCatalogName(resultSet)),identifierHelper.toIdentifier(resultSetSchemaName(resultSet)),identifierHelper.toIdentifier(resultSetSequenceName(resultSet))),resultSetStartValueSize(resultSet),resultSetMinValue(resultSet),resultSetMaxValue(resultSet),resultSetIncrementValue(resultSet)));
    }
    return sequenceInformationList;
  }
  finally {
    try {
      resultSet.close();
    }
 catch (    SQLException ignore) {
    }
  }
}
  finally {
  try {
    statement.close();
  }
 catch (  SQLException ignore) {
  }
}

====================================================
InformationExtractorJdbcDatabaseMetaDataImpl.java at Line:257 col: 3
try {
  final String tableNameFilter=toMetaDataObjectName(tableName);
  final ResultSet resultSet=extractionContext.getJdbcDatabaseMetaData().getTables(null,null,tableNameFilter,tableTypes);
  try {
    return processTableResults(null,null,tableName,resultSet);
  }
  finally {
    try {
      resultSet.close();
    }
 catch (    SQLException ignore) {
    }
  }
}
 catch (SQLException sqlException) {
  throw convertSQLException(sqlException,"Error accessing table metadata");
}

====================================================
PersistentAttributesEnhancer.java at Line:236 col: 2
try {
  boolean declared=persistentField.getDeclaringClass().equals(managedCtClass);
  String declaredWriteFragment="this." + fieldName + "="+ fieldName+ ";";
  String superWriteFragment="super." + writerName + "("+ fieldName+ ");";
  if (!declared) {
    try {
      persistentField.getDeclaringClass().getDeclaredMethod(readerName);
      persistentField.getDeclaringClass().getDeclaredMethod(writerName);
    }
 catch (    NotFoundException nfe) {
      tmpSuperReader=MethodWriter.addGetter(persistentField.getDeclaringClass(),persistentField.getName(),readerName);
      tmpSuperWriter=MethodWriter.addSetter(persistentField.getDeclaringClass(),persistentField.getName(),writerName);
    }
  }
  if (!enhancementContext.hasLazyLoadableAttributes(managedCtClass) || !enhancementContext.isLazyLoadable(persistentField)) {
    writer=MethodWriter.write(managedCtClass,"public void %s(%s %s) {%n  %s%n}",writerName,persistentField.getType().getName(),fieldName,declared ? declaredWriteFragment : superWriteFragment);
  }
 else {
    writer=MethodWriter.write(managedCtClass,"public void %s(%s %s) {%n%s%n}",writerName,persistentField.getType().getName(),fieldName,typeDescriptor.buildWriteInterceptionBodyFragment(fieldName));
  }
  if (enhancementContext.doDirtyCheckingInline(managedCtClass)) {
    if (enhancementContext.isCompositeClass(managedCtClass)) {
      writer.insertBefore(String.format("  if (%1$s != null) { %1$s.callOwner(\"\"); }%n",EnhancerConstants.TRACKER_COMPOSITE_FIELD_NAME));
    }
 else {
      writer.insertBefore(typeDescriptor.buildInLineDirtyCheckingBodyFragment(enhancementContext,persistentField));
    }
    handleCompositeField(managedCtClass,persistentField,writer);
  }
  if (enhancementContext.doBiDirectionalAssociationManagement(persistentField)) {
    handleBiDirectionalAssociation(managedCtClass,persistentField,writer);
  }
  if (tmpSuperReader != null) {
    persistentField.getDeclaringClass().removeMethod(tmpSuperReader);
  }
  if (tmpSuperWriter != null) {
    persistentField.getDeclaringClass().removeMethod(tmpSuperWriter);
  }
  return writer;
}
 catch (CannotCompileException cce) {
  final String msg=String.format("Could not enhance entity class [%s] to add field writer method [%s]",managedCtClass.getName(),writerName);
  throw new EnhancementException(msg,cce);
}
catch (NotFoundException nfe) {
  final String msg=String.format("Could not enhance entity class [%s] to add field writer method [%s]",managedCtClass.getName(),writerName);
  throw new EnhancementException(msg,nfe);
}

====================================================
LongToDateConversionTest.java at Line:69 col: 2
try (Session session=openSession()){
  session.getTransaction().begin();
  try {
    session.createQuery("delete from TestEntity").executeUpdate();
    session.getTransaction().commit();
  }
 catch (  Exception e) {
    if (session.getTransaction().isActive()) {
      session.getTransaction().rollback();
    }
    throw e;
  }
}
 
====================================================
IndividuallySchemaValidatorImplTest.java at Line:166 col: 2
try {
  new SchemaCreatorImpl(ssr).doCreation(metadata,serviceRegistry,settings,true,schemaGenerator);
  metadataSources=new MetadataSources(ssr);
  metadataSources.addAnnotatedClass(NameColumn.class);
  metadata=(MetadataImplementor)metadataSources.buildMetadata();
  metadata.validate();
  try {
    getSchemaValidator(metadata);
    Assert.fail("SchemaManagementException expected");
  }
 catch (  SchemaManagementException e) {
    assertEquals("Schema-validation: missing column [name] in table [SomeSchema.ColumnEntity]",e.getMessage());
  }
}
  finally {
  new SchemaDropperImpl(serviceRegistry).doDrop(metadata,false,schemaGenerator);
  serviceRegistry.destroy();
  connectionProvider.stop();
}

====================================================
JpaTckUsageTest.java at Line:177 col: 2
try {
  try {
    StoredProcedureQuery query=em.createNamedStoredProcedureQuery("positional-param");
    query.setParameter(99,1);
    fail("Expecting an exception");
  }
 catch (  IllegalArgumentException expected) {
  }
  try {
    StoredProcedureQuery query=em.createNamedStoredProcedureQuery("positional-param");
    query.setParameter("does-not-exist",1);
    fail("Expecting an exception");
  }
 catch (  IllegalArgumentException expected) {
  }
}
  finally {
  em.getTransaction().commit();
  em.close();
}

====================================================
JpaTckUsageTest.java at Line:308 col: 3
try {
  Statement statement=conn.createStatement();
  try {
    dropProcedures(statement);
  }
 catch (  SQLException ignore) {
  }
  createProcedureFindOneUser(statement);
  createProcedureDeleteAllUsers(statement);
  try {
    statement.close();
  }
 catch (  SQLException ignore) {
  }
}
  finally {
  try {
    conn.commit();
  }
 catch (  SQLException e) {
    System.out.println("Unable to commit transaction after creating creating procedures");
  }
  try {
    connectionAccess.releaseConnection(conn);
  }
 catch (  SQLException ignore) {
  }
}

====================================================
PersisterFactoryImpl.java at Line:93 col: 2
try {
  final Constructor<? extends EntityPersister> constructor=persisterClass.getConstructor(ENTITY_PERSISTER_CONSTRUCTOR_ARGS);
  try {
    return constructor.newInstance(entityBinding,entityCacheAccessStrategy,naturalIdCacheAccessStrategy,creationContext);
  }
 catch (  MappingException e) {
    throw e;
  }
catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof HibernateException) {
      throw (HibernateException)target;
    }
 else {
      throw new MappingException("Could not instantiate persister " + persisterClass.getName(),target);
    }
  }
catch (  Exception e) {
    throw new MappingException("Could not instantiate persister " + persisterClass.getName(),e);
  }
}
 catch (MappingException e) {
  throw e;
}
catch (Exception e) {
  throw new MappingException("Could not get constructor for " + persisterClass.getName(),e);
}

====================================================
LocalSchemaLocator.java at Line:55 col: 2
try {
  InputStream schemaStream=schemaUrl.openStream();
  try {
    StreamSource source=new StreamSource(schemaUrl.openStream());
    SchemaFactory schemaFactory=SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
    return schemaFactory.newSchema(source);
  }
 catch (  Exception e) {
    throw new XmlInfrastructureException("Unable to load schema [" + schemaUrl.toExternalForm() + "]",e);
  }
 finally {
    try {
      schemaStream.close();
    }
 catch (    IOException e) {
      log.debugf("Problem closing schema stream - %s",e.toString());
    }
  }
}
 catch (IOException e) {
  throw new XmlInfrastructureException("Stream error handling schema url [" + schemaUrl.toExternalForm() + "]");
}

====================================================
JdbcEnvironmentInitiator.java at Line:69 col: 4
try {
  final DatabaseMetaData dbmd=connection.getMetaData();
  if (log.isDebugEnabled()) {
    log.debugf("Database ->\n" + "       name : %s\n" + "    version : %s\n"+ "      major : %s\n"+ "      minor : %s",dbmd.getDatabaseProductName(),dbmd.getDatabaseProductVersion(),dbmd.getDatabaseMajorVersion(),dbmd.getDatabaseMinorVersion());
    log.debugf("Driver ->\n" + "       name : %s\n" + "    version : %s\n"+ "      major : %s\n"+ "      minor : %s",dbmd.getDriverName(),dbmd.getDriverVersion(),dbmd.getDriverMajorVersion(),dbmd.getDriverMinorVersion());
    log.debugf("JDBC version : %s.%s",dbmd.getJDBCMajorVersion(),dbmd.getJDBCMinorVersion());
  }
  Dialect dialect=dialectFactory.buildDialect(configurationValues,new DialectResolutionInfoSource(){
    @Override public DialectResolutionInfo getDialectResolutionInfo(){
      try {
        return new DatabaseMetaDataDialectResolutionInfoAdapter(connection.getMetaData());
      }
 catch (      SQLException sqlException) {
        throw new HibernateException("Unable to access java.sql.DatabaseMetaData to determine appropriate Dialect to use",sqlException);
      }
    }
  }
);
  return new JdbcEnvironmentImpl(registry,dialect,dbmd);
}
 catch (SQLException e) {
  log.unableToObtainConnectionMetadata(e.getMessage());
}
 finally {
  try {
    jdbcConnectionAccess.releaseConnection(connection);
  }
 catch (  SQLException ignore) {
  }
}

====================================================
Helper.java at Line:176 col: 3
try {
  Statement statement=connection.createStatement();
  try {
    statement.executeUpdate(logStatement(factory,idTableInfo.getIdTableDropStatement()));
    factory.getServiceRegistry().getService(JdbcServices.class).getSqlExceptionHelper().handleAndClearWarnings(statement,WARNING_HANDLER);
  }
  finally {
    try {
      statement.close();
    }
 catch (    Throwable ignore) {
    }
  }
}
 catch (Exception e) {
  log.warn("unable to drop temporary id table after use [" + e.getMessage() + "]");
}

====================================================
MetadataContext.java at Line:451 col: 2
try {
  final boolean allowNonDeclaredFieldReference=attribute.getPersistentAttributeType() == Attribute.PersistentAttributeType.EMBEDDED || attribute.getDeclaringType().getPersistenceType() == Type.PersistenceType.EMBEDDABLE;
  final Field field=allowNonDeclaredFieldReference ? metamodelClass.getField(name) : metamodelClass.getDeclaredField(name);
  try {
    ReflectHelper.ensureAccessibility(field);
    field.set(null,attribute);
  }
 catch (  IllegalAccessException e) {
    throw new AssertionFailure("Unable to inject static metamodel attribute : " + metamodelClass.getName() + '#'+ name,e);
  }
catch (  IllegalArgumentException e) {
    LOG.illegalArgumentOnStaticMetamodelFieldInjection(metamodelClass.getName(),name,attribute.getClass().getName(),field.getType().getName());
  }
}
 catch (NoSuchFieldException e) {
  LOG.unableToLocateStaticMetamodelField(metamodelClass.getName(),name);
}

====================================================
SessionImpl.java at Line:2025 col: 2
try {
  if (!HibernateProxy.class.isInstance(object) && persistenceContext.getEntry(object) == null) {
    try {
      getSessionFactory().getMetamodel().entityPersister(entityName);
    }
 catch (    HibernateException e) {
      throw new IllegalArgumentException("Not an entity [" + entityName + "] : "+ object);
    }
  }
  if (object instanceof HibernateProxy) {
    LazyInitializer li=((HibernateProxy)object).getHibernateLazyInitializer();
    if (li.isUninitialized()) {
      return li.getSession() == this;
    }
 else {
      object=li.getImplementation();
    }
  }
  EntityEntry entry=persistenceContext.getEntry(object);
  delayedAfterCompletion();
  return entry != null && entry.getStatus() != Status.DELETED && entry.getStatus() != Status.GONE;
}
 catch (MappingException e) {
  throw new IllegalArgumentException(e.getMessage(),e);
}
catch (RuntimeException e) {
  throw getExceptionConverter().convert(e);
}

====================================================
AuthorService.java at Line:75 col: 2
try (Session session=sessionFactory.openSession()){
  session.getTransaction().begin();
  try {
    Author entity=session.bySimpleNaturalId(Author.class).getReference(name);
    Integer result=entity.getFavoriteNumber();
    session.getTransaction().rollback();
    return result;
  }
 catch (  Throwable e) {
    try {
      session.getTransaction().rollback();
    }
 catch (    Throwable e2) {
      e.addSuppressed(e2);
    }
    throw e;
  }
}
 
====================================================
BeanInfoHelper.java at Line:80 col: 2
try {
  BeanInfo info=Introspector.getBeanInfo(beanClass,stopClass);
  try {
    return delegate.processBeanInfo(info);
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  InvocationTargetException e) {
    throw new BeanIntrospectionException("Error delegating bean info use",e.getTargetException());
  }
catch (  Exception e) {
    throw new BeanIntrospectionException("Error delegating bean info use",e);
  }
 finally {
    Introspector.flushFromCaches(beanClass);
  }
}
 catch (IntrospectionException e) {
  throw new BeanIntrospectionException("Unable to determine bean info from class [" + beanClass.getName() + "]",e);
}

====================================================
JpaComplianceAlreadyStartedTransactionTest.java at Line:45 col: 2
try (Session s=openSession()){
  tm.begin();
  Transaction tx=null;
  try {
    tx=s.beginTransaction();
  }
 catch (  Exception e) {
    if (tx != null && tx.isActive()) {
      tx.rollback();
    }
    throw e;
  }
}
 catch (Exception e) {
  if (tm.getStatus() == Status.STATUS_ACTIVE) {
    tm.rollback();
  }
  throw e;
}

====================================================
SequenceStructure.java at Line:92 col: 4
try {
  final PreparedStatement st=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(sql);
  try {
    final ResultSet rs=session.getJdbcCoordinator().getResultSetReturn().extract(st);
    try {
      rs.next();
      final IntegralDataTypeHolder value=IdentifierGeneratorHelper.getIntegralDataTypeHolder(numberType);
      value.initialize(rs,1);
      if (LOG.isDebugEnabled()) {
        LOG.debugf("Sequence value obtained: %s",value.makeValue());
      }
      return value;
    }
  finally {
      try {
        session.getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(rs,st);
      }
 catch (      Throwable ignore) {
      }
    }
  }
  finally {
    session.getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(st);
    session.getJdbcCoordinator().afterStatementExecution();
  }
}
 catch (SQLException sqle) {
  throw session.getJdbcServices().getSqlExceptionHelper().convert(sqle,"could not get next sequence value",sql);
}


---------------DESTRUCTIVE WRAPPING--------------
SessionFactoryHelper.java at Line:192 col: 2
catch (Exception e) {
  throw new QueryException("collection not found: " + role);
}
==============================================================================================
JndiServiceImpl.java at Line:154 col: 2
catch (Exception initialException) {
  if (name.size() == 1) {
    throw new JndiException("Error performing bind [" + name + "]",initialException);
  }
  Context intermediateContextBase=context;
  while (name.size() > 1) {
    final String intermediateContextName=name.get(0);
    Context intermediateContext=null;
    try {
      LOG.tracev("Intermediate lookup: {0}",intermediateContextName);
      intermediateContext=(Context)intermediateContextBase.lookup(intermediateContextName);
    }
 catch (    NameNotFoundException handledBelow) {
    }
catch (    NamingException e) {
      throw new JndiException("Unanticipated error doing intermediate lookup",e);
    }
    if (intermediateContext != null) {
      LOG.tracev("Found intermediate context: {0}",intermediateContextName);
    }
 else {
      LOG.tracev("Creating sub-context: {0}",intermediateContextName);
      try {
        intermediateContext=intermediateContextBase.createSubcontext(intermediateContextName);
      }
 catch (      NamingException e) {
        throw new JndiException("Error creating intermediate context [" + intermediateContextName + "]",e);
      }
    }
    intermediateContextBase=intermediateContext;
    name=name.getSuffix(1);
  }
  LOG.tracev("Binding : {0}",name);
  try {
    intermediateContextBase.rebind(name,value);
  }
 catch (  NamingException e) {
    throw new JndiException("Error performing intermediate bind [" + name + "]",e);
  }
}
==============================================================================================
AccessType.java at Line:80 col: 2
catch (IllegalArgumentException e) {
  throw new UnknownAccessTypeException(externalName);
}
==============================================================================================
FastClass.java at Line:79 col: 2
catch (ArrayIndexOutOfBoundsException e) {
  throw new IllegalArgumentException("Cannot find matching method/constructor");
}
==============================================================================================
EntityManagerDeserializationTest.java at Line:74 col: 2
catch (ClassNotFoundException cnfe) {
  throw new IOException("Unable to locate class on reconstruction");
}
==============================================================================================
BatchingBatchFailureTest.java at Line:69 col: 2
catch (Exception expected) {
  System.out.println("Caught expected exception : " + expected);
  expected.printStackTrace(System.out);
  try {
    SessionImplementor sessionImplementor=(SessionImplementor)session;
    Field field=sessionImplementor.getJdbcCoordinator().getClass().getDeclaredField("currentBatch");
    field.setAccessible(true);
    Batch batch=(Batch)field.get(sessionImplementor.getJdbcCoordinator());
    if (batch == null) {
      throw new Exception("Current batch was null");
    }
 else {
      assertEquals(BatchingBatch.class,batch.getClass());
      field=AbstractBatchImpl.class.getDeclaredField("statements");
      field.setAccessible(true);
      assertEquals(0,((Map)field.get(batch)).size());
    }
  }
 catch (  Exception fieldException) {
    fail("Couldn't inspect field " + fieldException.getMessage());
  }
}
==============================================================================================
QueryTranslatorImpl.java at Line:465 col: 2
catch (ClassCastException cce) {
  throw new QueryException("collection role is not queryable: " + role);
}
==============================================================================================
AliasToBeanResultTransformer.java at Line:85 col: 2
catch (IllegalAccessException e) {
  throw new HibernateException("Could not instantiate resultclass: " + resultClass.getName());
}
==============================================================================================
AbstractProducedQuery.java at Line:1102 col: 2
catch (ClassCastException e) {
  throw new IllegalArgumentException("Value for hint");
}
==============================================================================================
ArchiveHelper.java at Line:115 col: 2
catch (MalformedURLException e) {
  try {
    jarUrl=new URL("file:" + jarPath);
  }
 catch (  MalformedURLException ee) {
    throw new IllegalArgumentException("Unable to find jar:" + jarPath,ee);
  }
}
==============================================================================================
AbstractEntityPersister.java at Line:2589 col: 2
catch (TooManyRowsAffectedException e) {
  throw new HibernateException("Duplicate identifier in table for: " + MessageHelper.infoString(this,id,getFactory()));
}
==============================================================================================
ByteBuddyProxyHelper.java at Line:134 col: 2
catch (NoSuchMethodException e) {
  throw new HibernateException(String.format(Locale.ENGLISH,"Unable to deserialize proxy [%s, %s]; could not locate id setter method [%s] on entity class [%s]",serializableProxy.getEntityName(),serializableProxy.getId(),serializableProxy.getIdentifierSetterMethodName(),serializableProxy.getIdentifierSetterMethodClass()));
}
==============================================================================================
PersistenceUtilHelper.java at Line:304 col: 3
catch (InvocationTargetException e) {
  throw new AttributeExtractionException("Unable to access attribute (method): " + method.getDeclaringClass().getName() + "#"+ name,e.getCause());
}
==============================================================================================
EntityTuplizerFactory.java at Line:65 col: 2
catch (ClassNotFoundException e) {
  throw new HibernateException("Could not locate specified tuplizer class [" + tuplizerClassName + "]");
}
==============================================================================================
AssignmentSpecification.java at Line:114 col: 3
catch (Throwable t) {
  throw new QueryException("cannot interpret set-clause assignment");
}
==============================================================================================
JpaCompliantLifecycleStrategy.java at Line:111 col: 3
catch (Exception e) {
  throw new IllegalStateException(new NotYetReadyException(e));
}
==============================================================================================
JtaAwareConnectionProviderImpl.java at Line:209 col: 3
catch (SQLException e) {
  throw new XAException(e.toString());
}
==============================================================================================
SpatialFunctionalTestCase.java at Line:56 col: 2
catch (BatchUpdateException e) {
  throw new RuntimeException(e.getNextException());
}
==============================================================================================
AliasToBeanResultTransformer.java at Line:82 col: 2
catch (InstantiationException e) {
  throw new HibernateException("Could not instantiate resultclass: " + resultClass.getName());
}
==============================================================================================
ReflectHelper.java at Line:280 col: 2
catch (NoSuchMethodException nme) {
  throw new PropertyNotFoundException("Object class [" + clazz.getName() + "] must declare a default (no-argument) constructor");
}
==============================================================================================
OsgiJtaPlatform.java at Line:91 col: 2
catch (Exception e) {
  throw new TransactionException("Could not obtain transaction from OSGi services!");
}
==============================================================================================
OracleTypesHelper.java at Line:61 col: 3
catch (ClassNotFoundException e2) {
  throw new HibernateException(String.format("Unable to locate OracleTypes class using either known FQN [%s, %s]",ORACLE_TYPES_CLASS_NAME,DEPRECATED_ORACLE_TYPES_CLASS_NAME),e);
}
==============================================================================================
BeanInfoHelper.java at Line:60 col: 3
catch (InvocationTargetException e) {
  throw new BeanIntrospectionException("Error delegating bean info use",e.getTargetException());
}
==============================================================================================
SDOGeometryValueBinder.java at Line:83 col: 2
catch (IllegalArgumentException e) {
  throw new HibernateException(e.getMessage());
}
==============================================================================================
UrlInputStreamAccess.java at Line:35 col: 2
catch (Exception e) {
  throw new HibernateException("Could not open url stream : " + url.toExternalForm());
}
==============================================================================================
ScanningCoordinator.java at Line:176 col: 5
catch (NoSuchMethodException ignore) {
  throw new IllegalArgumentException("Configuration named a custom Scanner, but we were unable to locate " + "an appropriate constructor");
}
==============================================================================================
ConfigLoader.java at Line:83 col: 2
catch (FileNotFoundException e) {
  throw new ConfigurationException("Specified cfg.xml file [" + cfgXmlFile.getAbsolutePath() + "] does not exist");
}
==============================================================================================
CustomCollectionType.java at Line:67 col: 2
catch (IllegalAccessException iae) {
  throw new MappingException("IllegalAccessException trying to instantiate custom type: " + userTypeClass.getName());
}
==============================================================================================
EnversRunner.java at Line:65 col: 3
catch (ClassCastException e) {
  throw new Exception(String.format("%s.%s() must return a Collection of arrays.",getTestClass().getName(),getParametersMethod(getTestClass()).getName()));
}
==============================================================================================
SessionFactoryHelper.java at Line:218 col: 2
catch (Exception e) {
  throw new QueryException("collection role not found: " + role);
}
==============================================================================================
ScriptTargetOutputToUrl.java at Line:64 col: 2
catch (IOException e) {
  throw new SchemaManagementException("Unable to close file writer : " + e.toString());
}
==============================================================================================
MethodWriter.java at Line:92 col: 3
catch (CannotCompileException ignored) {
  String msg=String.format("Could not enhance class [%s] to add method [%s] for field [%s]",target.getName(),name,field);
  throw new EnhancementException(msg,cce);
}
==============================================================================================
AbstractLazyInitializer.java at Line:231 col: 3
catch (Exception e) {
  LOG.error("Initialization failure [" + entityName + "#"+ id+ "]",e);
  throw new LazyInitializationException(e.getMessage());
}
==============================================================================================
CollectionType.java at Line:558 col: 2
catch (ClassCastException cce) {
  throw new MappingException("collection role is not queryable " + role);
}
==============================================================================================
QueryTranslatorImpl.java at Line:468 col: 2
catch (Exception e) {
  throw new QueryException("collection role not found: " + role);
}
==============================================================================================
SetterMethodImpl.java at Line:153 col: 3
catch (NoSuchMethodException e) {
  throw new PropertyAccessSerializationException("Unable to resolve setter method on deserialization : " + declaringClass.getName() + "#"+ methodName+ "("+ argumentType.getName()+ ")");
}
==============================================================================================
AbstractEmptinessExpression.java at Line:84 col: 2
catch (Exception e) {
  throw new QueryException("collection role not found: " + role);
}
==============================================================================================
TypeSafeActivator.java at Line:541 col: 6
catch (ClassCastException e) {
  throw new IntegrationException(String.format(Locale.ENGLISH,"ValidatorFactory reference (provided via `%s` setting) was not castable to %s : %s",FACTORY_PROPERTY,ValidatorFactory.class.getName(),value.getClass().getName()));
}
==============================================================================================
JoinedSubclassEntityPersister.java at Line:174 col: 5
catch (ClassCastException cce) {
  throw new MappingException("Illegal discriminator type: " + discriminatorType.getName());
}
==============================================================================================
StandardJaccServiceImpl.java at Line:86 col: 2
catch (Exception e) {
  throw new IntegrationException("Unable to access JACC PolicyConfiguration");
}
==============================================================================================
FumTest.java at Line:910 col: 2
catch (ClassNotFoundException cnfe) {
  throw new IOException("Unable to locate class on reconstruction");
}
==============================================================================================
EntityCopyObserverFactoryInitiator.java at Line:91 col: 3
catch (Exception e) {
  throw new HibernateException("Could not instantiate class of type " + value.getName());
}
==============================================================================================
SessionFactoryHelper.java at Line:189 col: 2
catch (ClassCastException cce) {
  throw new QueryException("collection is not queryable: " + role);
}
==============================================================================================
JavassistProxyFactory.java at Line:185 col: 2
catch (NoSuchMethodException e) {
  throw new HibernateException(String.format(Locale.ENGLISH,"Unable to deserialize proxy [%s, %s]; could not locate id getter method [%s] on entity class [%s]",serializableProxy.getEntityName(),serializableProxy.getId(),serializableProxy.getIdentifierGetterMethodName(),serializableProxy.getIdentifierGetterMethodClass()));
}
==============================================================================================
BmtEmfStatefulBean.java at Line:54 col: 3
catch (Exception e1) {
  throw new RuntimeException("Unable to rollback JTA transaction via UserTransaction",e);
}
==============================================================================================
PersisterFactoryImpl.java at Line:106 col: 3
catch (InvocationTargetException e) {
  Throwable target=e.getTargetException();
  if (target instanceof HibernateException) {
    throw (HibernateException)target;
  }
 else {
    throw new MappingException("Could not instantiate persister " + persisterClass.getName(),target);
  }
}
==============================================================================================
BeanInfoHelper.java at Line:88 col: 3
catch (InvocationTargetException e) {
  throw new BeanIntrospectionException("Error delegating bean info use",e.getTargetException());
}
==============================================================================================
ProxyFactoryFactoryImpl.java at Line:79 col: 3
catch (Throwable t) {
  throw new HibernateException("Unable to instantiated proxy instance");
}
==============================================================================================
SessionImpl.java at Line:3638 col: 2
catch (TransactionRequiredForJoinException e) {
  throw new TransactionRequiredException(e.getMessage());
}
==============================================================================================
MappingBinder.java at Line:73 col: 3
catch (JpaOrmXmlEventReader.BadVersionException e) {
  throw new UnsupportedOrmXsdVersionException(e.getRequestedVersion(),origin);
}
==============================================================================================
AbstractFieldSerialForm.java at Line:39 col: 2
catch (NoSuchFieldException e) {
  throw new PropertyAccessSerializationException("Unable to resolve field on deserialization : " + declaringClass.getName() + "#"+ fieldName);
}
==============================================================================================
MethodWriter.java at Line:65 col: 3
catch (CannotCompileException ignored) {
  String msg=String.format("Could not enhance class [%s] to add method [%s] for field [%s]",target.getName(),name,field);
  throw new EnhancementException(msg,cce);
}
==============================================================================================
SqlASTFactory.java at Line:222 col: 2
catch (Exception e) {
  throw new IllegalArgumentException("Invalid class or can't make instance, " + className);
}
==============================================================================================
CollectionBinder.java at Line:1369 col: 3
catch (MappingException e) {
  throw new AnnotationException("mappedBy reference an unknown target entity property: " + collType + "."+ joinColumns[0].getMappedBy()+ " in "+ collValue.getOwnerEntityName()+ "."+ joinColumns[0].getPropertyName());
}
==============================================================================================
ArchiveHelper.java at Line:91 col: 2
catch (MalformedURLException e) {
  throw new IllegalArgumentException("Unable to determine JAR Url from " + url + ". Cause: "+ e.getMessage());
}
==============================================================================================
JtaAwareConnectionProviderImpl.java at Line:191 col: 3
catch (SQLException e) {
  throw new XAException(e.toString());
}
==============================================================================================
BinderHelper.java at Line:975 col: 4
catch (ClassCastException cce) {
  throw new MappingException("metaType was not a DiscriminatorType: " + metaType.getName());
}
==============================================================================================
EhcacheRegionFactory.java at Line:334 col: 2
catch (InstantiationException|IllegalAccessException e) {
  throw new CacheException("Could not use explicit CacheManager : " + setting);
}
==============================================================================================
Cloneable.java at Line:138 col: 2
catch (Throwable t) {
  throw new HibernateException("Unable to validate listener config");
}
==============================================================================================
CacheMode.java at Line:90 col: 2
catch (IllegalArgumentException e) {
  throw new MappingException("Unknown Cache Mode: " + setting);
}
==============================================================================================
LocalSchemaLocator.java at Line:74 col: 2
catch (IOException e) {
  throw new XmlInfrastructureException("Stream error handling schema url [" + schemaUrl.toExternalForm() + "]");
}
==============================================================================================
JTASessionContext.java at Line:101 col: 3
catch (Throwable t) {
  try {
    currentSession.close();
  }
 catch (  Throwable ignore) {
    LOG.debug("Unable to release generated current-session on failed synch registration",ignore);
  }
  throw new HibernateException("Unable to register cleanup Synchronization with TransactionManager");
}
==============================================================================================
LocalSchema.java at Line:103 col: 2
catch (IOException e) {
  throw new XmlInfrastructureException("Stream error handling schema url [" + schemaUrl.toExternalForm() + "]");
}
==============================================================================================
StandardRefCursorSupport.java at Line:191 col: 3
catch (Exception e) {
  throw new HibernateException("Unexpected error trying to access CallableStatement#getObject(int,Class)");
}
==============================================================================================
BmtSfStatefulBean.java at Line:62 col: 3
catch (Exception e1) {
  throw new RuntimeException("Unable to rollback JTA transaction via UserTransaction",e);
}
==============================================================================================
BytecodeProviderImpl.java at Line:253 col: 2
catch (NoSuchMethodException e) {
  throw new BulkAccessorException("cannot find an accessor",index);
}
==============================================================================================
JPAOverriddenAnnotationReader.java at Line:3034 col: 3
catch (NumberFormatException e) {
  throw new AnnotationException(element.getPath() + attributeName + " not parseable: "+ attribute+ " ("+ SCHEMA_VALIDATION+ ")");
}
==============================================================================================
CollectionBinder.java at Line:683 col: 3
catch (Exception e) {
  throw new AnnotationException(String.format("Could not instantiate comparator class [%s] for %s",comparatorClass.getName(),safeCollectionRole()));
}
==============================================================================================
ScriptTargetOutputToStdout.java at Line:48 col: 3
catch (IOException e) {
  throw new SchemaManagementException("Unable to close file writer : " + e.toString());
}
==============================================================================================
Ejb3JoinColumn.java at Line:850 col: 4
catch (MappingException me) {
  throw new MappingException("Unable to find column with logical name: " + logicalReferencedColumnName + " in "+ matchingTable.getName());
}
==============================================================================================
TypeSafeActivator.java at Line:518 col: 2
catch (ClassCastException e) {
  throw new IntegrationException(String.format(Locale.ENGLISH,"ValidatorFactory reference (provided via %s) was not castable to %s : %s",SessionFactoryOptions.class.getName(),ValidatorFactory.class.getName(),validatorFactoryReference.getClass().getName()));
}
==============================================================================================
JBossAppServerJtaPlatform.java at Line:44 col: 3
catch (JndiException jndiExceptionInner) {
  throw new JndiException("unable to find transaction manager",jndiException);
}
==============================================================================================
CollectionBinder.java at Line:837 col: 3
catch (MappingException e) {
  throw new AnnotationException("mappedBy reference an unknown target entity property: " + collType + "."+ this.mappedBy+ " in "+ collection.getOwnerEntityName()+ "."+ property.getName());
}
==============================================================================================
BlobProxy.java at Line:73 col: 2
catch (IOException ioe) {
  throw new SQLException("could not reset reader");
}
==============================================================================================
ClassTypeDescriptor.java at Line:36 col: 2
catch (ClassNotFoundException e) {
  throw new HibernateException("Unable to locate named class " + string);
}
==============================================================================================
SimpleConvertAnnotationTest.java at Line:93 col: 3
catch (MalformedURLException e) {
  throw new IllegalArgumentException("Could not convert incoming value to URL : " + dbData);
}
==============================================================================================
PersisterFactoryImpl.java at Line:161 col: 3
catch (InvocationTargetException e) {
  Throwable target=e.getTargetException();
  if (target instanceof HibernateException) {
    throw (HibernateException)target;
  }
 else {
    throw new MappingException("Could not instantiate collection persister " + persisterClass.getName(),target);
  }
}
==============================================================================================
UnsavedValueFactory.java at Line:95 col: 3
catch (ClassCastException cce) {
  throw new MappingException("Bad identifier type: " + identifierType.getName());
}
==============================================================================================
MyEntityInstantiator.java at Line:68 col: 2
catch (Throwable t) {
  throw new HibernateException("could not get handle to entity-name as interface : " + t);
}
==============================================================================================
EntityCallback.java at Line:35 col: 2
catch (InvocationTargetException e) {
  if (e.getTargetException() instanceof RuntimeException) {
    throw (RuntimeException)e.getTargetException();
  }
 else {
    throw new RuntimeException(e.getTargetException());
  }
}
==============================================================================================
JaxbCfgProcessor.java at Line:182 col: 2
catch (IOException e) {
  throw new XsdException("Stream error handling schema url [" + url.toExternalForm() + "]",schemaName);
}
==============================================================================================
AbstractJavaTimeTypeTest.java at Line:209 col: 2
catch (ExecutionException e) {
  Throwable cause=e.getCause();
  if (cause instanceof RuntimeException) {
    throw (RuntimeException)cause;
  }
 else   if (cause instanceof Error) {
    throw (Error)cause;
  }
 else {
    throw new IllegalStateException("Unexpected exception while testing",cause);
  }
}
==============================================================================================
Collection.java at Line:149 col: 3
catch (Exception e) {
  throw new MappingException("Could not instantiate comparator class [" + comparatorClassName + "] for collection "+ getRole());
}
==============================================================================================
ComponentTuplizerFactory.java at Line:85 col: 2
catch (ClassLoadingException e) {
  throw new HibernateException("Could not locate specified tuplizer class [" + tuplizerClassName + "]");
}
==============================================================================================
Cloneable.java at Line:80 col: 4
catch (Throwable t) {
  throw new HibernateException("Unable copy copy listener [" + pd.getName() + "]");
}
==============================================================================================
QueryTranslatorImpl.java at Line:232 col: 2
catch (ANTLRException e) {
  LOG.trace("Converted antlr.ANTLRException",e);
  throw new QueryException(e.getMessage(),hql);
}
==============================================================================================
XMLContext.java at Line:138 col: 3
catch (IllegalArgumentException e) {
  throw new AnnotationException("Invalid access type " + access + " (check your xml configuration)");
}
==============================================================================================
QueryTranslatorImpl.java at Line:456 col: 2
catch (Exception e) {
  throw new QueryException("persistent class not found: " + entityName);
}
==============================================================================================
JavassistProxyFactory.java at Line:211 col: 2
catch (NoSuchMethodException e) {
  throw new HibernateException(String.format(Locale.ENGLISH,"Unable to deserialize proxy [%s, %s]; could not locate id setter method [%s] on entity class [%s]",serializableProxy.getEntityName(),serializableProxy.getId(),serializableProxy.getIdentifierSetterMethodName(),serializableProxy.getIdentifierSetterMethodClass()));
}
==============================================================================================
StandardRefCursorSupport.java at Line:209 col: 3
catch (Exception e) {
  throw new HibernateException("Unexpected error trying to access CallableStatement#getObject(String,Class)");
}
==============================================================================================
ScanningCoordinator.java at Line:139 col: 4
catch (NoSuchMethodException e) {
  throw new IllegalArgumentException("Configuration named a custom Scanner and a custom ArchiveDescriptorFactory, but " + "Scanner impl did not define a constructor accepting ArchiveDescriptorFactory");
}
==============================================================================================
EnhancedGetterMethodImpl.java at Line:163 col: 3
catch (NoSuchFieldException e) {
  throw new PropertyAccessSerializationException("Unable to resolve field on deserialization : " + declaringClass.getName() + "#"+ propertyName);
}
==============================================================================================
Dialect.java at Line:305 col: 2
catch (ClassNotFoundException cnfe) {
  throw new HibernateException("Dialect class not found: " + dialectName);
}
==============================================================================================
SessionImpl.java at Line:2031 col: 4
catch (HibernateException e) {
  throw new IllegalArgumentException("Not an entity [" + entityName + "] : "+ object);
}
==============================================================================================
ByteBuddyProxyHelper.java at Line:108 col: 2
catch (NoSuchMethodException e) {
  throw new HibernateException(String.format(Locale.ENGLISH,"Unable to deserialize proxy [%s, %s]; could not locate id getter method [%s] on entity class [%s]",serializableProxy.getEntityName(),serializableProxy.getId(),serializableProxy.getIdentifierGetterMethodName(),serializableProxy.getIdentifierGetterMethodClass()));
}
==============================================================================================
MultiTenantConnectionProviderInitiator.java at Line:76 col: 4
catch (ClassLoadingException cle) {
  log.warn("Unable to locate specified class [" + className + "]",cle);
  throw new ServiceException("Unable to locate specified multi-tenant connection provider [" + className + "]");
}
==============================================================================================
StandardRefCursorSupport.java at Line:91 col: 3
catch (InvocationTargetException e) {
  if (e.getTargetException() instanceof SQLException) {
    throw jdbcServices.getSqlExceptionHelper().convert((SQLException)e.getTargetException(),"Error extracting REF_CURSOR parameter [" + position + "]");
  }
 else {
    throw new HibernateException("Unexpected error extracting REF_CURSOR parameter [" + position + "]",e.getTargetException());
  }
}
==============================================================================================
PersistentClass.java at Line:497 col: 2
catch (MappingException e) {
  throw new MappingException("property [" + propertyPath + "] not found on entity ["+ getEntityName()+ "]");
}
==============================================================================================
DynamicInstantiator.java at Line:57 col: 2
catch (Throwable t) {
  throw new HibernateException("could not get handle to entity-name as interface : " + t);
}
==============================================================================================
ClassLoaderAccessImpl.java at Line:77 col: 4
catch (ClassNotFoundException e) {
  throw new ClassLoadingException(name);
}
==============================================================================================
AbstractEmptinessExpression.java at Line:81 col: 2
catch (ClassCastException cce) {
  throw new QueryException("collection role is not queryable: " + role);
}
==============================================================================================
UnsavedValueFactory.java at Line:98 col: 3
catch (Exception e) {
  throw new MappingException("Could not parse identifier unsaved-value: " + unsavedValue);
}
==============================================================================================
ClassLoadingStrategyHelper.java at Line:46 col: 3
catch (InvocationTargetException exception) {
  if (exception.getCause() instanceof IllegalAccessException) {
    return new ClassLoadingStrategy.ForUnsafeInjection(originalClass.getProtectionDomain());
  }
 else {
    throw new HibernateException(LOG.bytecodeEnhancementFailed(originalClass.getName()),exception.getCause());
  }
}
==============================================================================================
BulkAccessorFactory.java at Line:419 col: 2
catch (NoSuchMethodException e) {
  throw new BulkAccessorException("cannot find an accessor",index);
}
==============================================================================================
OneToOneSecondPass.java at Line:158 col: 3
catch (MappingException e) {
  throw new AnnotationException("Unknown mappedBy in: " + StringHelper.qualify(ownerEntity,ownerProperty) + ", referenced property unknown: "+ StringHelper.qualify(value.getReferencedEntityName(),mappedBy));
}
==============================================================================================
Custom.java at Line:21 col: 2
catch (CloneNotSupportedException cnse) {
  throw new RuntimeException();
}
==============================================================================================
JCacheRegionFactory.java at Line:280 col: 2
catch (InstantiationException|IllegalAccessException e) {
  throw new CacheException("Could not use explicit CacheManager : " + setting);
}
==============================================================================================
AbstractProducedQuery.java at Line:711 col: 4
catch (HibernateException e) {
  throw new QueryParameterException("could not locate parameter at position [" + position + "]");
}
==============================================================================================
TestClassMetadata.java at Line:207 col: 2
catch (InvocationTargetException e) {
  throw new CallbackException(callback,e.getTargetException());
}
==============================================================================================
HqlSqlWalker.java at Line:1483 col: 2
catch (Throwable t) {
  throw new SemanticException("node did not reference a map");
}
==============================================================================================
SingleTableEntityPersister.java at Line:331 col: 4
catch (ClassCastException cce) {
  throw new MappingException("Illegal discriminator type: " + discriminatorType.getName());
}
==============================================================================================
ScanningCoordinator.java at Line:162 col: 4
catch (NoSuchMethodException e) {
  try {
    final Constructor<? extends Scanner> constructor=scannerImplClass.getConstructor();
    try {
      return constructor.newInstance();
    }
 catch (    Exception e2) {
      throw new IllegalStateException("Error trying to instantiate custom specified Scanner [" + scannerImplClass.getName() + "]",e2);
    }
  }
 catch (  NoSuchMethodException ignore) {
    throw new IllegalArgumentException("Configuration named a custom Scanner, but we were unable to locate " + "an appropriate constructor");
  }
}
==============================================================================================
ListenerCallback.java at Line:38 col: 2
catch (InvocationTargetException e) {
  if (e.getTargetException() instanceof RuntimeException) {
    throw (RuntimeException)e.getTargetException();
  }
 else {
    throw new RuntimeException(e.getTargetException());
  }
}
==============================================================================================
FastClass.java at Line:133 col: 2
catch (ArrayIndexOutOfBoundsException e) {
  throw new IllegalArgumentException("Cannot find matching method/constructor");
}
==============================================================================================
SessionFactoryImpl.java at Line:1064 col: 3
catch (MappingException me) {
  if (serializable) {
    return type;
  }
 else {
    throw new HibernateException("Could not determine a type for class: " + typename);
  }
}
==============================================================================================
SingleTableEntityPersister.java at Line:425 col: 5
catch (ClassCastException cce) {
  throw new MappingException("Illegal discriminator type: " + discriminatorType.getName());
}
==============================================================================================
ForeignGenerator.java at Line:110 col: 2
catch (TransientObjectException toe) {
  if (LOG.isDebugEnabled()) {
    LOG.debugf("ForeignGenerator detected a transient entity [%s]",foreignValueSourceType.getAssociatedEntityName());
  }
  if (sessionImplementor instanceof Session) {
    id=((Session)sessionImplementor).save(foreignValueSourceType.getAssociatedEntityName(),associatedObject);
  }
 else   if (sessionImplementor instanceof StatelessSession) {
    id=((StatelessSession)sessionImplementor).insert(foreignValueSourceType.getAssociatedEntityName(),associatedObject);
  }
 else {
    throw new IdentifierGenerationException("sessionImplementor is neither Session nor StatelessSession");
  }
}
==============================================================================================
CustomCollectionType.java at Line:64 col: 2
catch (InstantiationException ie) {
  throw new MappingException("Cannot instantiate custom type: " + userTypeClass.getName());
}
==============================================================================================
AbstractEntityPersister.java at Line:2579 col: 2
catch (StaleStateException e) {
  if (!isNullableTable(tableNumber)) {
    final StatisticsImplementor statistics=getFactory().getStatistics();
    if (statistics.isStatisticsEnabled()) {
      statistics.optimisticFailure(getEntityName());
    }
    throw new StaleObjectStateException(getEntityName(),id);
  }
  return false;
}
==============================================================================================
BeanValidationIntegrator.java at Line:133 col: 4
catch (InvocationTargetException e) {
  if (HibernateException.class.isInstance(e.getTargetException())) {
    throw ((HibernateException)e.getTargetException());
  }
  throw new IntegrationException("Error activating Bean Validation integration",e.getTargetException());
}
==============================================================================================
QueryTranslatorImpl.java at Line:238 col: 2
catch (IllegalArgumentException e) {
  LOG.trace("Converted IllegalArgumentException",e);
  throw new QueryException(e.getMessage(),hql);
}
==============================================================================================
SessionFactoryHelper.java at Line:215 col: 2
catch (ClassCastException cce) {
  throw new QueryException("collection role is not queryable: " + role);
}
==============================================================================================
HCANNHelper.java at Line:59 col: 2
catch (InvocationTargetException e) {
  throw new AssertionFailure("Could not resolve member signature from XProperty reference",e.getCause());
}
==============================================================================================
DefaultIdentifierGeneratorFactory.java at Line:143 col: 2
catch (ClassLoadingException e) {
  throw new MappingException(String.format("Could not interpret id generator strategy [%s]",strategy));
}
==============================================================================================
JarFileBasedArchiveDescriptor.java at Line:119 col: 5
catch (IOException e) {
  throw new ArchiveException(String.format("Unable to access stream from jar file [%s] for entry [%s]",jarFile.getName(),zipEntry.getName()));
}
==============================================================================================
LocalXsdResolver.java at Line:110 col: 2
catch (IOException e) {
  throw new XsdException("Stream error handling schema url [" + url.toExternalForm() + "]",schemaResourceName);
}
==============================================================================================
JPAOverriddenAnnotationReader.java at Line:1883 col: 3
catch (IllegalArgumentException e) {
  throw new AnnotationException(access + " is not a valid access type. Check you xml confguration.");
}
==============================================================================================
JtaAwareConnectionProviderImpl.java at Line:135 col: 2
catch (SystemException e) {
  throw new IllegalStateException("Could not locate current transaction");
}
==============================================================================================
EmbeddableCallback.java at Line:40 col: 2
catch (InvocationTargetException e) {
  if (e.getTargetException() instanceof RuntimeException) {
    throw (RuntimeException)e.getTargetException();
  }
 else {
    throw new RuntimeException(e.getTargetException());
  }
}
==============================================================================================
BaseUnitTestCase.java at Line:94 col: 2
catch (ExecutionException e) {
  throw new RuntimeException(e.getCause());
}
==============================================================================================
EnhancingClassTransformerImpl.java at Line:46 col: 2
catch (final Exception e) {
  throw new IllegalClassFormatException("Error performing enhancement of " + className){
    @Override public synchronized Throwable getCause(){
      return e;
    }
  }
;
}
==============================================================================================
StandardRefCursorSupport.java at Line:125 col: 3
catch (InvocationTargetException e) {
  if (e.getTargetException() instanceof SQLException) {
    throw jdbcServices.getSqlExceptionHelper().convert((SQLException)e.getTargetException(),"Error extracting REF_CURSOR parameter [" + name + "]");
  }
 else {
    throw new HibernateException("Unexpected error extracting REF_CURSOR parameter [" + name + "]",e.getTargetException());
  }
}
==============================================================================================
GetterMethodImpl.java at Line:129 col: 3
catch (NoSuchMethodException e) {
  throw new PropertyAccessSerializationException("Unable to resolve getter method on deserialization : " + declaringClass.getName() + "#"+ methodName);
}
==============================================================================================
StandardRefCursorSupport.java at Line:188 col: 3
catch (NoSuchMethodException e) {
  throw new HibernateException("CallableStatement class does not define getObject(int,Class) method");
}
==============================================================================================
AuxiliaryDatabaseObjectBinder.java at Line:43 col: 3
catch (Exception e) {
  throw new org.hibernate.boot.MappingException(String.format("Unable to instantiate custom AuxiliaryDatabaseObject class [%s]",auxDbObjectImplClass),context.getOrigin());
}
==============================================================================================
DdlTransactionIsolatorJtaImpl.java at Line:102 col: 3
catch (Exception e) {
  throw new HibernateException("Unable to resume JTA transaction after DDL execution");
}
==============================================================================================
AbstractAttribute.java at Line:109 col: 2
catch (Exception e) {
  throw new IllegalStateException("Unable to locate member [" + memberDeclaringClassName + "#"+ memberName+ "]");
}
==============================================================================================
AbstractEntityTuplizer.java at Line:230 col: 2
catch (ClassCastException cce) {
  StringBuilder msg=new StringBuilder("Identifier classes must be serializable. ");
  if (id != null) {
    msg.append(id.getClass().getName()).append(" is not serializable. ");
  }
  if (cce.getMessage() != null) {
    msg.append(cce.getMessage());
  }
  throw new ClassCastException(msg.toString());
}
==============================================================================================
HqlSqlWalker.java at Line:520 col: 2
catch (Exception e) {
  throw new SemanticException(e.getMessage());
}
==============================================================================================
DdlTransactionIsolatorJtaImpl.java at Line:54 col: 2
catch (SystemException e) {
  throw new HibernateException("Unable to suspend current JTA transaction in preparation for DDL execution");
}
==============================================================================================
StatefulPersistenceContext.java at Line:1805 col: 2
catch (HibernateException he) {
  throw new InvalidObjectException(he.getMessage());
}
==============================================================================================
GraphParser.java at Line:42 col: 2
catch (RecognitionException|TokenStreamException e) {
  throw new InvalidGraphException("Error parsing graph string");
}
==============================================================================================
ParameterParser.java at Line:194 col: 6
catch (NumberFormatException e) {
  throw new QueryException("JPA-style positional param was not an integral ordinal");
}
==============================================================================================
CdiBeanContainerBuilder.java at Line:74 col: 3
catch (InvocationTargetException e) {
  throw new HibernateException("Problem building " + containerClass.getName(),e.getCause());
}
==============================================================================================
StandardRefCursorSupport.java at Line:206 col: 3
catch (NoSuchMethodException e) {
  throw new HibernateException("CallableStatement class does not define getObject(String,Class) method");
}
==============================================================================================
ScriptTargetOutputToFile.java at Line:65 col: 3
catch (IOException e) {
  throw new SchemaManagementException("Unable to close file writer : " + e.toString());
}
==============================================================================================
MyEntityInstantiator.java at Line:56 col: 2
catch (Throwable t) {
  throw new HibernateException("could not get handle to entity-name as interface : " + t);
}
==============================================================================================
JPAOverriddenAnnotationReader.java at Line:1677 col: 3
catch (IllegalArgumentException e) {
  throw new AnnotationException(access + " is not a valid access type. Check you xml confguration.");
}
==============================================================================================
DynamicInstantiator.java at Line:47 col: 8
catch (Throwable t) {
  throw new HibernateException("could not get handle to entity as interface : " + t);
}
==============================================================================================
JTSGeometryJavaTypeDescriptor.java at Line:51 col: 2
catch (ParseException e) {
  throw new RuntimeException(String.format("Can't parse string %s as WKT",string));
}
==============================================================================================
ValidationMode.java at Line:57 col: 3
catch (IllegalArgumentException e) {
  throw new HibernateException("Unknown validation mode in " + BeanValidationIntegrator.MODE_PROPERTY + ": "+ modeProperty);
}
==============================================================================================
ExplodedArchiveDescriptor.java at Line:162 col: 4
catch (IOException e) {
  throw new ArchiveException(String.format("Unable to access stream from jar file [%s] for entry [%s]",jarFile.getName(),zipEntry.getName()));
}
==============================================================================================
UrlTypeDescriptor.java at Line:35 col: 2
catch (MalformedURLException e) {
  throw new HibernateException("Unable to convert string [" + string + "] to URL : "+ e);
}
==============================================================================================
JPAMetadataProvider.java at Line:126 col: 5
catch (ClassLoadingException e) {
  throw new IllegalStateException("Default entity listener class not found: " + className);
}
==============================================================================================
JoinedSubclassEntityPersister.java at Line:539 col: 7
catch (ClassCastException cce) {
  throw new MappingException("Illegal discriminator type: " + discriminatorType.getName());
}
==============================================================================================
ScriptSourceInputFromUrl.java at Line:61 col: 2
catch (IOException e) {
  throw new SchemaManagementException("Unable to open specified script source url [" + url + "] for reading");
}
==============================================================================================
MultiTenantConnectionProviderInitiator.java at Line:85 col: 3
catch (Exception e) {
  log.warn("Unable to instantiate specified class [" + implClass.getName() + "]",e);
  throw new ServiceException("Unable to instantiate specified multi-tenant connection provider [" + implClass.getName() + "]");
}
==============================================================================================
FromElementType.java at Line:350 col: 4
catch (SemanticException e) {
  throw new QueryException("Unable to locate persister for subclass named in TREAT-AS : " + treatAsSubclassName);
}
==============================================================================================
EnhancedGetterMethodImpl.java at Line:151 col: 3
catch (NoSuchMethodException e) {
  throw new PropertyAccessSerializationException("Unable to resolve getter method on deserialization : " + declaringClass.getName() + "#"+ methodName);
}
==============================================================================================
HqlSqlWalker.java at Line:974 col: 5
catch (Throwable t) {
  throw new QueryException("could not determine seed value for version on bulk insert [" + versionType + "]");
}
==============================================================================================
AbstractSharedSessionContract.java at Line:967 col: 3
catch (ClassLoadingException e) {
  throw new AssertionFailure("Unable to load class [" + entityClassName + "] declared on named native query ["+ namedQueryDefinition.getName()+ "]");
}
==============================================================================================
JBossAppServerJtaPlatform.java at Line:59 col: 3
catch (JndiException jndiExceptionInner) {
  throw new JndiException("unable to find UserTransaction",jndiException);
}
==============================================================================================
SimpleConvertsAnnotationTest.java at Line:94 col: 3
catch (MalformedURLException e) {
  throw new IllegalArgumentException("Could not convert incoming value to URL : " + dbData);
}
==============================================================================================

---------------OVER CATCH--------------
BeanValidationIntegrator.java at Line:53 col: 3
Exception is catching NoSuchMethodException, IllegalArgumentException, SecurityException, 
Cloneable.java at Line:74 col: 4
Throwable is catching IllegalAccessException, IllegalArgumentException, InvocationTargetException, 
JavassistLazyInitializer.java at Line:66 col: 3
Throwable is catching IllegalArgumentException, InvocationTargetException, IllegalAccessException, 
BaselineSessionEventsListenerBuilder.java at Line:94 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
JarInputStreamBasedArchiveDescriptor.java at Line:76 col: 5
Exception is catching IOException, 
SessionImpl.java at Line:3573 col: 2
RuntimeException is catching IllegalArgumentException, 
OptimizerFactory.java at Line:65 col: 3
Throwable is catching ClassNotFoundException, 
JOnASJtaPlatform.java at Line:26 col: 2
Exception is catching NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException, IllegalAccessException, ClassNotFoundException, 
AbstractLoadPlanBasedLoader.java at Line:200 col: 2
HibernateException is catching MappingException, 
SessionImpl.java at Line:1961 col: 2
RuntimeException is catching IllegalArgumentException, 
Dialect.java at Line:302 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
AbstractEntityPersister.java at Line:2576 col: 2
Throwable is catching SQLException, 
JpaDescriptorParser.java at Line:222 col: 2
Exception is catching IOException, ClassNotFoundException, 
EventListenerRegistryImpl.java at Line:207 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
WebSphereJtaPlatform.java at Line:34 col: 3
Exception is catching ClassNotFoundException, 
OptionalEagerRefNonPKNotFoundTest.java at Line:223 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
JndiServiceImpl.java at Line:209 col: 2
Exception is catching NamingException, 
ScanningCoordinator.java at Line:128 col: 5
Exception is catching IllegalArgumentException, InvocationTargetException, IllegalAccessException, InstantiationException, 
ReflectHelper.java at Line:370 col: 2
Exception is catching NoSuchMethodException, SecurityException, 
SessionImpl.java at Line:780 col: 2
RuntimeException is catching IllegalStateException, 
WildFlyStandAloneJtaPlatform.java at Line:27 col: 2
Exception is catching InvocationTargetException, IllegalAccessException, IllegalArgumentException, 
EntityManagerFactoryBuilderImpl.java at Line:1227 col: 2
Exception is catching IllegalArgumentException, 
AbstractServiceRegistryImpl.java at Line:331 col: 3
Exception is catching IllegalArgumentException, InvocationTargetException, IllegalAccessException, 
BasicProxyFactoryImpl.java at Line:56 col: 2
Throwable is catching InstantiationException, IllegalAccessException, 
WebSphereJtaPlatform.java at Line:61 col: 2
Exception is catching IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, 
EmbeddableCallback.java at Line:33 col: 2
Exception is catching IllegalAccessException, IllegalArgumentException, 
JndiServiceImpl.java at Line:224 col: 2
Exception is catching NamingException, 
SuppliedConnectionProviderConnectionHelper.java at Line:42 col: 3
Throwable is catching SQLException, 
InvocationTargetExceptionTest.java at Line:40 col: 2
Throwable is catching ParseException, 
BatchTest.java at Line:281 col: 2
RuntimeException is catching IndexOutOfBoundsException, 
AbstractCollectionMapper.java at Line:285 col: 2
Exception is catching InvocationTargetException, IllegalAccessException, InstantiationException, IllegalArgumentException, 
ItemAttributeConverter.java at Line:33 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
HiloOptimizerConcurrencyTest.java at Line:133 col: 4
Throwable is catching InterruptedException, 
JBossStandAloneJtaPlatform.java at Line:39 col: 2
Exception is catching InvocationTargetException, IllegalAccessException, IllegalArgumentException, 
ScriptSourceInputFromUrl.java at Line:56 col: 2
IOException is catching UnsupportedEncodingException, 
TypeFactorySerializationTest.java at Line:48 col: 3
HibernateException is catching SerializationException, 
OsgiClassLoader.java at Line:171 col: 4
Exception is catching IOException, 
AbstractPropertiesAuditedTest.java at Line:108 col: 2
Exception is catching IllegalStateException, IllegalArgumentException, 
ReflectionTools.java at Line:161 col: 2
Exception is catching ClassNotFoundException, 
ReflectHelper.java at Line:152 col: 2
Throwable is catching ClassNotFoundException, 
NamedQueryRepository.java at Line:154 col: 3
HibernateException is catching QueryException, MappingException, 
ByteBuddyProxyFactory.java at Line:88 col: 2
Throwable is catching InvocationTargetException, InstantiationException, IllegalAccessException, IllegalArgumentException, 
Helper.java at Line:176 col: 3
Exception is catching SQLException, 
TypeFactory.java at Line:94 col: 2
Exception is catching IllegalArgumentException, InvocationTargetException, InstantiationException, IllegalAccessException, 
GeoDbWkb.java at Line:121 col: 2
Exception is catching SQLException, IOException, 
PersisterFactoryImpl.java at Line:95 col: 3
Exception is catching IllegalAccessException, IllegalArgumentException, InstantiationException, 
ReflectHelper.java at Line:379 col: 2
Exception is catching NoSuchMethodException, SecurityException, 
TestUtil.java at Line:189 col: 2
Exception is catching MalformedURLException, ClassNotFoundException, 
JtaAwareConnectionProviderImpl.java at Line:81 col: 2
Exception is catching SQLException, 
AbstractLogicalConnectionImplementor.java at Line:98 col: 2
Exception is catching SQLException, 
ConnectionProviderInitiator.java at Line:249 col: 3
Exception is catching IllegalAccessException, InstantiationException, 
SuppliedConnectionTest.java at Line:141 col: 2
Throwable is catching SQLException, 
WebSphereLibertyJtaPlatform.java at Line:35 col: 2
Exception is catching InvocationTargetException, IllegalAccessException, IllegalArgumentException, 
Helper.java at Line:85 col: 5
Throwable is catching SQLException, 
FallbackBeanInstanceProducer.java at Line:39 col: 2
Exception is catching IllegalArgumentException, SecurityException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException, 
JdbcIsolationDelegate.java at Line:49 col: 3
Exception is catching SQLException, 
EnhancementTask.java at Line:191 col: 2
Exception is catching FileNotFoundException, IOException, 
SQLFunctionsInterSystemsTest.java at Line:627 col: 8
Exception is catching UnsupportedOperationException, 
GeoDbWkb.java at Line:77 col: 2
Exception is catching IllegalArgumentException, 
TransactionUtil2.java at Line:209 col: 2
Exception is catching TransactionManagementException, 
H2Dialect.java at Line:86 col: 2
Exception is catching ClassNotFoundException, IllegalAccessException, IllegalArgumentException, 
ReflectHelper.java at Line:55 col: 2
Exception is catching NoSuchMethodException, SecurityException, 
JavassistProxyFactory.java at Line:124 col: 2
Throwable is catching InvocationTargetException, IllegalArgumentException, InstantiationException, IllegalAccessException, 
JavassistProxyFactory.java at Line:162 col: 2
Throwable is catching InstantiationException, IllegalAccessException, 
JtaAfterCompletionTest.java at Line:104 col: 3
Exception is catching InterruptedException, 
LocalSchemaLocator.java at Line:57 col: 3
Exception is catching SAXException, 
OrderSequenceGenerationTest.java at Line:82 col: 2
Exception is catching IllegalArgumentException, IllegalStateException, 
HANADecimalTest.java at Line:56 col: 4
Exception is catching SQLException, 
EmbeddableQuery.java at Line:98 col: 2
Exception is catching IllegalArgumentException, 
BootstrapTest.java at Line:228 col: 8
Exception is catching IllegalArgumentException, 
SqlASTFactory.java at Line:248 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
ClassLoaderServiceImpl.java at Line:129 col: 2
Exception is catching ClassNotFoundException, 
ImportSqlCommandExtractorInitiator.java at Line:41 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
ComponentPropertyMapper.java at Line:125 col: 6
Exception is catching InvocationTargetException, IllegalAccessException, IllegalArgumentException, InstantiationException, 
ConfigurationTest.java at Line:22 col: 2
Exception is catching IllegalArgumentException, 
PersisterFactoryInitiator.java at Line:45 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
ClassLoadingStrategyHelper.java at Line:33 col: 2
Exception is catching SecurityException, NoSuchMethodException, 
BulkAccessorFactory.java at Line:67 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
ClobTest.java at Line:60 col: 12
Exception is catching SQLException, 
StatefulPersistenceContext.java at Line:1709 col: 2
HibernateException is catching MappingException, 
DriverManagerConnectionProviderImpl.java at Line:150 col: 3
Exception is catching InstantiationException, IllegalAccessException, 
OptionalLazyNotFoundTest.java at Line:250 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
IdentifierGeneratorHelper.java at Line:109 col: 2
Exception is catching SQLException, 
StandardRefCursorSupport.java at Line:163 col: 2
Exception is catching IllegalAccessException, IllegalArgumentException, InvocationTargetException, 
ConnectionProviderInitiator.java at Line:288 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
EnhancementHelper.java at Line:114 col: 2
Exception is catching IOException, FileNotFoundException, 
MultiTenantConnectionProviderInitiator.java at Line:82 col: 3
Exception is catching IllegalAccessException, InstantiationException, 
SchemaValidator.java at Line:68 col: 2
Exception is catching IOException, 
TypeFactory.java at Line:176 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
OsgiClassLoader.java at Line:83 col: 4
Exception is catching ClassNotFoundException, 
Helper.java at Line:186 col: 5
Throwable is catching SQLException, 
AbstractBinder.java at Line:105 col: 3
Exception is catching XMLStreamException, 
EntityCallback.java at Line:31 col: 2
Exception is catching IllegalArgumentException, IllegalAccessException, 
ByteBuddyProxyHelper.java at Line:83 col: 2
Throwable is catching InstantiationException, IllegalAccessException, 
PersistenceUtilHelper.java at Line:279 col: 3
Exception is catching SecurityException, 
MariaDBExtractSequenceMatadataTest.java at Line:68 col: 3
Exception is catching SQLException, 
BlobTest.java at Line:60 col: 12
Exception is catching SQLException, 
InstrumentedClassLoader.java at Line:48 col: 2
Throwable is catching ClassFormatError, IllegalClassFormatException, ClassNotFoundException, IOException, 
JaxbCfgProcessor.java at Line:99 col: 2
Exception is catching XMLStreamException, 
BeanValidationIntegrator.java at Line:50 col: 2
Exception is catching ClassNotFoundException, 
OracleExtractSequenceMetadataTest.java at Line:62 col: 4
Exception is catching SQLException, 
EnhancerFileNotFoundTest.java at Line:35 col: 8
Exception is catching IOException, 
AbstractAllAuditedTest.java at Line:114 col: 2
Exception is catching IllegalArgumentException, IllegalStateException, 
SpatialFunctionalTestCase.java at Line:107 col: 2
Exception is catching IllegalArgumentException, IllegalAccessException, InstantiationException, 
JdbcEnvironmentInitiator.java at Line:67 col: 3
Exception is catching SQLException, 
CdiBeanContainerBuilder.java at Line:70 col: 3
Exception is catching InstantiationException, IllegalArgumentException, SecurityException, IllegalAccessException, 
MyEntityInstantiator.java at Line:50 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
DatabaseConnectionInfo.java at Line:42 col: 3
Exception is catching InstantiationException, IllegalAccessException, 
BytecodeEnhancerRunner.java at Line:209 col: 5
Throwable is catching ClassFormatError, IOException, ClassNotFoundException, FileNotFoundException, 
BatchTest.java at Line:233 col: 2
RuntimeException is catching IndexOutOfBoundsException, 
AbstractAttribute.java at Line:104 col: 2
Exception is catching NoSuchMethodException, SecurityException, NoSuchFieldException, 
SchemaUpdate.java at Line:138 col: 2
Exception is catching IllegalArgumentException, IOException, 
ScriptSourceInputFromFile.java at Line:80 col: 2
IOException is catching UnsupportedEncodingException, 
ClassLoaderServiceImpl.java at Line:143 col: 2
Exception is catching MalformedURLException, 
AbstractBinder.java at Line:133 col: 2
Exception is catching XMLStreamException, 
SetterFieldImpl.java at Line:40 col: 2
Exception is catching IllegalAccessException, IllegalArgumentException, 
HiloOptimizerConcurrencyTest.java at Line:103 col: 4
Throwable is catching InterruptedException, 
ClassLoaderServiceImpl.java at Line:181 col: 2
Exception is catching IOException, 
DefaultSchemaNameResolver.java at Line:42 col: 2
Exception is catching SecurityException, SQLException, NoSuchMethodException, 
EntityTuplizerFactory.java at Line:87 col: 2
Throwable is catching InstantiationException, IllegalArgumentException, InvocationTargetException, IllegalAccessException, 
ConstructorResultColumnProcessor.java at Line:60 col: 2
Exception is catching IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException, 
StandardRefCursorSupport.java at Line:185 col: 3
Exception is catching SecurityException, 
Cloneable.java at Line:68 col: 2
Exception is catching IllegalAccessException, IntrospectionException, InstantiationException, 
ConnectionProviderBuilder.java at Line:76 col: 2
Exception is catching InstantiationException, IllegalArgumentException, ClassNotFoundException, InvocationTargetException, IllegalAccessException, 
PostgreSQLStoredProcedureTest.java at Line:317 col: 3
Exception is catching SQLException, 
EntityBinder.java at Line:431 col: 2
MappingException is catching DuplicateMappingException, 
AbstractSharedSessionContract.java at Line:814 col: 2
RuntimeException is catching IllegalArgumentException, 
SessionImpl.java at Line:3293 col: 2
RuntimeException is catching IllegalStateException, IllegalArgumentException, 
JdbcEnvironmentImpl.java at Line:310 col: 2
Exception is catching SQLException, 
ManagedBeanRegistryInitiator.java at Line:109 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
SQLExceptionConverterFactory.java at Line:90 col: 2
Throwable is catching IllegalAccessException, ClassNotFoundException, InstantiationException, SecurityException, 
PersisterFactoryImpl.java at Line:93 col: 2
Exception is catching SecurityException, NoSuchMethodException, 
DriverManagerConnectionProviderImpl.java at Line:158 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
PostgreSQL81DialectTestCase.java at Line:92 col: 2
Exception is catching SQLException, UnsupportedOperationException, 
HCANNHelper.java at Line:29 col: 2
Exception is catching SecurityException, 
BootstrapTest.java at Line:567 col: 8
Exception is catching IllegalArgumentException, 
HibernateMethodLookupDispatcher.java at Line:112 col: 5
Throwable is catching SecurityException, IllegalArgumentException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, IllegalAccessException, 
OptimizerFactory.java at Line:74 col: 2
Throwable is catching IllegalArgumentException, SecurityException, InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchMethodException, 
LocalSchema.java at Line:86 col: 3
Exception is catching SAXException, 
SessionImpl.java at Line:1226 col: 2
RuntimeException is catching IllegalArgumentException, 
IsolatedClassLoader.java at Line:42 col: 2
Throwable is catching ClassFormatError, IOException, 
UUIDGenerator.java at Line:69 col: 5
Exception is catching InstantiationException, IllegalAccessException, 
AbstractProducedQuery.java at Line:1069 col: 5
Exception is catching IllegalArgumentException, 
SQLExceptionConverterFactory.java at Line:100 col: 6
Throwable is catching IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException, 
TransactionUtil.java at Line:608 col: 4
Throwable is catching SQLException, 
MutableNaturalIdTest.java at Line:137 col: 2
Throwable is catching IllegalArgumentException, SecurityException, NoSuchFieldException, IllegalAccessException, 
SqlASTFactory.java at Line:208 col: 2
Exception is catching NoSuchMethodException, ClassNotFoundException, IllegalArgumentException, InvocationTargetException, SecurityException, InstantiationException, IllegalAccessException, 
OptionalEagerMappedByNotFoundTest.java at Line:127 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
ScanningCoordinator.java at Line:151 col: 5
Exception is catching IllegalArgumentException, InvocationTargetException, IllegalAccessException, InstantiationException, 
AgroalConnectionProviderTest.java at Line:69 col: 2
Exception is catching SQLException, 
PersisterFactoryImpl.java at Line:151 col: 3
Exception is catching IllegalAccessException, IllegalArgumentException, InstantiationException, 
MetadataSources.java at Line:465 col: 4
Exception is catching IOException, 
JarFileBasedArchiveDescriptor.java at Line:74 col: 5
Exception is catching IOException, 
AbstractPropertiesAudited2Test.java at Line:108 col: 2
Exception is catching IllegalArgumentException, IllegalStateException, 
OracleExtractSequenceMetadataTest.java at Line:98 col: 3
Exception is catching SQLException, 
DerbyDialect.java at Line:84 col: 2
Exception is catching ClassNotFoundException, IllegalAccessException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, 
AuxiliaryDatabaseObjectBinder.java at Line:33 col: 3
Exception is catching IllegalAccessException, InstantiationException, 
ObjectUserType.java at Line:101 col: 2
Exception is catching ClassNotFoundException, IOException, 
LobCreatorBuilderImpl.java at Line:120 col: 4
Throwable is catching IllegalArgumentException, IllegalAccessException, InvocationTargetException, 
JOTMJtaPlatform.java at Line:25 col: 2
Exception is catching InvocationTargetException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, 
ComponentTuplizerFactory.java at Line:103 col: 2
Throwable is catching InstantiationException, InvocationTargetException, IllegalAccessException, IllegalArgumentException, 
AtomikosJtaPlatform.java at Line:23 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
SessionImpl.java at Line:1991 col: 5
HibernateException is catching MappingException, 
HANASearchTest.java at Line:55 col: 4
Exception is catching SQLException, 
AliasToBeanConstructorResultTransformer.java at Line:36 col: 2
Exception is catching IllegalAccessException, InstantiationException, InvocationTargetException, IllegalArgumentException, 
SchemaValidatorTask.java at Line:116 col: 2
Exception is catching IllegalArgumentException, 
LocalXsdResolver.java at Line:76 col: 2
Exception is catching MalformedURLException, 
AttributeConverterDefinition.java at Line:59 col: 2
Exception is catching IllegalAccessException, InstantiationException, SecurityException, InvocationTargetException, IllegalArgumentException, NoSuchMethodException, 
WebSphereExtendedJtaPlatform.java at Line:198 col: 4
Exception is catching IllegalAccessException, InvocationTargetException, IllegalArgumentException, 
ClassLoaderServiceImpl.java at Line:229 col: 2
Exception is catching RuntimeException, IOException, 
InstantiationOptimizerAdapter.java at Line:34 col: 2
Exception is catching IllegalArgumentException, InvocationTargetException, SecurityException, 
CriteriaQueryTranslator.java at Line:577 col: 3
HibernateException is catching QueryException, 
EnhancementTask.java at Line:266 col: 2
IOException is catching FileNotFoundException, 
JBossStandAloneJtaPlatform.java at Line:60 col: 2
Exception is catching InvocationTargetException, IllegalAccessException, IllegalArgumentException, 
BitronixJtaPlatform.java at Line:24 col: 2
Exception is catching IllegalAccessException, InvocationTargetException, NoSuchMethodException, IllegalArgumentException, SecurityException, 
AbstractLobTest.java at Line:33 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
StandardRefCursorSupport.java at Line:88 col: 3
Exception is catching IllegalAccessException, IllegalArgumentException, 
CustomRunner.java at Line:371 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
JmxServiceImpl.java at Line:85 col: 6
Exception is catching InstanceNotFoundException, MBeanRegistrationException, 
TypeFactory.java at Line:146 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
BytecodeEnhancerRunner.java at Line:166 col: 3
Exception is catching SecurityException, InvocationTargetException, IllegalArgumentException, IllegalAccessException, 
PersistenceUtilHelper.java at Line:245 col: 3
Exception is catching SecurityException, 
PersisterClassResolverInitiator.java at Line:45 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
TestClassMetadata.java at Line:81 col: 2
Exception is catching SecurityException, 
TransactionUtil2.java at Line:79 col: 2
Exception is catching TransactionManagementException, 
AbstractHANADialect.java at Line:1524 col: 3
Exception is catching SQLException, 
CriteriaQueryTranslator.java at Line:496 col: 3
HibernateException is catching QueryException, 
AbstractCompositeIdMapper.java at Line:60 col: 6
Exception is catching IllegalArgumentException, InvocationTargetException, InstantiationException, IllegalAccessException, 
HikariCPConnectionProviderTest.java at Line:69 col: 2
Exception is catching SQLException, 
SuppliedConnectionHelper.java at Line:37 col: 3
Throwable is catching SQLException, 
BasicDialectResolver.java at Line:74 col: 3
Throwable is catching IllegalAccessException, InstantiationException, 
LobCreatorBuilder.java at Line:96 col: 5
Throwable is catching InvocationTargetException, IllegalArgumentException, IllegalAccessException, NoSuchMethodException, SecurityException, 
EntityCopyObserverFactoryInitiator.java at Line:88 col: 3
Exception is catching IllegalAccessException, InstantiationException, 
ListenerCallback.java at Line:34 col: 2
Exception is catching IllegalAccessException, 
RuntimeException is catching IllegalArgumentException, 
JtaTransactionAfterCallbackTest.java at Line:114 col: 3
Exception is catching InterruptedException, 
StrategySelectorImpl.java at Line:35 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
SimpleValueBinder.java at Line:510 col: 3
Exception is catching IllegalArgumentException, 
RequiredLazyNotFoundTest.java at Line:177 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
JarInputStreamBasedArchiveDescriptor.java at Line:50 col: 2
Exception is catching IOException, 
ReflectHelper.java at Line:179 col: 2
Throwable is catching ClassNotFoundException, 
JoinedSubclassEntityPersister.java at Line:525 col: 3
Exception is catching AssertionFailure, 
ReflectionTools.java at Line:85 col: 3
Exception is catching NoSuchFieldException, SecurityException, 
ConnectionProviderInitiator.java at Line:348 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
AbstractPropertyMapping.java at Line:424 col: 3
Exception is catching IllegalStateException, UnsupportedOperationException, 
SchemaExport.java at Line:351 col: 2
Exception is catching IOException, IllegalArgumentException, 
MariaDBExtractSequenceMatadataTest.java at Line:61 col: 3
Exception is catching SQLException, 
PropertyBinder.java at Line:421 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
NClobTest.java at Line:73 col: 12
Exception is catching SQLException, 
BootstrapTest.java at Line:114 col: 8
Exception is catching IllegalArgumentException, 
ScriptTargetOutputToFile.java at Line:89 col: 2
IOException is catching UnsupportedEncodingException, 
BytecodeProviderImpl.java at Line:46 col: 2
Throwable is catching IllegalArgumentException, InvocationTargetException, SecurityException, 
BeanValidationIntegrator.java at Line:130 col: 4
Exception is catching IllegalAccessException, IllegalArgumentException, 
ConnectionProviderInitiator.java at Line:268 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
EnversServiceImpl.java at Line:172 col: 2
Exception is catching IllegalAccessException, InstantiationException, IllegalArgumentException, InvocationTargetException, 
BatchBuilderInitiator.java at Line:54 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
SessionFactoryImpl.java at Line:278 col: 2
Exception is catching IllegalArgumentException, 
AggregatedServiceLoader.java at Line:268 col: 3
RuntimeException is catching IllegalArgumentException, 
MavenEnhancePlugin.java at Line:211 col: 2
Exception is catching IOException, FileNotFoundException, 
JndiHelper.java at Line:57 col: 2
Exception is catching NamingException, 
ClassLoaderServiceImpl.java at Line:205 col: 3
Exception is catching IOException, 
WebSphereExtendedJtaPlatform.java at Line:174 col: 4
Exception is catching IllegalAccessException, InvocationTargetException, IllegalArgumentException, 
StandardRefCursorSupport.java at Line:122 col: 3
Exception is catching IllegalAccessException, IllegalArgumentException, 
ProcedureCallImpl.java at Line:718 col: 2
RuntimeException is catching IllegalStateException, 
SuppliedConnectionTest.java at Line:116 col: 2
Throwable is catching SQLException, 
SetHashcodeChangeTest.java at Line:125 col: 2
Exception is catching IllegalStateException, IllegalArgumentException, 
SchemaExportTask.java at Line:186 col: 2
Exception is catching IllegalArgumentException, 
SessionWithSharedConnectionTest.java at Line:261 col: 3
Exception is catching SecurityException, 
MetadataImpl.java at Line:398 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
C3P0ConnectionProvider.java at Line:134 col: 2
Exception is catching NumberFormatException, 
HANABooleanTest.java at Line:68 col: 4
Exception is catching SQLException, 
BootstrapTest.java at Line:586 col: 8
Exception is catching IllegalArgumentException, 
OptionalEagerNotFoundTest.java at Line:159 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
TestClassMetadata.java at Line:137 col: 2
Exception is catching SecurityException, 
SerializationHelperTest.java at Line:106 col: 3
Throwable is catching IOException, ClassFormatError, 
ReflectHelper.java at Line:255 col: 2
Throwable is catching IllegalArgumentException, IllegalAccessException, 
UnsavedValueFactory.java at Line:39 col: 2
Exception is catching IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException, 
QueryTranslatorImpl.java at Line:239 col: 2
Exception is catching SecurityException, 
MappingException is catching PropertyNotFoundException, 
JmxServiceImpl.java at Line:163 col: 2
Exception is catching NotCompliantMBeanException, MBeanRegistrationException, InstanceAlreadyExistsException, 
ListHashcodeChangeTest.java at Line:125 col: 2
Exception is catching IllegalArgumentException, IllegalStateException, 
NamedQueryRepository.java at Line:170 col: 3
HibernateException is catching QueryException, MappingException, 
JaxbCfgProcessor.java at Line:68 col: 4
Exception is catching XMLStreamException, 
SessionFactoryImpl.java at Line:1010 col: 3
Throwable is catching InvocationTargetException, IllegalArgumentException, InstantiationException, IllegalAccessException, 
LobCreatorBuilderImpl.java at Line:122 col: 5
Throwable is catching IllegalArgumentException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, SecurityException, 
AggregatedClassLoader.java at Line:201 col: 3
Exception is catching ClassNotFoundException, 
PersisterFactoryImpl.java at Line:149 col: 2
Exception is catching SecurityException, NoSuchMethodException, 
Cloneable.java at Line:119 col: 2
Throwable is catching IllegalAccessException, IllegalArgumentException, InvocationTargetException, 
UrlInputStreamAccess.java at Line:32 col: 2
Exception is catching IOException, 
MasterDetailTest.java at Line:905 col: 4
Throwable is catching SQLException, 
JarFileBasedArchiveDescriptor.java at Line:152 col: 3
Exception is catching IOException, 
AggregatedServiceLoader.java at Line:230 col: 3
RuntimeException is catching IllegalArgumentException, 
StatisticsInitiator.java at Line:78 col: 3
Exception is catching InstantiationException, IllegalAccessException, 
ClassLoadingStrategyHelper.java at Line:40 col: 2
Throwable is catching IllegalAccessException, IllegalArgumentException, 
CriteriaQueryTranslator.java at Line:552 col: 2
HibernateException is catching QueryException, 
TransactionUtil2.java at Line:129 col: 2
Exception is catching TransactionManagementException, 
CacheableFileXmlSource.java at Line:120 col: 2
Exception is catching IllegalArgumentException, 
ConnectionProviderInitiator.java at Line:358 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
SessionImpl.java at Line:2028 col: 4
HibernateException is catching MappingException, 
DefaultIdentifierGeneratorFactory.java at Line:114 col: 2
Exception is catching InstantiationException, UnsupportedOperationException, IllegalAccessException, 
DefaultRevisionInfoGenerator.java at Line:77 col: 2
Exception is catching InvocationTargetException, IllegalAccessException, InstantiationException, IllegalArgumentException, 
OptionalEagerInEmbeddableNotFoundTest.java at Line:138 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
ScriptTargetOutputToFile.java at Line:76 col: 2
Exception is catching IOException, 
WildFlyStandAloneJtaPlatform.java at Line:43 col: 2
Exception is catching InvocationTargetException, IllegalAccessException, IllegalArgumentException, 
EnversServiceImpl.java at Line:203 col: 2
Exception is catching ClassNotFoundException, 
LobCreatorBuilder.java at Line:94 col: 4
Throwable is catching InvocationTargetException, IllegalArgumentException, IllegalAccessException, 
JndiServiceImpl.java at Line:150 col: 2
Exception is catching NamingException, 
Helper.java at Line:75 col: 3
Exception is catching SQLException, 
HANABooleanTest.java at Line:61 col: 4
Exception is catching SQLException, 
HSQLDialect.java at Line:120 col: 2
Throwable is catching NumberFormatException, IllegalArgumentException, IllegalAccessException, ClassNotFoundException, 
EntityReferenceInitializerImpl.java at Line:105 col: 2
Exception is catching SQLException, 
SessionImpl.java at Line:706 col: 2
RuntimeException is catching IllegalStateException, 
AbstractLobTest.java at Line:46 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
ConfigurationServiceImpl.java at Line:102 col: 3
Exception is catching IllegalAccessException, InstantiationException, 
TypeFactory.java at Line:194 col: 2
Exception is catching InstantiationException, IllegalAccessException, 
VmValueGeneration.java at Line:40 col: 2
Exception is catching InstantiationException, IllegalArgumentException, InvocationTargetException, IllegalAccessException, 
StandardRefCursorSupport.java at Line:203 col: 3
Exception is catching SecurityException, 
BootstrapTest.java at Line:173 col: 8
Exception is catching IllegalArgumentException, 
SchemaUpdateTask.java at Line:171 col: 2
Exception is catching IllegalArgumentException, 
HibernateException is catching SchemaManagementException, 
OracleExtractSequenceMetadataTest.java at Line:78 col: 4
Exception is catching SQLException, 
GetterFieldImpl.java at Line:42 col: 2
Exception is catching IllegalAccessException, IllegalArgumentException, 
EventType.java at Line:95 col: 7
Exception is catching IllegalAccessException, IllegalArgumentException, 
JtaIsolationDelegate.java at Line:171 col: 3
Exception is catching SQLException, 
HANACalcViewTest.java at Line:90 col: 4
Exception is catching SQLException, 
ConnectionProviderInitiator.java at Line:311 col: 2
Exception is catching IllegalAccessException, InstantiationException, 
Loader.java at Line:2110 col: 2
HibernateException is catching MappingException, 
OracleTypesHelper.java at Line:45 col: 2
Exception is catching IllegalAccessException, IllegalArgumentException, 
ProxyFactoryFactoryImpl.java at Line:74 col: 3
Throwable is catching InstantiationException, IllegalAccessException, 
CriteriaCompilingTest.java at Line:238 col: 2
Exception is catching IOException, ClassNotFoundException, 
Environment.java at Line:182 col: 3
Exception is catching IOException, 
